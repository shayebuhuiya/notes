# 计算机网络

## 一、基础

### 1.1 TCP/IP 网络模型

通用网络协议

#### 1.1.1应用层

作用：应用软件实现。应用层专注与软件的应用功能，如：HTTP、FTP、Telnet、DNS、SMTP等。而不需要关心数据是如何传递的。

特点：应用层通常工作在操作系统的**用户态**，传输层及以下通常工作在**内核态**。

#### 1.1.2 传输层

作用：传输控制，为应用层提供网络支持，实现不同设备应用间通信。

传输协议：TCP、UDP。

特点：

1. 数据分块。当传输层传输的数据非常大时，直接传输不好控制，当传输层的数据包大小超过MSS时，需要将数据包分块。
2. 端口。接收方可能会有许多应用需要接受数据，因此需要编号将应用区分开，这个编号就是端口。传输层的报文中会携带端口号，接收方可以根据报文识别接收应用。

#### 1.1.3 网络层

作用：实现不同类型设备间传输，应对实际场景的网络环境。

传输协议：IP协议

特点：

1. 数据分片。当网络层传输的报文加上IP报头组装成IP报文大小超过MTU（以太网中为1500字节）时，路由器会对报文再次进行分片。
2. IP地址。使用IP地址给设备编号，通过子网掩码，路由器会根据目标IP地址的网络前缀决定数据报的下一跳路由器。

<img src=".\图片\路由转发" alt="IP地址的网络号" style="zoom: 50%;" />

#### 1.1.4 网络接口层

作用：实现以太网通信，提供链路级别服务，在以太网、WiFi这样的底层网络上发送原始数据包，工作在网络接口这个层次，使用网络接口标识网络上的设备。

以太网：在局域网内，把附近的设备连接起来，使它们之间可以进行通讯的技术。在判断包的目的地的时候，必须匹配才能发往目的地。

协议：ARP协议

特点：

1. MAC地址。在进行通信时，使用ARP协议获取对方MAC地址，从而发送数据包

#### 1.1.5 总结

TCP/IP网络分成：应用层、传输层、网络层、网络接口层。

<img src=".\图片\tcpip参考模型.drawio.png" alt="img" style="zoom:50%;" />

每层封装格式：

应用层：应用数据 ==》报文（message）

传输层：TCP头+应用数据 ==》段（segment）

网络层：IP头+TCP头+应用数据 ==》包（packet）

网络接口层：帧头+IP头+TCP头+应用数据+帧尾 ==》帧（frame）

所有数据单位可以统称为数据包。

### 1.2 从输入网址到网页显示

我的理解是：

1. **地名（网址）**：就像你想去一个城市或地标，但你需要具体的地址才能真正到达那里。
2. **地图（DNS）**：你查看地图或询问人来得知地名对应的具体地址。在网络中，这个“地址”就是IP地址。
3. **地球（根服务器）**：作为地图的基础，这是开始你的查询的地方，然后逐步缩小范围。
4. **国家-省份-市-区-门牌号**：这是DNS解析过程的层次，从最高级的域到最具体的地址。
5. **判断出发点（路由表）**：你的位置可能有多个出口或道路可选，你会选择一个最佳路径前往目的地。
6. **选择近的地点出发（子网选择）**：这类似于你决定从哪个门或窗出去，或者决定走哪条近的街道或小路，因为它们直接通向你的目的地。
7. **返回的过程**：就像你从目的地返回，你会沿着相同或不同的路径回到出发点。

#### 1.2.1 解析URL

URL组成：以http://xiaolincoding.com/network/1_base/what_happen_url.html#孤单小弟-http为例：

这里包含了：

* 协议部分：http://表示使用HTTP协议来访问该网页
* 域名部分：xiaolincoding.com表示该网页的域名或主机名。表示该网页托管在xiaolincoding.com域名下。
* 路径部分：/network/1_base/what_happen_url.html表示网页的具体位置。其中/表示服务器根目录，这个路径表明网页位于服务器的/network/1_base/目录下，并且文件名为what_happen_url。
* 片段标识符：#孤单小弟-http是URL中的片段标识符，用于指定特定的锚点或目标位置。指示网页的特定段落。

#### 1.2.2 生成发送给Web服务器的请求

解析完URL后，利用这些信息生成HTTP请求。如图：

<img src=".\图片\生成HTTP请求" alt="HTTP 的消息格式" style="zoom: 33%;" />

#### 1.2.3 真实地址查询-DNS

域名层级关系：

* 根DNS服务器（.）
* 顶级域DNS服务器（.com）
* 权威DNS服务器（server.com）

其中根DNS服务器的信息保存在互联网所有DNS服务器中。

域名查询顺序：

1. 查询浏览器缓存
2. 查询操作系统缓存
3. 查询hosts文件
4. 查询本地DNS服务器
   1. 查询根域
   2. 查询顶级域名
   3. 查询权威DNS服务器

#### 1.2.4 协议栈

浏览器（应用程序）调用Socket库，委托协议栈工作，即：

TCP/UDP ==> IP（包括ICMP和ARP） ==> 网卡驱动程序 ==>硬件

如图：

<img src=".\图片\协议栈" alt="img" style="zoom:50%;" />

#### 1.2.5 TCP

**头部格式**：

<img src=".\图片\TCP头部" alt="TCP 包头格式" style="zoom: 45%;" />

头部包括以下部分：

- 源端口号：

  - 标识发送数据的源应用程序或进程的端口号：其中0-1023通常保留给一些总所周知的协议与服务，而较高的端口号通常由**动态**或**临时分配**给客户端应用程序。
  - 连接识别：用于在TCP连接中进行识别。每个TCP连接由源IP地址、源端口号、目标IP地址和目标端口号四元组唯一标识，从而保证每个连接都是唯一的。

- 目标端口号：类似源端口号，标识接受数据的端口

- 序号：解决包**乱序**的问题

- 确认号：确认对方是否收到。如果没有收到就应该重发，解决**丢包**问题。

- 状态位：

  - SYN：发起连接
  - ACK：回复
  - RST：重新连接
  - FIN：结束连接

  TCP面向连接，双方需要维护连接的状态，带状态包的发送可以改变状态。

- 窗口大小：通信双方都需要声明一个窗口大小（缓存大小），表明自己的处理能力，避免发送速度太快（撑死）或者太慢（饿死），从而实现流量控制与拥塞控制。

TCP进行数据传输之前，还需要进行**三次握手**建立连接，如图：

<img src=".\图片\TCP三次握手.drawio" alt="TCP 三次握手" style="zoom:33%;" />

* 服务器监听某个特定端口，处于LISTEN状态。
* 客户端主动发起连接SYN，之后处于SYN-SENT状态。
* 服务端收到发起的连接，返回SYN，并且ACK确认客户端的SYN，之后处于SYN-RCVD状态。
* 客户端收到SYN和ACK之后，发送对SYN确认的ACK，之后处于ESTABLISHED状态。
* 服务端收到ACK的ACK后，处于ESTABLISHED状态。

三次握手的目的就是**确认双方都有一发一收能力**。当某方确认后，就会处于ESTABLISHED状态。

**TCP的连接状态**

可以在Linux通过netstat -napt查看，如图：

![TCP 连接状态查看](.\图片\查看TCP连接状态.drawio)

**TCP分割数据**

如果HTTP请求消息比较长，超过了MSS的长度，这时TCP就需要把HTTP的数据拆解成一块块的数据发送。

<img src=".\图片\TCP分割数据" alt="MTU 与 MSS" style="zoom:50%;" />

* MTU：**一个网络包的最大长度**，以太网中一般为1500字节。
* MSS：**除去IP和TCP头部**后，一个网络包所能容纳的TCP数据的最大长度。

数据会被以MSS的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上TCP头部信息。然后交给IP模块来发送数据。如图：

<img src=".\图片\分割与分片" alt="数据包分割" style="zoom: 50%;" />

TCP不会关注HTTP消息是什么，只会决定传输层需要关注的部分，IP同理。但是**TCP会关注下层**，即IP的MTU以及IP头部大小来决定MSS大小。在建立TCP连接时，客户端和服务器会在TCP握手时交换MSS值。这样双方就知道对方可以接受的最大TCP数据包大小。在后续的数据传输中，TCP会将应用层的数据分割成适当大小的TCP数据包，确保它们不会超过MSS值，从而**避免分片或数据包过大**的问题。

**TCP报文生成**

TCP协议的端口：

* 浏览器监听的端口（随机生成）
* Web服务器监听的端口（HTTP默认端口号80，HTTPS默认443）

在双方建立连接后，将数据部分存入分割后的HTTP数据组成TCP报文，然后交给网络层处理。如图：

<img src=".\图片\完整TCP报文" alt="TCP 层报文" style="zoom: 45%;" />



#### 1.2.6 IP

**IP头部格式**：

<img src=".\图片\IP头部格式" alt="IP 包头格式" style="zoom:30%;" />

在IP头部里包括：

* 源IP地址：客户端输出的IP地址
* 目标地址：即通过DNS域名解析得到的Web服务器的IP
* 协议号：06，表示协议为TCP。

**IP头部的源地址如何选择**：

假设客户端有多个网卡，就会有多个IP地址 ，那么IP头部的源地址应该选择哪个IP？有如下规则：

1. **子网匹配**：如果目标IP与某个接口在同一子网中，那么该接口的IP通常被选择为源IP。
2. **路由表**：当数据需要被路由到其他网络时，主机/设备会查看其路由表以决定出口接口。路由表中可能还会有为特定目标配置的源IP。
3. **操作系统策略**：操作系统可能有默认的策略或算法，例如，它们可能基于接口的度量值（metric）、速度或其他因素来选择源IP。
4. **应用程序指定**：某些应用程序可能会明确指定从哪个IP地址发送数据。
5. **绑定的地址**：服务端应用程序，如Web服务器或数据库，可能会绑定到特定的IP地址。这样，它只会从该特定地址接受和发送数据。
6. **源地址选择算法（RFC 6724）**：这是一个特别为IPv6定义的算法，但也可以应用于IPv4。该算法定义了一个来源和目的地址选择的机制，考虑到多种因素，如前缀的长度、地址的范围、策略表等。
7. **隐私和临时地址**：对于IPv6，有临时地址（隐私扩展）的概念，这意味着源地址可能会定期更改以保护用户的隐私。
8. **连接持久性**：某些协议或应用需要“粘性”连接，即始终从同一个源IP与特定的目标通信，即使其他因素（如路由变化）可能推荐使用不同的源IP。
9. **默认地址选择**：如果没有其他规则或策略明确指示，设备可能会使用其主IP地址（例如，第一个配置的或操作系统默认的接口上的地址）作为源IP。
10. **故障切换**：如果一个接口变得不可用，设备可能会选择另一个接口的IP地址作为源地址。

最简单情况下的路由表就是一个子网选择的过程。

**IP报文的生成**：

<img src=".\图片\IP头部完整格式" alt="IP 层报文" style="zoom:20%;" />

完整IP报文如上。

#### 1.2.7 MAC

如果网络包需要在两点之间传递，则需要加上发送与接收两方的MAC地址。MAC头部如图：

<img src=".\图片\MAC头部" alt="MAC 包头格式" style="zoom: 50%;" />

* 发送方MAC包头：直接从网卡里读取
* 接收方包头：通过ARP协议获取接收方MAC地址。

在TCP/IP通信里，MAC包头的协议类型只使用：

* IP协议：0800
* ARP协议：0806

ARP协议获取目的MAC地址过程如下：

1. **确定下一跳的IP地址**：当主机需要与另一个主机通信时，首先需要查找路由表，以确定数据包的下一跳。如果目标主机与源主机在同一局域网内，那么下一跳就是目标主机。如果不是，则通常下一跳是一个网关或路由器。
2. **查询ARP缓存**：在发送数据之前，主机会首先检查其ARP缓存表，看是否已知下一跳IP地址对应的MAC地址。如果已知，那么可以直接用这个MAC地址，跳过ARP请求步骤。
3. **发送ARP请求广播**：如果ARP缓存中没有相关条目，那么主机会在局域网内发送一个ARP请求广播，询问谁拥有这个IP地址，同时希望其能回复其MAC地址。
4. **接收ARP响应并更新缓存**：拥有所请求IP地址的主机会回复一个ARP响应，其中包含其MAC地址。源主机接收到此响应后，会更新其ARP缓存表，将新的IP到MAC地址映射保存起来，以供将来使用。
5. **发送数据包**：有了目标的MAC地址，源主机可以构造Ethernet帧，并将数据包发送到正确的目的地。

MAC报文生成：

<img src=".\图片\MAC报文" alt="MAC 层报文" style="zoom: 25%;" />

#### 1.2.8 网卡

网络包只是一串二进制数字信息，需要将数字信息转换为电信号才能在网线上传输。

执行这一过程的是网卡，可以使用网卡驱动程序控制网卡，发送过程如下：

1. 网卡获取网络包并将其复制到网卡的缓冲区中。
2. 在开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。
3. 将包转换为电信号，通过网线发送出去。

如图：

<img src=".\图片\数据包.drawio.png" alt="数据包" style="zoom: 67%;" />



#### 1.2.9 交换机

交换机的主要功能为基于MAC地址进行帧转发。具体过程如下：

1. **信号接收**：电信号到达网线接口，交换机中的模块对其进行接收。
2. **信号解析**：交换机里的模块将电信号解析为数字帧（注意：在以太网中，信号本身已经是数字化的）。
3. **错误校验**：通过FCS校验错误。
4. **基于MAC地址转发**：检查交换机MAC地址表，若目的MAC地址存在，则发送到相应端口，否则广播该包并更新MAC地址表。

交换机的MAC地址表如下：

<img src=".\图片\交换机地址表" alt="交换机的 MAC 地址表" style="zoom:40%;" />

两个广播地址：

* MAC地址中的FF:FF:FF:FF:FF:FF
* IP地址中的255.255.255.255

#### 1.2.10 路由器

路由器和交换机的区别：

* 路由器：基于IP设计，三层网络设备，路由器的各个端口都具有MAC地址和IP地址；
* 交换机：基于以太网设计，二层网络设备，交换机的端口不具有MAC地址。

路由器原理：

* MAC地址：路由器端口具有MAC地址，可以成为以太网的收发方。
* IP地址：进行包的转发，网络地址转换NAT、访问控制。

路由器包接收操作：

* 以太网电信号到达网线接口部分，路由器模块将其转换为数字信号，然后通过FCS进行错误校验。
* 基于MAC地址检查是否是发给自己的包，如果不是，则丢弃，如果是，则放到缓冲区中。

查询路由表确定输出端口：

* 更改MAC头部，根据MAC头部后方的IP头部内容进行包的转发。
* 根据路由表选择转发目标，这里与之前的路由转发一样。

路由器包发送操作：

* **查看目的IP**：首先，路由器从数据包的IP头部获取目的IP地址。
* **查询路由表**：路由器查询其路由表，找到与目的IP最匹配的条目。路由表中的条目可能是精确匹配、子网匹配或默认路由。
* **决定下一跳**：基于路由表的查询结果，路由器决定数据包的下一跳。这可以是直接连接的设备（如在同一局域网中的目标主机）或另一个路由器（网关）。
* 根据ARP协议找到目标IP的MAC地址，包会通过交换机到达指定IP。
* **更新MAC帧**。
* **可能会有NAT操作**，即更改源端口号/源IP
* 发送数据包并**更新接口计数器**。

通过层层转发，包最终到达目的地。在这个过程中，源IP与目的IP一直没有变。

#### 1.2.11 总结

总体过程如图：

<img src=".\图片\总体过程" alt="网络分层模型" style="zoom:50%;" />

1. 抵达服务器，检查MAC头部，若符合，则收下。
2. 检查IP头部，发现IP地址符合，根据IP头中的协议项，发现上层是TCP。
3. 检查TCP头部，查看序列号与其他状态位等，若序列号是需要的，则放回缓存并放回ACK，否则丢弃该包。
4. 服务器操作系统发现HTTP进程在监听这个端口，于是将包发给HTTP进程。
5. HTTP进程分析请求后发现客户端需要访问某页面，于是将该网页封装到HTTP相应报文中并发送给客户端。
6. 经过层层包装与层层转发，客户端收到该HTTP相应报文，交给浏览器渲染，网页显示出来了。
7. 最后，客户端结束连接，向服务器发起TCP四次挥手，连接断开。

注意，在路由器转发的时候，路由器只关心IP地址。

### 1.3 Linux中的过程

#### 1.3.1 网络模型

OSI七层模型：

* 应用层：负责给应用程序统一的接口
* 表示层：负责把数据转换成兼容另一个系统能识别的格式
* 会话层：负责建立、管理和终止表示层之间的通信会话
* 传输层：负责端到端的数据传输
* 网络层：负责数据的路由、转发、分片
* 数据链路层：负责数据的封帧和差错检测，以及MAC寻址
* 物理层：负责在物理网络中传输数据帧

TCP/IP网络模型：

* 应用层：负责向用户提供一组应用程序，如HTTP、DNS、FTP等
* 传输层：负责端到端的通信，比如TCP、UDP等
* 网络层：负责网络包的封装、分片、路由、转发，比如IP、ICMP等
* 网络接口层：负责网络包在物理网络中的传输，比如网络包的封帧、MAC寻址、差错检测，以及通过网卡传输网络帧等

两者对应关系示意图：

<img src=".\图片\OSI与TCP.png" alt="img" style="zoom:50%;" />

#### 1.3.2 Linux网络协议栈

网络包封装格式：

<img src=".\图片\封装.png" alt="img" style="zoom:50%;" />

数据链路层并不能传输任意大小的数据包，以太网的这一限制被称为MTU，通常为1500字节。

MTU越大，同等数据量下需要的分包越少，从而提高网络吞吐能力，过大的MTU也可能导致更多的分片，因为其他网络可能MTU更小。

Linux协议栈图示：

<img src=".\图片\协议栈.png" alt="img" style="zoom: 40%;" />

其中：

* 应用程序通过系统调用跟Socket层进行数据交互
* Socket层下面就是传输层、网络层和网络接口层
* 最下层为网卡驱动程序和硬件网卡设备

#### 1.3.3 接收网络包的流程

1. 网卡收到网络包，并使用DMA技术将其写入到指定的内存地址，即Ring Buffer（环形缓冲区），触发硬件中断。
2. （Linux 2.6 NAPI机制）CPU收到硬件中断，根据中断表调用中断处理函数，有以下步骤。
   1. 屏蔽中断
   2. 发起软中断，恢复刚才屏蔽的中断
3. ksoftirqd内核线程（软中断处理线程）收到软中断后开始轮询处理数据：从Ring Buffer中获取一个数据帧，用sk_buff结构表示，从而作为一个网络包交给网络协议栈进行逐层处理。
4. 进入网络接口层，检查报文合法性，若不合法则丢弃，然后找出上层协议类型，去掉帧头帧尾，交给网络层。
5. 进入网络层，判断网络包的走向，决定要转发还是交给上层。若确定要交给上层，则查看上一层的协议，接着去掉IP头部，交给传输层。
6. 进入传输层，去除头部，根据四元组[源IP、源端口，目的IP、目的端口]，找到对应Socket，并把数据放到Socket的接收缓冲区。
7. 应用程序调用Socket接口，将内核Socket接收缓冲区数据拷贝到应用层的缓冲区，唤醒用户进程。

自此，一个网络包发送完毕，如图：

![img](.\图片\收发流程.png)

这个过程的逆过程就是发送的流程。

#### 1.3.4 发送网络包的流程

1. 应用程序调用Socket发送数据包的接口（系统调用），内核申请一个内核态的sk_buff，将用户待发送的数据拷贝到sk_buff内存，并将其加入到发送缓冲区。
2. 网络协议栈从Socket发送缓冲区取出sk_buff，并按照TCP/IP协议从上到下逐层处理。
3. 若使用TCP协议，则会拷贝一个新的sk_buff副本，填充TCP头部。并将其交给网络层，当收到接收端的ACK之后，传输层才会将sk_buff内存释放（TCP可靠传输，支持丢失重传）。
4. 网络层选取路由、填充IP头部、netfilter过滤对超过MTU大小的数据包进行分片，然后将数据包交给网络接口层处理。
5. 网络接口层通过ARP协议获取下一跳的MAC地址，对sk_buff填充帧头和帧尾，接着将sk_buff放到网卡的发送队列中。
6. 上面工作完成后，触发软中断，然后网卡驱动程序从发送队列中读取sk_buff，将其挂到RingBuffer中，然后将sk_buff数据映射到网卡可访问的内存DMA区域，最后将其发送出去。
7. 数据发送完后，网卡触发硬中断释放内存，释放sk_buff内存和清理RingBuffer内存。

在整个发送过程中，涉及了三次内存拷贝操作：

1. 系统调用Socket时，内核申请内核态sk_buff内存，将用户待发送的数据拷贝到sk_buff中。
2. TCP可靠传输会拷贝一个sk_buff副本
3. 当IP层发现sk_buff大于MTU时，申请额外sk_buff，并将原来的sk_buff分为多个小的sk_buff。

在协议栈各层需要对数据包添加包头，为了在层级之间不发生拷贝，只用sk_buff一个结构体来描述所有的网络包，添加包的方式为调整sk_buff中的指针，如图所示：

![img](.\图片\sk_buff.jpg)



## 二、HTTP

### 2.1 HTTP是什么

HTTP是超文本传输协议，即HyperText Transfer Protocol

<img src=".\图片\3-HTTP三部分.png" alt="三个部分"  />

1. 是一种协议
2. 两点传输，可能是服务器到服务器。
3. 传输内容为超文本

所以：**HTTP是在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。**

### 2.2 HTTP状态码有哪些

如图：

<img src=".\图片\6-五大类HTTP状态码.png" alt=" 五大类 HTTP 状态码 " style="zoom: 50%;" />

* **1xx**状态码为提示信息

* **2xx**状态码为服务器成功处理客户端的请求

  * **200 OK**：最常见的状态码，表示一切正常。如果非HEAD请求，通常会有body数据
  * **204 No Content**：常见的状态码，与200 OK基本相同，但响应头没有body数据。
  * **206 Partial Content**：应用于HTTP分块下载或断点续传，表示相应返回的body数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

* **3xx**表示客户请求的资源发生了变动，需要客户端使用新的URL重新发送请求获取资源，即重定向。

  * **301 Moved Permanently**：永久重定向，表示资源不存在了，需要使用新的URL再次访问。
  * **302 Found**：临时重定向，表示请求的资源还在，但暂时需要用另一个URL来访问。

  301和302都会在响应头里使用字段Location，指明后续需要跳转的URL，浏览器会自动重定向新的URL。

  * **304 Not Modified**：不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，告诉客户端可以继续使用缓存资源，用于缓存控制。

* **4xx**类状态码表示客户端发送的报文有误，服务器无法处理

  * **400 Bad Request**：表示客户端请求的报文有错误，但只是个笼统的错误。
  * **403 Forbidden**：表示服务器禁止访问资源，并不是客户端的请求出错
  * **404 Not Found**：表示请求的资源在服务器上不存在或者未找到，无法提供给客户端。

* **5xx**类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。

  * **500 Internal Server Error**：笼统的错误码，并不知道服务器发生了什么错误。
  * **501 Not Implemented**：客户端请求的功能还不支持，类似“即将开业”
  * **502 Bad Gateway**：服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误。
  * **503 Service Unavailable**：表示服务器当前很忙，暂时无法响应客户端，类似“网络繁忙，稍后再试”。

### 2.3 HTTP常见字段

**Host**字段：指定发完同一台服务器上的不同网站

<img src=".\图片\7-HOST字段.png" alt="img" style="zoom: 67%;" />

~~~http
Host: www.A.com
~~~

**Content-Length**字段：表明本次回应的数据长度

<img src=".\图片\8-content-length字段.png" alt="img" style="zoom:75%;" />

~~~http
Content-Length: 1000
~~~

这个字段后面的字节就属于下一个回应了。

HTTP协议通过设置**回车符、换行符**作为HTTP header的**边界**，通过**Content-Length字段**作为HTTP body的**边界**，这两个方式都是为了解决“**粘包**”的问题

**Connection**字段：常用于客户端要求服务器使用HTTP长连接机制，以便其他请求复用。

<img src=".\图片\9-connection字段.png" alt="img" style="zoom:75%;" />

~~~http
GET / HTTP/1.1
Connection: Keep-Alive
~~~

**Content-Type**字段：数据格式

<img src=".\图片\10-content-type字段.png" alt="img" style="zoom:75%;" />

~~~http
// 接受所有格式
Accept: */*	
~~~

~~~http
// 发送网页，编码为UTF-8
Content-Type: text/html; Charset=utf-8		
~~~

**Content-Encoding**字段：数据的压缩方法，表示服务器返回的数据使用了什么压缩格式。

<img src=".\图片\11-content-encoding字段.png" alt="img" style="zoom:75%;" />

~~~http
//客户端可以接受的编码方式
Accept-Encoding: gzip, deflate
~~~

~~~http
//服务器返回的数据采用了gzip压缩格式
Content-Encoding: gzip
~~~

### 2.4 GET与POST

**GET**

1. 目的：通常用于请求数据或信息

2. 数据传递：将参数包含在URL中。例如:

   <http://example.com/page?param1=value&param=value2>

3. 长度限制：因为数据在URL中，所以其长度有限制，这个限制取决于浏览器与服务器，通常限制在2000字左右。

4. 安全性：相对较低。由于所有参数都在URL中，这使得敏感信息容易被暴露（浏览器历史记录、服务器日志、Web缓存等）。

5. 幂等性：GET请求是只读请求，意味着多次执行相同的GET请求，结果应该是相同的。（但是也有例外，取决于开发者如何设置）。

**POST**

1. 目的：通常用于提交数据。
2. 数据传递：数据包含在请求体中，而不是在URL中。
3. 长度限制：理论上没有长度限制，但实际的限制取决于服务器配置。
4. 安全性：相对较高，数据不会出现在URL中，不会轻易暴露。但这并不意味着POST是绝对安全的，数据传输仍然可以被拦截，除非使用了加密（HTTPS）。
5. 幂等性：POST请求不是幂等的，重复发送相同的POST请求可能会产生不同的结果。（也有例外）。

**相同点**

1. 都是HTTP协议中定义的方法。
2. 都可以用于发送请求和传输数据。

**不同点**

1. 数据位置：GET在URL中，POST在请求体中。
2. 安全性：POST相对更安全，因为它不会在URL中暴露数据。
3. 数据大小：GET有大小限制，而POST理论上没有限制。
4. 用途：GET通常用于获取数据，POST通常用于提交数据。
5. 幂等性：GET是幂等的，POST不是。

**RFC2616**

在RFC2616中定义了GET和POST规范的核心语义，即上面所述内容，从这个角度看，有：

* GET方法就是**安全**且**幂等**的，可以对GET获取的数据做缓存，这个缓存可以做到浏览器上，也可以做到代理上（nginx），并且浏览器中GET请求可以保存为书签（就是一个带参数的URL）。
* POST因为是新增或者提交数据，会修改服务器上的数据，所以是**不安全**的，且多次提交就会创建多个资源，所以是**不幂等**的。所以，浏览器不会缓存POST请求，也不能把POST请求存为书签。

在实际开发中，许多细节取决于开发者，比如：

- RFC规范中没有规定GET请求是不能带body的，只是RFC规范中定义的GET请求是获取，这个语义下不需要body。
- POST请求中的URL也可以带有参数。

### 2.5 HTTP缓存技术

**强制缓存**

只要浏览器判断没有过期，就直接使用浏览器的本地缓存，决定使用缓存的主动性在于浏览器这边。

在浏览器按F12后在Network页可以看到请求头部，如下图

<img src=".\图片\强制缓存.png" alt="image-20231012140332417" style="zoom:80%;" />

强缓存是利用下面两个HTTP相应头部实现的（Respond Header），它们都用来表示资源在客户端缓存的有效期：

* Cache-Control，相对时间
* Expires，绝对时间

若两者同时存在，则Cache-Control的优先级高于Expires。

Cache-Control的选项多一些，设置更加精细，实现流程如下：

* 当浏览器第一次访问服务器资源时，服务器会返回这个资源的同时，**在Response头部加上Cache-Control**，其中设置了过期时间大小。
* 浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与Cache-Control中设置的过期时间大小**对比**，计算该资源是否过期，如果没有过期，则使用该缓存，否则向服务器发送请求。
* 服务器再次收到请求后，**更新**Respond头部的Cache-Control。

**协商缓存**

当客户端请求资源时，若收到了**304响应码**，则表明还可以使用本地缓存的资源，通过服务器告诉客户端是否可以使用缓存的方式被称为协商缓存。

<img src=".\图片\缓存etag.png" alt="img" style="zoom: 50%;" />

协商缓存可以通过两种头部实现：

第一种：通过请求头部中的If-Modified-Since字段与响应头部中的Last-Modified字段实现

* **响应头部中的Last-Modified**：当服务器首次相应一个请求的时候，可能会在响应头中加入Last-Modified字段。这个字段表示资源的最后修改时间。

* **请求头部的If-Modified-Since**：其值为之前收到的Last-Modified的值，用来判断资源是否已经过期了。

  具体步骤为：

  1. 客户端想要请求某个资源的时候，首先判断本地是否有缓存，当客户端发现这个缓存可能已经过期时，会向服务器发起请求，将**Last-Modified的值赋给If-Modified-Since**，加在请求头部中。
  2. 服务器收到请求后，**比较**If-Modified-Since的值与Last-Modified的值，如果后者较大，即资源在之后又被修改过，则返回HTTP 200 OK并附上最新的资源。
  3. 否则返回HTTP 304进行缓存重定向，告诉浏览器可以安全使用本地资源。

第二种：通过请求头部的If-None-Match字段与响应头部的ETag字段。

* 响应头部的ETag：唯一标识响应资源；
* 请求头部的If-None-Match：其值为之前收到的响应头部中的ETag中的值，用来判断资源是否变化。

两者方式的区别：**Last-Modified基于时间**，而**ETag基于唯一标识**。

如果两个字段同时出现，则ETag的优先度高于Last-Modified，关系类似于switch-case。

为何ETag优先度更高？

1. 在没有修改文件内容的情况下，文件的**最后修改时间也可能会改变**，这会导致客户端认为这文件被改动了，从而重新请求；
2. 有些文件的修改在秒级以内，而**Last-Modified是秒级**的，使用ETag可以保证一秒钟可以刷新多次。
3. 有些服务器**不能精确获取**文件的最后修改时间。

强制缓存与协商缓存是**配合使用**的，只有在未命中强制缓存的时候，才能发起带有协商缓存字段的请求。

两者关系如图：

<img src=".\图片\http缓存.png" alt="img" style="zoom: 50%;" />

假设客户端已经向浏览器请求过资源了，且服务器正常，则总体流程如下：

1. 浏览器请求访问某个资源，首先查看本地磁盘中Cache-Control / Expires，若存在Cache-Control / Expires且未过期，则直接使用本地磁盘中的资源。
2. 若Cache-Control中的max-age指令指定的缓存时长已过期，浏览器会进一步检查响应头部是否存在ETag字段。若存在，则向请求头中添加If-None-Match字段，其值为本地缓存资源头部中的ETag，并将请求发送给服务器，服务器对比资源的ETag判断资源是否修改，返回200 OK并附上资源或发送304响应，告诉浏览器继续使用磁盘中的资源。
3. 若没有ETag，则浏览器检查响应头部是否存在Last-Modified字段，若存在，则浏览器在请求头部添加If-Modified-Since字段，其值为本地缓存资源头部的Last-Modified值，并将请求发送给服务器，服务器对比资源的修改时间后做出响应。
4. 若既没有ETag字段，也没有Last-Modified字段，则浏览器直接向服务器发送请求，服务器响应200 OK并附上最新的资源。
5. 浏览器得到资源后，对资源进行处理。

### 2.6 HTTP特性

这里主要介绍HTTP/1.1。

**优点**

1. 简单：报文格式为header + body，头部为key-value。
2. 灵活且易于拓展：HTTP协议中的各类请求、URI/URL、状态码、头字段虽然都有标准的方法，但是也可以使用非标准的方法，开发人员可以基于特定需求进行自定义和拓展。
3. 应用广泛和跨平台：HTTP作为基础协议，各种网站、Web应用、在线服务，大多数基于HTTP通信。且HTTP协议**独立于操作系统和硬件平台**，只要是支持网络通信的设备和系统，都可以使用HTTP。
4. **无状态**：不会记忆HTTP的状态，不需要额外资源，节省服务器负担。
5. **明文传输**：传输过程中方便阅读，利于开发调试。

**缺点**

1. **无状态**：不好完成关联性操作，需要很多重复操作确定用户身份。（可以利用Cookie技术解决）
2. **明文传输**：信息裸奔。
3. **不安全：明文（被窃听）、无记忆（伪装）、无法证明报文完整性（篡改）**。

**性能**

1. 长连接：减少TCP连接重复建立与断开，只要一端没有明确提出断开连接，则保持TCP连接状态。或者超过一定时间没有数据交互，服务器会主动断开连接。
2. 管道网络传输：长连接使管道传输成为可能，在同一个TCP连接里，客户端可以发起多个请求，不必等待回应，减少响应等待时间（管道化技术默认是不开启的，且大部分浏览器不支持）。
3. **队头阻塞**：服务器必须按顺序发送管道化请求响应，可能造成队头阻塞，服务器若在第一个请求的处理上阻塞了，后面的请求都将被延迟，直到第一个请求被响应。



### 2.7 HTTP与HTTPS

**结构**

<img src=".\图片\19-HTTPS与HTTP.png" alt="HTTP 与 HTTPS 网络层" style="zoom:67%;" />

**区别**

* HTTP是超文本传输协议，信息是**明文传输**，存在安全风险的问题。HTTPS则解决了HTTP不安全的缺陷，在TCP和HTTP网络层之间加入了**SSL/TLS安全协议**，使得报文能够加密传输。
* HTTP**连接建立**相对简单，TCP三次握手之后便可进行HTTP的报文传输。而HTTPS在TCP三次握手之后，还需要进行SSL/TLS的握手过程，才可进入加密报文传输。
* 两者的默认端口不一样，HTTP默认端口号是**80**，HTTPS默认端口号是**443**.
* HTTPS协议需要向CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。

**解决问题**

* 窃听风险：信息加密，**混合加密**实现信息的机密性。
* 篡改风险：校验机制，**摘要算法**来实现完整性。
* 冒充风险：身份证书，将服务器公钥放入到**数字证书**中，解决冒充风险。

**补充**

1. 混合加密

   <img src=".\图片\20-混合加密.png" alt="混合加密" style="zoom: 67%;" />

   HTTPS采用对称加密和非对称加密结合的混合加密方式：

   * 通信建立前采用**非对称加密**的方式交换会话秘钥
   * 通信过程中**全部**使用**对称加密**的会话秘钥加密明文数据

   使用混合加密的原因：

   * 对称加密只使用一个秘钥，运算**速度快**，秘钥必须保密，无法做到安全的秘钥交换。
   * 非对称加密使用两个秘钥，公钥可以任意分发而私钥保密，解决了秘钥交换问题但**速度慢**。

2. 摘要算法+数字签名

   使用摘要算法（哈希函数）计算内容的哈希值，哈希值唯一且无法通过哈希值推导出内容。

   <img src=".\图片\摘要算法.png" alt="img" style="zoom: 50%;" />

   哈希算法可以保证内容不被篡改，但是不能保证内容+哈希值不会被中间人替换，因为缺少客户端收到的消息是否来自服务端的证明。

   为了避免这种情况，计算机里使用非对称加密算法解决。

   * 公钥：提供给所有人
   * 私钥：只有本人持有

   两个秘钥可以双向加解密：

   * **公钥加密，私钥解密**：保证只有私钥可以解密出实际内容，保证内容传输的安全。
   * **私钥加密，公钥解密**：保证消息来自本人，保证消息不被冒充。

   一般**不使用**非对称加密来加密实际的**传输内容**，因为非对称加密的计算比较耗费性能。

   主要使用私钥加密，公钥解密来确认消息的身份，即**数字签名算法**。

   且加密的不是内容本身，而是内容的**哈希值**。

   <img src=".\图片\数字签名.png" alt="img" style="zoom: 50%;" />

   私钥一般由**服务端**保管，然后服务端向客户端颁发对应公钥。

3. 数字证书

   服务器将自己的公钥注册到CA，CA使用私钥将【服务器信息+服务器公钥+CA数字签名】打包成数字证书，于是客户端可以使用CA提供的公钥解密数字证书，保证服务器公钥来自服务器。

   <img src="D:\notes\图片\22-数字证书工作流程.png" alt="数子证书工作流程" style="zoom: 67%;" />

   黑客难以伪造CA的公私钥，所以数字证书还是非常安全的。

**HTTPS建立连接过程**

SSL/TLS协议基本流程：

* 客户端向服务器索要并验证服务器的**公钥**。
* 双方协商生产**会话秘钥**
* 双方采用**会话秘钥**进行加密通信

前两步就是SSL/TLS的建立过程，也就是TLS握手阶段。现在常用的秘钥交换算法有两种，RSA算法和ECDHE算法，下面为**基于RSA算法的TLS握手过程**。

1. ClientHello

   客户端向服务器发起加密通信请求，包括：

   1. 客户端**支持的TLS协议版本**，如TLS 1.2。
   2. 客户端生成的**随机数（Client Random）**，后面用于生成会话秘钥的条件之一。
   3. 客户端支持的**密码套件列表**，如RSA加密算法。

2. SeverHello

   服务器收到客户端请求后，向客户端发出响应，即SeverHello，包括：

   1. **确认TLS协议版本**，如果浏览器不支持，则关闭通信。
   2. 服务器生产的**随机数（Server Random）**，也就是后面用于生产的会话秘钥条件之一。
   3. 确认的**密码套件列表**，如RSA加密算法。
   4. 服务器的**数字证书**。

3. 客户端回应

   从这里开始加密，只有服务器私钥可以解开报文，保证随机数只被服务器收到。

   客户端收到回应后，首先通过CA公钥确定服务器的数字证书的**真实性**。若没有问题，则从数字证书中取出服务器的公钥，用它加密报文，发送以下信息：

   1. 一个**随机数（pre-master key）**。该随机数会被服务器公钥加密。
   2. **加密通信算法改变通知**，表示随后的信息都将用会话秘钥加密通信。
   3. 客户端**握手结束通知**，同时将之前所有内容的发生的数据做个**摘要**，供服务器校验。

   pre-master key会发送给服务端，所以在客户端与服务端上这个随机数都是一样的。

   服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着用双方协商的加密算法，各自生成本次通信的会话秘钥。

4. 服务器的最后回应

   服务端收到客户端的第三个随机数（pre-master key）后，通过协商的加密算法，计算出本次通信的会话秘钥，然后发送：

   1. **加密通信算法改变通知**，表示随后的信息都将使用会话秘钥加密通信。
   2. 服务器**握手结束通知**，表示服务器的握手阶段已经结束。同时把之前所有内容发生的数据做个**摘要**，供客户端校验。

TLS握手阶段结束，接下来客户端进入加密通信，使用普通的HTTP协议，但使用会话秘钥加密内容。

![HTTPS 连接建立过程](.\图片\23-HTTPS工作流程.png)

客户端验证数字证书流程：

![img](.\图片\证书的校验.png)

CA签发证书：

* 将持有者的公钥、用途、颁发者、有效时间等信息打包，使用Hash计算，得到一个哈希值。
* CA使用自己的私钥将哈希值加密，生成Certificate Signature，即对证书做了签名。
* 将Certificate Signature添加到文件证书上，形成数字证书。

客户端校验证书：

* 首先使用相同的Hash算法获取证书的Hash值H1
* 使用浏览器或者操作系统中的CA公钥信息解密Certificate Signature内容，得到另一个Hash值H2
* 比较H1与H2，若相同，则可信（证书来自CA且未修改）

证书信任链：根CA证书->中间CA证书->服务器证书

将根证书隔离好可以避免整个信任链失效。

**HTTPS如何保证完整性**

TLS在实现上分为握手协议和记录协议两层：

* TLS握手协议就是TLS四次握手的过程，负责协商加密算法和生成对称秘钥，后续用此秘钥来波阿虎应用程序数据（即HTTP数据）
* TLS记录协议负责保护应用程序数据并验证其完整性和来源，所以对HTTP数据加密是使用记录协议

过程如下：

<img src=".\图片\记录协议.png" alt="img" style="zoom: 33%;" />

具体过程如下：

* 首先，消息被**分割**成多个较短的片段，然后对每个片段进行**压缩**。
* 经过压缩的片段被加上**消息认证码**（MAC值，通过哈希算法生成），为了保证完整性，并进行数据的认证。通过MAC码可以识别出篡改。同时，在计算消息认证码时加上了**片段的编码**，以避免重放攻击。
* 经过压缩的片段加上消息认证码会一起通过对称密码进行**加密**。
* 经过上述加密的数据再加上数据类型、版本号、压缩后的长度组成的**报头**就是最终的报文数据。

记录协议完成后，最终的报文数据将传递到传输控制协议TCP层进行传输。

**HTTPS是否安全可靠**

1. 中间人（假基站）

   ![img](.\图片\https中间人.drawio.png)

   * 客户端发起HTTPS建立连接请求，假基站将其转发到一个中间人服务器，中间人服务器向服务端发钱连接请求，此时客户端与中间人进行TLS握手，中间人与服务端进行TLS握手。
   * 客户端与中间人进行TLS握手，中间人将自己的公钥证书给客户端，客户端验证证书真伪，从证书拿到公钥，并生成随机数用公钥加密发送到中间人服务器，中间人服务器使用随机数生成对话秘钥，两者通过对话秘钥进行对话。
   * 服务端发送CA签发的公钥证书给中间人，中间人拿到公钥后生成随机数并使用公钥加密发送给服务端，服务端利用随机数生成对话秘钥，两者通过对话秘钥进行对话。
   * 后续通信中，中间人使用对称秘钥解密客户端HTTPS请求数据，并使用对称秘钥加密数据发送给服务器。同理将服务器的响应转发给客户端。于是中间人监听了全部对话。

   但是中间人的证书是伪造的，没有被CA认证，可以被浏览器识别出，浏览器会提醒用户证书存在问题。

   或者电脑中毒了，被恶意导入中间人的根证书，等同与中间人被信任。

   HTTPS协议目前没有任何漏洞，即使成功进行中间人攻击，也只是利用了客户端的漏洞。

2. 抓包工具

   抓包工具的原理与中间人一致，中间人要拿到私钥只有以下方式：

   1. 去网站服务端拿到私钥
   2. 去CA拿域名签发私钥
   3. 自己签发证书，且被浏览器信任

   抓包工具使用的是第三种方法，在客户端安装了根证书。

可以通过HTTPS双向认证来避免中间人攻击：

![img](.\图片\双向认证.png)

当且仅当客户端与服务端互相认证时，才能进行通信。

### 2.8 HTTP协议的演变

#### 2.8.1 HTTP/1.1

HTTP/1.1相比于HTTP/1.0性能上的改进：

* 使用**长连接**方式改善了HTTP/1.0短连接造成的性能开销。
* 支持**管道**（pipeline）网络传输，只要第一个请求发出去了就可以发送第二个请求了，减少整体的响应时间。

HTTP/1.1的性能瓶颈：

* 请求/响应头部（Header）**未经压缩**就发送，首部信息越多延迟越大，只能压缩Body的部分；
* 发送**冗长的头部**，每次互相发送相同的首部造成的浪费较多。
* 服务器是按请求的顺序响应的，如果服务器响应慢，会导致客户端一直请求不到数据，即**队头阻塞**。
* 没有**请求优先级控制**。
* 请求只能从客户端开始，服务器只能**被动响应**。

#### 2.8.2 HTTP/2

HTTP/2协议是基于HTTPS的，所以HTTP/2的安全性也是有保障的。

<img src=".\图片\25-HTTP2.png" alt="HTT/1 ~ HTTP/2" style="zoom: 80%;" />

HTTP/2相比与HTTP/1.1性能上的改进：

1. **头部压缩**：如果同时发出多个请求，且头部是一样的或者相识的，那么协议会消除重复的部分。即**HPACK**算法：在客户端和服务器同时维护一张头部信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段，只发送索引号，从而提高速度。

2. **二进制格式**：HTTP/1.1使用纯文本形式的报文，而HTTP/2全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧（frame）：头信息帧（Headers Frame）和数据帧（Data Frame）。

   <img src=".\图片\二进制帧.png" alt="HTTP/1 与 HTTP/2 " style="zoom:50%;" />

   计算机收到报文后，无需将明文的报文转换为二进制，而是直接解析二进制报文，**增加数据传输的效率**。

   例：200 HTTP/1.1: 00110010 00110000 00110000，HTTP/2: 10001000，节省了两个字节

   10001000最前面的1表示静态表中已经存在的KV，而200在静态表中的编码为8，二进制为1000

   ![img](.\图片\index.png)

   结合一下就是10001000了

3. **并发传输**：HTTP/1.1实现基于请求响应模型。若第一个请求未被响应，则后续请求无法发送，造成队头阻塞。而HTTP/2引入了Stream：

   <img src=".\图片\stream.png" alt="img" style="zoom: 67%;" />

   1个TCP连接包含多个Stream，Stream里可以包含一个或多个Message，一个Message里包含一条或者多个Frame，Frame为HTTP/2的最小单位，以二进制压缩格式存放HTTP/1中的内容（头部和包体）。

   针对不同的HTTP请求用Stream ID区分，不同Stream的帧可以**乱序发送**。

4. **服务器主动推送资源**：客户端和服务器都可以建立Stream，客户端Stream必须为奇数，服务器Stream必须是偶数。

   客户端获取HTML文件后，可能还需要CSS文件来渲染，如左图。

   <img src=".\图片\push.png" alt="img" style="zoom:67%;" />

   在HTTP/2中，服务器可以主动推送CSS文件，减少消息传递的次数。

HTTP/2缺陷：

* 队头阻塞：HTTP/2的Stream方法只解决了应用层的问题，但是在传输层，HTTP/2基于TCP协议来传输数据，TCP是字节流协议，当前一个字节数据没有到达时，后收到的字节数据只能存放在内核缓冲区中，只有这个数据到达时，HTTP/2应用层才能从内核中拿到数据，还是有队头阻塞问题。

#### 2.8.3 HTTP/3

通过将HTTP下层的TCP协议改成UDP协议解决了队头阻塞的问题。

<img src=".\图片\27-HTTP3.png" alt="HTTP/1 ~ HTTP/3" style="zoom:80%;" />

UDP发送是不管顺序，也不管丢包的，所以不会出现HTTP/2队头阻塞问题，但**基于UDP的QUIC协议**可以实现类似TCP的可靠性传输。

QUIC有以下优点：

1. **无队头阻塞**：QUIC协议与Stream多路复用类似，可以在同一条连接上并发传输多个Stream，Stream可以认为就是一条HTTP请求。**当某个流发生丢包时，只会阻塞这个流**，其它流不会受到影响，因此不会存在队头阻塞问题。而HTTP/2中某个流的数据包丢失了，其它流会受到影响。

   <img src=".\图片\quic无阻塞.jpeg" alt="img" style="zoom: 50%;" />
2. **更快的连接建立**：HTTP/1和HTTP/2使用TCP协议，与TLS分层，分别属于内核实现的传输层、openssl库实现的表示层，因此难以合并在一起。而HTTP/3使用QUIC协议，**不与TLS分层**，QUIC握手包括了连接ID与TLS记录，因此仅需一个RTT就可以同时完成建立连接与秘钥协商。

   <img src=".\图片\28-HTTP3交互次数.png" alt="TCP HTTPS（TLS/1.3） 和 QUIC HTTPS " style="zoom: 80%;" />

   在第二次连接时，应用数据包可以和QUIC握手信息（连接信息与TLS信息）一起发送，达到0-RTT效果。

   ![img](.\图片\0rtt握手.png)
3. **连接迁移**：基于TCP传输协议的HTTP协议通过四元组确定一条TCP连接。

   <img src=".\图片\format,png-20230309231026577.png" alt="TCP 四元组" style="zoom:50%;" />

   当移动设备的**网络从4G切换到WIFI**时，意味着**IP地址变化**，导致连接断开重连，其中包含TCP三次握手，TLS四次握手与TCP慢启动。

   而QUIC协议没有用四元组来绑定连接，而是用连接ID，IP变化之后，只要上下文信息保留，如（ID、TLS密钥等），可以无缝衔接，达到连接迁移功能。

### 2.9 HTTP/1.1如何优化

#### 2.9.1 避免发送HTTP请求

缓存实现：

1. 客户端将第一次请求以及响应的数据保存在本地磁盘上，将URL作为key，将响应作为value。
2. 后续发起请求时，先查看过期时间。
3. 若已过期，则重新发送请求，并在请求的Etag头部带上头部摘要。
4. 服务器查看Etag的摘要并与本地资源做对比。
5. 若过期，则附上最新资源，若未过期，则返回304 Not Modified响应，表示可以从本地读取。

#### 2.9.2 减少HTTP请求次数

**减少重定向次数**：将重定向任务交给代理服务器

<img src=".\图片\代理服务器重定向.png" alt="img" style="zoom:50%;" />

**合并请求**：

* **将多个小文件请求合并成大请求**：为了防止单个请求的阻塞，一般浏览器会同时发起**5-6**个请求，每一个请求都是不同的TCP连接，合并请求可以**减少TCP连接的数量**，省去TCP握手和慢启动过程耗费的时间。可以减少重复发送的HTTP头部。

  有的网站有很多小图片，小图标，**有多少图片，客户端就要发起多少次请求**，可以将所有小图片合成大图片，如何根据css将大图片切割成多个小图片。

  或者使用webpack打包，或者将其二进制数据用base64编码后，以URL形式嵌入到HTML文件中。

* 问题：小资源变化后，客户端必须重新下载整个大资源文件。

**延迟发送请求**：只获取用户可以看到的页面资源。

#### 2.9.3 减少HTTP响应的数据大小

**无损压缩**：gzip、deflate、br

**有损压缩**：静态与动态

### 2.10 HTTPS RSA 握手解析

**TLS第一次握手**

发送**Client Hello**消息：TLS版本号、支持的密码套件、生成的随机数

**TLS第二次握手**

收到Client Hello消息，返回**Server Hello**，确定TLS版本是否支持、选择合适密码套件、给出随机数

密码套件基本形式：秘钥交换算法+签名算法+对称加密算法+摘要算法

返回**Server Certificate**，包含数字证书，证明身份

发送**Server Hello Done**消息，结束握手

**TLS第三次握手**

发送**Client Key Exchange**：客户端生成新的随机数（pre-master)，用服务器的RSA公钥加密该随机数。

客户端生成会话秘钥**Master Secret**，发送**Change Cipher Spec**，告诉服务端开始使用加密方式发送消息

发送**Encrypted Handshake Message (Finished)**消息，对之前的消息做一个摘要，并使用master secret加密，验证服务器的**加密通信是否可用**、**握手消息是否被篡改**。

**TLS第四次握手**

服务器发送**Change Cipher Spec**和**Encrypted Handshake Message**，握手完成，之后的消息全部使用会话秘钥加解密HTTP请求和响应。

**RSA秘钥协商缺陷**：服务器私钥泄露，则master secret可以被第三方截获。

### 2.11 HTTPS ECDHE 握手解析

#### 2.11.1 ECDHE原理

和RSA对比：RSA不具备前向安全性

**离散对数**: 
$$
a^i\ mod\ p = b
$$
**DH算法**

G与P公开，A与B分别为a与b私钥对应的公钥
$$
A = G^a\ mod\ P \\
B = G^b\ mod\ P \\
K = B^a\ mod\ P = A^b\ mod\ P
$$
K即为对称加密秘钥，可以作为会话秘钥使用。

一般而言，服务器私钥不变，客户端私钥会改变，但是通过大量的秘钥交换，服务器私钥可以被破解，因此**DH算法不具备前向安全性**。

**DHE算法**

算法私钥在每次秘钥交换通信时都随机生成，因此每个通信过程的私钥之间都是没有任何关系的，保证了**前向安全**。

缺点：性能不佳，使用了大量的乘法。

**ECDHE算法**

在DHE算法的基础上利用ECC椭圆曲线特性，使用更少的计算量计算出公钥，以及最终会话秘钥。

秘钥交换过程：

* 协商椭圆曲线参数与曲线上的基点，信息公开。
* 生成随机数作为私钥d，与基点G相乘得到公钥Q（Q = dG），双方都获得公私钥。
* 双方交换公钥，计算点（x,y) = dQ，由于d1Q2 = d1d2G = d2Q1，所以双方坐标一样，并将其作为会话密钥。

#### 2.11.2 ECDHE握手过程

**TLS第一次握手**

Client Hello： TLS版本、客户端随机数、密码套件列表

**TLS第二次握手**

Server Hello： TLS版本号、服务器随机数、密码套件

Server Certificate： 证书

Server Key Exchange： 选择椭圆曲线、生成随机数作为私钥、计算椭圆曲线公钥

Server Hello Done

**TLS第三次握手**

校验数字证书是否合法

Client Key Exchange： 生成随机数作为私钥、计算客户端公钥并发送

最终会话密钥：客户端随机数+服务端随机数+x（ECDHE算法算出的共享密钥）

Change Cipher Spec：后续改用对称算法加密通信

Encrypted Handshake Message：将之前发送的数据做一个摘要。

自此，客户端可以开始发送HTTP请求。

**TLS第四次握手**

Change Cipher Spec

Encrypted Handshake Message

双方验证加密解密没问题，握手完成。

### 2.12 HTTPS 如何优化

为何要优化HTTPS：数据安全性

优化角度：

![image-20240102153708561](.\图片\HTTPS优化.png)

#### 2.12.1 性能损耗

相对于HTTP协议产生额外性能消耗的两个环节：

* TLS协议握手过程

  TLS协议增加了网络延时（最长2RTT），握手中的其它步骤也产生性能消耗

  * ECDHE密钥协商算法，客户端与服务端都需要临时生成椭圆曲线公私钥
  * 客户端验证证书会访问CA获取CRL或者OCSP，验证服务器的证书是否被吊销
  * 算法计算Pre-Master，即对称加密密钥

* 握手后的对称加密报文传输

  主流的对称加密算法AES、ChaCha20性能都很好，而且CPU厂商还针对该过程做了硬件级别的优化。

第一阶段额外消耗如图：

![image-20240102155048319](D:\Xiao\note\图片\HTTPS额外消耗.png)



#### 2.12.2 硬件优化

HTTPS协议是**计算密集型**，而不是I/O密集型

可以选择支持AES-NI特性的CPU，该款CPU在指令级别优化了AES算法，加速了数据的加密解密传输过程。

#### 2.12.3 软件优化

* 软件升级

  将OpenSSL升级为更高版本...

  软件升级可能可以优化以前软件的问题或者性能，但同样会花费时间与人力。

#### 2.12.4 会话复用

TLS握手的目的就是协商处会话密钥，即对称加密密钥，如果可以服用这个密钥，则可以减少TLS握手的性能损耗。

这种方式就是会话复用（TLS session resumption），会话复用分两种：

* Session ID；
* Session Ticket；

**Session ID**

客户端和服务器首次TLS握手连接后，双方都会在内存缓存会话密钥，并用唯一的Session ID来标识，Session ID和会话密钥相当于key-value的关系。

客户端想要再次连接时，hello消息中会带上Session ID，服务器收到后会在内存中找。为了安全性，内存中的会话密钥会**定期失效**。

<img src=".\图片\Session resume.png" alt="image-20240102182752806" style="zoom:150%;" />

缺点：

* 服务器必须保持与每一个客户端的会话密钥，随着客户端的增多，**服务器的内存压力也会越来越大**。
* 网站一般都是多台服务器通过负载均衡提供服务的，**客户端再次连接不一定会命中上次访问过的服务器**，于是还是要走完整的TLS握手过程。

**Session Ticket**

服务器不再缓存每个客户端的会话密钥，而是把缓存的工作交给了客户端，类似于HTTP的cookie。

客户端与服务器首次建立连接时，服务器会加密会话密钥作为Ticket发给客户端，交给客户端缓存该Ticket，客户端再次连接时，只需要发送Ticket，由服务器解密并验证有效期后，就可以恢复会话了。

![image-20240102183816284](.\图片\Session resume with ticket.png)

对于集群服务器，要**确保每台服务器加密会话密钥的密钥是一致的**，这样客户端携带Ticket访问任意一台服务器时，都能恢复会话。

Session ID和Session Ticket都**不具备前向安全性**，因为一旦加密会话密钥的密钥被破解或者服务器密钥被泄露，前面劫持的通信密文都会被破解。

同时应对**重放攻击**也很困难。避免重放攻击 的方式就是需要对会话密钥设定一个**合理的过期时间**。

**Pre-shared Key**

Session ID和Session Ticket都需要1RTT才能恢复会话，而TLS1.3只需要0RTT就可以恢复重连：客户端会将Ticket和HTTP请求一同发送给服务端，这种方式叫Pre-shared Key。

![image-20240102185542431](图片\TLS1.3重连.png)

同样的，Pre-shared Key也有重放攻击的风险。

![image-20240102190008568](图片\重放攻击.png)

应对重放攻击可以对会话密钥设定一个合理的过期时间，以及只针对安全的HTTP请求GET/HEAD使用。

#### 2.12.5 协议优化

* 协议优化

  密钥交换算法优化：RSA==》ECDHE

  尽量选择x25519曲线（目前最快的椭圆曲线）

  可以使用AES_128_GCM代替AES_256_GCM（安全性较低，但密钥长度短）

  TLS升级：简化握手步骤（1RTT）、安全性更高

从TLS1.2到TLS1.3：

![image-20240102160725025](.\图片\TLS升级.png)

TLS1.3将Hello和公钥交换合并，这样就可以1RTT完成握手。

TLS1.3还废除了不支持前向安全性的RSA和DH算法，只支持ECDHE算法，避免降级攻击。

#### 2.12.6 证书优化

为了验证服务器的身份，服务器会在TLS握手过程中，将自己的证书发给客户端，以此证明自己身份是可信的。

对于证书的优化，有两个方向：

* 证书传输
* 证书验证

**证书传输优化**

减小证书的大小，可以节约带宽，也可以减少客户端的运算量。所以尽量选择椭圆曲线证书（ECDSA）证书，而不是RSA证书，在相同安全强度下，**ECC密钥长度比RSA短得多**。

**证书验证优化**

客户端在验证证书时，不仅需要用CA公钥解密证书，以及用签名算法验证证书的完整性，还需要去访问CA，下载CRL或者 OCSP数据，确认证书的有效性。

整个访问过程为HTTP访问，会产生一系列网络通信的开销，如DNS查询、建立连接、收发数据等。

**CRL**

证书吊销列表（Certificate Revocation List），由CA定期更新，存在两个问题：

* 一个证书被吊销后，客户端在更新CRL之前还是会信任这个证书，实时性较差；
* 随着吊销证书增多，列表越来越大，下载速度慢，查询时还需要遍历整个列表，延时大，拖慢了HTTPS连接。

**OSCP**

在线证书状态协议（Online Certificate Status Protocol），向CA发送查询请求，让CA返回证书的有效状态。

解决了实时性问题，但同样需要发生网络请求，如果网络不好，或者CA服务器繁忙，同样会导致延时变大。

**OSCP Stapling**

**服务器**向CA周期性查询证书状态，获得一个带有时间戳和签名的响应结果并缓存。

当客户端发起连接请求时，服务器将响应结果发给客户端。由于有签名的存在，服务器无法篡改，因此客户端就能得知证书是否已经被吊销了，这样客户端就不需要查询了。

### 2.13 HTTP/2 优点

#### 2.13.1 HTTP/1.1的性能问题

现在的站点和以前的相比：

* 消息的大小变大了
* 内容资源变多了
* 内容形式变多样了
* 实时性要求变高了

从而引发HTTP/1.1的最大性能问题：高延迟。主要原因如下：

* **延迟难以下降**，虽然现在带宽比以前高，但是延迟降到一定幅度后，就很难再下降了。
* **并发连接有限**，谷歌浏览器的最大并发连接数是6个，并且每一个连接都要经过TCP和TLS握手耗时，以及TCP慢启动过程给流量带来的影响 。
* **队头阻塞问题**，同一连接下，只能完成一个HTTP请求和响应后，才能进行下一个处理。
* **HTTP头部巨大且重复**，HTTP协议无状态，每一个请求都需要携带HTTP头部，特别对于有携带Cookie的头部，Cookie的大小通常很大。
* **不支持服务器推送消息**，当客户端需要获取通知时，只能通过定时器不断拉取消息。

在前面列举了一系列对于HTTP/1.1的优化，如：将一个页面的资源分散到不同域名，提升并发连接上限，因为浏览器对于同一域名的HTTP连接最大只能是六个。

尽管对于HTTP/1.1协议的优化手段如此多，但是这些手段都是队HTTP/1.1的外部作优化，而一些**关键地方没办法优化**，如请**求-响应模型**、**头部巨大且重复**、**并发连接耗时**、**服务器不能主动推送**等，要改变这些必须重新设计HTTP协议（积重难返） 

#### 2.13.2 兼容HTTP/1.1

如果不能兼容老版本的协议，则新协议的推广相当困难，HTTP/2做到了兼容HTTP/1.1。

* **HTTP/2没有在URI里引入新的协议名**，仍然用**http://表示明文协议**，用**https://表示加密协议**，只需要浏览器和服务器在背后自动升级协议，用户意识不到协议的升级。

* **只在应用层做了改变**，还是基于TCP协议传输，应用层方面为了保持功能上的兼容，将HTTP分解成了**语义**和**语法**两个部分，**语义层不做改动**，与HTTP/1.1完全一致，比如请求方法、状态码、头字段等规则保留不变。

  但是在语法层面做了很多改造，基本改变了HTTP报文的传输格式。

#### 2.13.3 头部压缩

HTTP报文由 **Header + Body** 构成，对于Body部分，HTTP/1.1协议可以使用头字段Content-Encoding指定Body的压缩方式，比如使用gzip进行压缩，但报文中的另外一部分Header没有优化手段。

Header部分存在以下问题：

* 含很多固定的字段，如Cookie、User Agent、Accept等，这些字段加起来也高达几百字节甚至上千字节，所以有必要**压缩**。
* 大量的请求和响应的报文里有很多字段值都是重复的，这样会使得大量带宽被这些冗余的数据占用，所以有必要**避免重复性**。
* 字段是ASCII编码，易于人类观察，但效率低，有必要**改成二进制编码**。

HTTP/2没有使用gzip来压缩头部，而是使用**HPACK算法**，HPACK算法主要包含三个部分：

* 静态字典
* 动态字典
* Huffman编码（压缩算法）

客户端和服务器两端都会建立和维护字典，用长度较小的索引号表示重复的字符串，再用Huffman编码压缩数据，可达到50%~90%的高压缩率。

**静态表编码**

HTTP/2为高频出现在头部的字符串与字段建立了一张静态表，它是写入到HTTP/2框架里的，共有61组：

<img src="图片\HTTP2静态表.png" alt="image-20240102195902078" style="zoom: 50%;" />

Index表示索引（Key），Header Value表示索引对应的Value，Header Name表示字段的名字。

HTTP/2头部基于二进制编码，不需要\r\n作为分隔符，改用字符串长度（Value Length）来分割Index和Value。

**动态表编码**

第一次发送了一个消息后，下一次发送可以不用重复发送这个字段的数据，只用发一个字节的Index号就好了，因为双方都可以根据自己的动态表获取到字段的数据。

前提：必须**同一个连接上**，重复传输**完全相同的HTTP头部**，如果消息字段在一个连接上只发送了1次，或者重复传输时，字段总是略有变化，动态表就无法被充分利用了。

动态表过大同样会对服务器内存造成占用，Web服务器都会提供类似**http2_max_requests**的配置，限制一个连接上能够传输的请求数量，到达上限后，就会关闭HTTP/2连接来释放内存。

**Huffman编码**

在静态表中，有的index没有对应的Header Value，表示这些Value并不是固定的，而是变化的，这些Value都会经过Huffman编码后，才会发送出去。

如：server: nghttpx\r\n

![image-20240102203416394](.\图片\Huffman.png)

根据RFC7541规范，如果头部属于静态表范围，且Value是变化，则HTTP/2头部前两位固定为01，所以整个头部格式如下：

![image-20240102203600935](.\图片\编码举例.png)

HTTP/2头部基于二进制编码，不需要\r\n作为分隔符，改用字符串长度分割Index和Value。

第一个字节，Server的Index为54，二进制为110110，加上固定01，即01110110。

第二个字节表示Value首个比特位表示是否经过Huffman编码，剩余7位表示Value的长度，即10000110。

在统计大量HTTP头部后，HTTP/2根据出现频率将ASCCI编码为Huffman编码。故，后面六位为：

![image-20240102204203164](图片\nghttpx的Huffman编码.png)

#### 2.13.4 二进制帧

HTTP/1.1的响应和HTTP/2的区别：

![image-20240103143040433](图片\HTTP2二进制帧.png)

HTTP/2将响应报文划分为两类帧：

* HEADERS（首部）
* DATA（消息负载）

200 OK在两代HTTP中的区别：

* HTTP/1.1: 00110010 00110000 00110000
* HTTP/2: 10001000

HTTP/2二进制帧的结构：

![image-20240103143902872](图片\HTTP2二进制帧格式.png)

包括：

* 帧头（Frame Header）：表示帧数据（Frame Playload）的长度

* 帧类型：HTTP/2一共定义了10种类型的帧，一般分为数据帧和控制帧：

  ![image-20240103144221045](图片\HTTP2帧头类型.png)

* 标志位：携带简单的控制信息

  * END_HEADERS：表示头数据结束标志，相当于HTTP/1空行（\r\n）。
  * END_Stream：表示单方向数据发送结束，后续不会再有数据帧。
  * PRIORITY：表示流的优先级。

* 流标识符（Stream ID）：最高位保留不用，共31位，用来标识Frame属于哪个Stream，从而使接受方有序组装信息。

* 帧数据：存放HPACK算法压缩过的HTTP头部和包体。

#### 2.13.5 并发传输

HTTP/2通过Stream，实现多个Stream复用一条TCP连接，达到并发的效果，解决了HTTP/1.1对头阻塞的问题，提高了HTTP传输的吞吐量。

<img src="图片\HTTP2连接格式.png" alt="image-20240103150909010" style="zoom: 50%;" />

* 1个TCP连接种包含一个或多个Stream，Stream是HTTP/2并发的关键技术。
* Stream里可以包含1个或者多个Message，Message对应HTTP/1中的请求或响应，由HTTP头部和包体构成。
* Message包含一条或者多个Frame，Frame是HTTP/2最小单位，以二进制压缩格式存放HTTP/1中的内容（头部和包体）。

![image-20240103151547129](图片\HTTP2连接.png)

**不同Stream的帧可以乱序发送**（有Stream ID），而**同一Stream内部的帧必须是严格有序的**。

客户端和服务器双方都可以建立Stream，因为服务端可以主动推送资源给客户端，**客户端**建立的Stream必须是**奇数号**，**服务器**建立的Stream必须是**偶数号**。

同一个连接中的Stream ID是不能复用的，只能顺序递增，当Stream ID耗尽时，需要发送控制帧**GOAWAY**关闭TCP连接。

在Nginx中，可以通过**http2_max_concurrent_Streams**配置来设置Stream的上限，默认为128个。

**并发速度对比**：HTTP/2通过**Stream实现并发**，HTTP/1.1通过**TCP连接实现并发**。HTTP/2建立100个Stream，只需要一次TCP连接，而HTTP/1.1需要建立100个TCP连接，每个TCP连接都需要经过TCP握手、慢启动、TLS握手过程，**更耗时**。

**Stream优先级**：通过优先级设置，如服务器先传HTML/CSS，再传图片，可以提高用户体验。

#### 2.13.6 服务器主动推送资源

当客户端获取HTML文件的时候，可能还需要css文件来渲染界面：

<img src="图片\主动推送.png" alt="image-20240103153526732" style="zoom:50%;" />

HTTP/2主动推送可以减少消息传递的次数。

且服务器主动推送是在不同的Stream，可以与原Stream并发。

<img src="图片\主动推送过程" alt="img" style="zoom:50%;" />

服务器推送资源时，会通过**PUSH_PROMISE**帧传输HTTP头部，并通过**Promised Stream ID**字段告知客户端，接下来会在哪个偶数号Stream发送包体。

#### 2.13.7 总结

HTTP/2还有很多内容，如流控制、流状态、依赖关系等。

上面主要记录了HTTP/2提升性能的几个方向：

* 静态表和Huffman编码，与针对后序请求头部的动态表。
* Stream并发：节约了TCP和TLS握手时间，减少了TCP慢启动阶段对流量的影响。
* 服务器主动推送资源：通过发送PUSH_PROMISE帧，告知客户端服务器将在哪个Stream发送资源。

HTTP/2的限制：HTTP/2是基于TCP协议的，**TCP是字节流协议**，必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区的数据返回给HTTP应用，当前1字节数据没有到达时，后序字节数据只能存放在内核缓冲区中，只有这1字节数据到达时，HTTP/2应用层才能从内核中获取数据，即**HTTP/2队头阻塞问题**（同1 Stream内必须有序？TCP并不知道HTTP流是什么）。

### 2.14 HTTP/3 优点

#### 2.14.1 HTTP/2的缺陷

**队头阻塞**

HTTP/2多个请求是跑在一个TCP连接中的，当TCP丢包时，整个TCP都要等待重传，会阻塞该TCP连接中的全部请求。

![image-20240103162822284](图片\HTTP2队头阻塞.png)

TCP是字节流协议，TCP层必须保证收到的字节数据是完整且有序的，如果序列号较低的TCP段在网络传输中丢失了，即使序列号较高的TCP段已经被接收了，应用层也无法从内核中读取到这部分数据，从HTTP视角看，就是请求被阻塞了。

<img src="图片\TCP包传输阻塞.png" alt="image-20240103163210150" style="zoom: 50%;" />

TCP中每个Packet都有自己的序号，当前面的包丢失，后面的包无法读取。

**握手延迟**

发起HTTP请求时，需要经过TCP三次握手和TLS四次握手的过程（TLS 1.2）因此共需要3个RTT的时延才能发出请求数据。

![image-20240103163652053](图片\TCP与TLS连接.png)

TCP具有拥塞控制特性，所以刚建立的TCP还有慢启动过程，产生减速效果。

**网络重连**

一个TCP连接由四元组（源IP地址、源端口、目标IP地址、目标端口）确定，如果IP地址或者端口变动了，就会导致需要TCP与TLS重新握手。

这些问题都是TCP固有的。

#### 2.14.2 QUIC协议的特点

**无队头阻塞**

QUIC协议会保证数据包的可靠性，当某个流中一个数据包丢失了，即使其它包都到了，数据也无法被HTTP/3读取（区别在于只会影响该流，所以对于整个连接来说，没有队头阻塞）。

![image-20240103184052235](图片\QUIC连接.png)

**更快的连接建立**

HTTP/1和HTTP/2中，TCP和TLS是分层的，分别属于内核实现的传输层、OpenSSL库实现的表示层，因此难以合并在一起，需要先进行TCP握手，再进行TLS握手。

HTTP/3中，使用**QUIC协议握手**确定连接ID的同时，还会携带TLS中的记录，且QUIC使用了TLS1.3，仅需**一个RTT**就可以同时完成建立连接与密钥协商。甚至在**第二次连接**的时候，可以将应用数据与QUIC握手信息（连接信息+TLS信息）一起发送，达到**0-RTT**的效果。

![image-20240103184724106](图片\QUIC0rtt.png)

**连接迁移**

QUIC协议在进行连接迁移时，只需要通过连接ID来标记通信的两个端点无缝连接，消除重连成本（需要保有上下文信息，如连接ID、TLS密钥）。

#### 2.14.3 HTTP/3协议

HTTP/3和HTTP/2一样采用二进制帧，但是区别在于不需要再帧里定义Stream，而是使用QUIC里的Stream。

![image-20240103185334789](D:\Xiao\note\图片\HTTP3帧头.png)

帧分为：

* 数据帧：Header帧（HTTP头部）、DATA帧（HTTP包体）
* 控制帧

**头部压缩算法**

从HPACK升级到了QPACK，同样采用了静态表、动态表及Huffman编码。

静态表升级：从61项扩充到91项

Huffman动态表解码方式升级：

原动态表：具有时序性，若**首次出现的请求发生丢包，后序无法解码**，只能等到丢失数据包传过来。

QPACK：使用**双向流**

* QPACK Encoder Stream：客户端通过该Stream告诉对方字典。
* QPACK Decoder Stream：用于响应对方，后续就可以用该字典进行编码了。

### 2.15 HTTP与RPC

#### 2.15.1 裸TCP

TCP特性：**面向连接、可靠、基于字节流**

粘包问题：TCP基于字节流，**没有边界**，需要自定义规则才能区分消息边界。

![image-20240103192443978](图片\TCP粘包问题.png)

#### 2.15.2 联系

都是基于底层TCP/UDP协议创造出来的协议，是定义了不同消息格式应用层协议。

HTTP（Hyper Text Transfer Protocol）：超文本传输协议，用于浏览器，统一访问各个网站的数据格式。

RPC（Remote Procedure Call）：远程过程调用。不是一个具体的协议，而是一种调用方式。可以屏蔽网络细节，调用远端服务器暴露出来的方法remoteFunc。

![image-20240103192927747](图片\远端服务器方法.png)

为什么要有RPC：历史遗留

#### 2.15.3 区别

**服务发现**

要想向某个服务器**发起请求**，需要先**建立连接**，需要知道**IP地址**和**端口**。

HTTP使用**DNS服务**解析服务器IP地址，默认端口80

RPC使用专门的**中间服务**保存服务名与IP信息，如Consul或者Etcd、Redis。想要访问某个服务，就去中间服务获得IP与端口信息。DNS也是服务发现的一种方式，也有基于DNS做服务发现的组件，如CoreDNS。

**底层连接形式**

HTTP/1.1：建立TCP连接后会一直保持这个连接（Keep Alive），之后的请求和响应都是使用这条连接。

RPC协议：同一建立TCP长连接，但是RPC一般还会建立连接池，建立多条连接放在池内，要发数据的时候就取一条出来用，用完放回去下次复用。

![image-20240103194104896](图片\RPC长连接.png)

连接池有利于提升网络请求性能，不少编程语言的网络库都会给HTTP加个连接池，比如Go。

**传输的内容**



### 2.16 HTTP与WebSocket





## 三、TCP

## 四、IP



# 操作系统



# 数据库



# Redis



# 语言

