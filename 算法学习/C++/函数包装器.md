## 作用

1. 将可调用对象封装成一个对象，从而使这个对象可以像一个函数一样被调用，这样可以方便地将可调用对象作为参数传递给其他函数。
2. 可以通过函数包装器实现类型擦除，将不同类型的可调用对象封装成一个相同类型的对象，从而实现多态。
3. 可以通过函数包装器实现函数适配器，将一个可调用对象的参数列表转换为另一个可调用对象的参数列表，从而使得这两个可调用对象可以互相调用。

## 实现方法

1. 模板实现：可以通过模板参数推导和函数对象的重载实现函数包装器。例如可以定义一个函数模板，接受一个可调用对象和一个参数列表作为参数，然后根据可调用对象的类型来选择不同的实现方法，从而将可调用对象封装成一个对象。
2. 使用***std::function***：这是一个c++11中的函数包装器，它可以将任何可调用对象封装成一个对象，从而实现类型擦除和多态。它采用模板参数推导的方式来推导可调用对象的类型，因此可以将不同类型的可调用对象封装成一个相同类型的std::function对象

函数包装器的优点是灵活性高，可以封装任何可调用对象（函数、函数指针、成员函数指针、lambda表达式等），并且可以通过函数适配器实现参数转换和适配。但是函数包装器的缺点是性能略低，因为需要进行类型转换和多态调用。因此，在需要高性能的场景下，应该尽量避免使用函数包装器。