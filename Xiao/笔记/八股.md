# 计算机网络

## 一、基础

### 1.1 TCP/IP 网络模型

通用网络协议

#### 1.1.1应用层

作用：应用软件实现。应用层专注与软件的应用功能，如：HTTP、FTP、Telnet、DNS、SMTP等。而不需要关心数据是如何传递的。

特点：应用层通常工作在操作系统的**用户态**，传输层及以下通常工作在**内核态**。

#### 1.1.2 传输层

作用：传输控制，为应用层提供网络支持，实现不同设备应用间通信。

传输协议：TCP、UDP。

特点：

1. 数据分块。当传输层传输的数据非常大时，直接传输不好控制，当传输层的数据包大小超过MSS时，需要将数据包分块。
2. 端口。接收方可能会有许多应用需要接受数据，因此需要编号将应用区分开，这个编号就是端口。传输层的报文中会携带端口号，接收方可以根据报文识别接收应用。

#### 1.1.3 网络层

作用：实现不同类型设备间传输，应对实际场景的网络环境。

传输协议：IP协议

特点：

1. 数据分片。当网络层传输的报文加上IP报头组装成IP报文大小超过MTU（以太网中为1500字节）时，路由器会对报文再次进行分片。
2. IP地址。使用IP地址给设备编号，通过子网掩码，路由器会根据目标IP地址的网络前缀决定数据报的下一跳路由器。

<img src="..\图片\路由转发" alt="IP地址的网络号" style="zoom: 50%;" />

#### 1.1.4 网络接口层

作用：实现以太网通信，提供链路级别服务，在以太网、WiFi这样的底层网络上发送原始数据包，工作在网络接口这个层次，使用网络接口标识网络上的设备。

以太网：在局域网内，把附近的设备连接起来，使它们之间可以进行通讯的技术。在判断包的目的地的时候，必须匹配才能发往目的地。

协议：ARP协议

特点：

1. MAC地址。在进行通信时，使用ARP协议获取对方MAC地址，从而发送数据包

#### 1.1.5 总结

TCP/IP网络分成：应用层、传输层、网络层、网络接口层。

<img src="..\图片\tcpip参考模型.drawio.png" alt="img" style="zoom:50%;" />

每层封装格式：

应用层：应用数据 ==》报文（message）

传输层：TCP头+应用数据 ==》段（segment）

网络层：IP头+TCP头+应用数据 ==》包（packet）

网络接口层：帧头+IP头+TCP头+应用数据+帧尾 ==》帧（frame）

所有数据单位可以统称为数据包。

### 1.2 从输入网址到网页显示

我的理解是：

1. **地名（网址）**：就像你想去一个城市或地标，但你需要具体的地址才能真正到达那里。
2. **地图（DNS）**：你查看地图或询问人来得知地名对应的具体地址。在网络中，这个“地址”就是IP地址。
3. **地球（根服务器）**：作为地图的基础，这是开始你的查询的地方，然后逐步缩小范围。
4. **国家-省份-市-区-门牌号**：这是DNS解析过程的层次，从最高级的域到最具体的地址。
5. **判断出发点（路由表）**：你的位置可能有多个出口或道路可选，你会选择一个最佳路径前往目的地。
6. **选择近的地点出发（子网选择）**：这类似于你决定从哪个门或窗出去，或者决定走哪条近的街道或小路，因为它们直接通向你的目的地。
7. **返回的过程**：就像你从目的地返回，你会沿着相同或不同的路径回到出发点。

#### 1.2.1 解析URL

URL组成：以http://xiaolincoding.com/network/1_base/what_happen_url.html#孤单小弟-http为例：

这里包含了：

* 协议部分：http://表示使用HTTP协议来访问该网页
* 域名部分：xiaolincoding.com表示该网页的域名或主机名。表示该网页托管在xiaolincoding.com域名下。
* 路径部分：/network/1_base/what_happen_url.html表示网页的具体位置。其中/表示服务器根目录，这个路径表明网页位于服务器的/network/1_base/目录下，并且文件名为what_happen_url。
* 片段标识符：#孤单小弟-http是URL中的片段标识符，用于指定特定的锚点或目标位置。指示网页的特定段落。

#### 1.2.2 生成发送给Web服务器的请求

解析完URL后，利用这些信息生成HTTP请求。如图：

<img src="..\图片\生成HTTP请求" alt="HTTP 的消息格式" style="zoom: 33%;" />

#### 1.2.3 真实地址查询-DNS

域名层级关系：

* 根DNS服务器（.）
* 顶级域DNS服务器（.com）
* 权威DNS服务器（server.com）

其中根DNS服务器的信息保存在互联网所有DNS服务器中。

域名查询顺序：

1. 查询浏览器缓存
2. 查询操作系统缓存
3. 查询hosts文件
4. 查询本地DNS服务器
   1. 查询根域
   2. 查询顶级域名
   3. 查询权威DNS服务器

#### 1.2.4 协议栈

浏览器（应用程序）调用Socket库，委托协议栈工作，即：

TCP/UDP ==> IP（包括ICMP和ARP） ==> 网卡驱动程序 ==>硬件

如图：

<img src="..\图片\协议栈" alt="img" style="zoom:50%;" />

#### 1.2.5 TCP

**头部格式**：

<img src="..\图片\TCP头部" alt="TCP 包头格式" style="zoom: 45%;" />

头部包括以下部分：

- 源端口号：

  - 标识发送数据的源应用程序或进程的端口号：其中0-1023通常保留给一些总所周知的协议与服务，而较高的端口号通常由**动态**或**临时分配**给客户端应用程序。
  - 连接识别：用于在TCP连接中进行识别。每个TCP连接由源IP地址、源端口号、目标IP地址和目标端口号四元组唯一标识，从而保证每个连接都是唯一的。

- 目标端口号：类似源端口号，标识接受数据的端口

- 序号：解决包**乱序**的问题

- 确认号：确认对方是否收到。如果没有收到就应该重发，解决**丢包**问题。

- 状态位：

  - SYN：发起连接
  - ACK：回复
  - RST：重新连接
  - FIN：结束连接

  TCP面向连接，双方需要维护连接的状态，带状态包的发送可以改变状态。

- 窗口大小：通信双方都需要声明一个窗口大小（缓存大小），表明自己的处理能力，避免发送速度太快（撑死）或者太慢（饿死），从而实现流量控制与拥塞控制。

TCP进行数据传输之前，还需要进行**三次握手**建立连接，如图：

<img src="..\图片\TCP三次握手.drawio" alt="TCP 三次握手" style="zoom:33%;" />

* 服务器监听某个特定端口，处于LISTEN状态。
* 客户端主动发起连接SYN，之后处于SYN-SENT状态。
* 服务端收到发起的连接，返回SYN，并且ACK确认客户端的SYN，之后处于SYN-RCVD状态。
* 客户端收到SYN和ACK之后，发送对SYN确认的ACK，之后处于ESTABLISHED状态。
* 服务端收到ACK的ACK后，处于ESTABLISHED状态。

三次握手的目的就是**确认双方都有一发一收能力**。当某方确认后，就会处于ESTABLISHED状态。

**TCP的连接状态**

可以在Linux通过netstat -napt查看，如图：

![TCP 连接状态查看](..\图片\查看TCP连接状态.drawio)

**TCP分割数据**

如果HTTP请求消息比较长，超过了MSS的长度，这时TCP就需要把HTTP的数据拆解成一块块的数据发送。

<img src="..\图片\TCP分割数据" alt="MTU 与 MSS" style="zoom:50%;" />

* MTU：**一个网络包的最大长度**，以太网中一般为1500字节。
* MSS：**除去IP和TCP头部**后，一个网络包所能容纳的TCP数据的最大长度。

数据会被以MSS的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上TCP头部信息。然后交给IP模块来发送数据。如图：

<img src="..\图片\分割与分片" alt="数据包分割" style="zoom: 50%;" />

TCP不会关注HTTP消息是什么，只会决定传输层需要关注的部分，IP同理。但是**TCP会关注下层**，即IP的MTU以及IP头部大小来决定MSS大小。在建立TCP连接时，客户端和服务器会在TCP握手时交换MSS值。这样双方就知道对方可以接受的最大TCP数据包大小。在后续的数据传输中，TCP会将应用层的数据分割成适当大小的TCP数据包，确保它们不会超过MSS值，从而**避免分片或数据包过大**的问题。

**TCP报文生成**

TCP协议的端口：

* 浏览器监听的端口（随机生成）
* Web服务器监听的端口（HTTP默认端口号80，HTTPS默认443）

在双方建立连接后，将数据部分存入分割后的HTTP数据组成TCP报文，然后交给网络层处理。如图：

<img src="..\图片\完整TCP报文" alt="TCP 层报文" style="zoom: 45%;" />



#### 1.2.6 IP

**IP头部格式**：

<img src="..\图片\IP头部格式" alt="IP 包头格式" style="zoom:30%;" />

在IP头部里包括：

* 源IP地址：客户端输出的IP地址
* 目标地址：即通过DNS域名解析得到的Web服务器的IP
* 协议号：06，表示协议为TCP。

**IP头部的源地址如何选择**：

假设客户端有多个网卡，就会有多个IP地址 ，那么IP头部的源地址应该选择哪个IP？有如下规则：

1. **子网匹配**：如果目标IP与某个接口在同一子网中，那么该接口的IP通常被选择为源IP。
2. **路由表**：当数据需要被路由到其他网络时，主机/设备会查看其路由表以决定出口接口。路由表中可能还会有为特定目标配置的源IP。
3. **操作系统策略**：操作系统可能有默认的策略或算法，例如，它们可能基于接口的度量值（metric）、速度或其他因素来选择源IP。
4. **应用程序指定**：某些应用程序可能会明确指定从哪个IP地址发送数据。
5. **绑定的地址**：服务端应用程序，如Web服务器或数据库，可能会绑定到特定的IP地址。这样，它只会从该特定地址接受和发送数据。
6. **源地址选择算法（RFC 6724）**：这是一个特别为IPv6定义的算法，但也可以应用于IPv4。该算法定义了一个来源和目的地址选择的机制，考虑到多种因素，如前缀的长度、地址的范围、策略表等。
7. **隐私和临时地址**：对于IPv6，有临时地址（隐私扩展）的概念，这意味着源地址可能会定期更改以保护用户的隐私。
8. **连接持久性**：某些协议或应用需要“粘性”连接，即始终从同一个源IP与特定的目标通信，即使其他因素（如路由变化）可能推荐使用不同的源IP。
9. **默认地址选择**：如果没有其他规则或策略明确指示，设备可能会使用其主IP地址（例如，第一个配置的或操作系统默认的接口上的地址）作为源IP。
10. **故障切换**：如果一个接口变得不可用，设备可能会选择另一个接口的IP地址作为源地址。

最简单情况下的路由表就是一个子网选择的过程。

**IP报文的生成**：

<img src="..\图片\IP头部完整格式" alt="IP 层报文" style="zoom:20%;" />

完整IP报文如上。

#### 1.2.7 MAC

如果网络包需要在两点之间传递，则需要加上发送与接收两方的MAC地址。MAC头部如图：

<img src="..\图片\MAC头部" alt="MAC 包头格式" style="zoom: 50%;" />

* 发送方MAC包头：直接从网卡里读取
* 接收方包头：通过ARP协议获取接收方MAC地址。

在TCP/IP通信里，MAC包头的协议类型只使用：

* IP协议：0800
* ARP协议：0806

ARP协议获取目的MAC地址过程如下：

1. **确定下一跳的IP地址**：当主机需要与另一个主机通信时，首先需要查找路由表，以确定数据包的下一跳。如果目标主机与源主机在同一局域网内，那么下一跳就是目标主机。如果不是，则通常下一跳是一个网关或路由器。
2. **查询ARP缓存**：在发送数据之前，主机会首先检查其ARP缓存表，看是否已知下一跳IP地址对应的MAC地址。如果已知，那么可以直接用这个MAC地址，跳过ARP请求步骤。
3. **发送ARP请求广播**：如果ARP缓存中没有相关条目，那么主机会在局域网内发送一个ARP请求广播，询问谁拥有这个IP地址，同时希望其能回复其MAC地址。
4. **接收ARP响应并更新缓存**：拥有所请求IP地址的主机会回复一个ARP响应，其中包含其MAC地址。源主机接收到此响应后，会更新其ARP缓存表，将新的IP到MAC地址映射保存起来，以供将来使用。
5. **发送数据包**：有了目标的MAC地址，源主机可以构造Ethernet帧，并将数据包发送到正确的目的地。

MAC报文生成：

<img src="..\图片\MAC报文" alt="MAC 层报文" style="zoom: 25%;" />

#### 1.2.8 网卡

网络包只是一串二进制数字信息，需要将数字信息转换为电信号才能在网线上传输。

执行这一过程的是网卡，可以使用网卡驱动程序控制网卡，发送过程如下：

1. 网卡获取网络包并将其复制到网卡的缓冲区中。
2. 在开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。
3. 将包转换为电信号，通过网线发送出去。

如图：

<img src="..\图片\数据包.drawio.png" alt="数据包" style="zoom: 67%;" />



#### 1.2.9 交换机

交换机的主要功能为基于MAC地址进行帧转发。具体过程如下：

1. **信号接收**：电信号到达网线接口，交换机中的模块对其进行接收。
2. **信号解析**：交换机里的模块将电信号解析为数字帧（注意：在以太网中，信号本身已经是数字化的）。
3. **错误校验**：通过FCS校验错误。
4. **基于MAC地址转发**：检查交换机MAC地址表，若目的MAC地址存在，则发送到相应端口，否则广播该包并更新MAC地址表。

交换机的MAC地址表如下：

<img src="..\图片\交换机地址表" alt="交换机的 MAC 地址表" style="zoom:40%;" />

两个广播地址：

* MAC地址中的FF:FF:FF:FF:FF:FF
* IP地址中的255.255.255.255

#### 1.2.10 路由器

路由器和交换机的区别：

* 路由器：基于IP设计，三层网络设备，路由器的各个端口都具有MAC地址和IP地址；
* 交换机：基于以太网设计，二层网络设备，交换机的端口不具有MAC地址。

路由器原理：

* MAC地址：路由器端口具有MAC地址，可以成为以太网的收发方。
* IP地址：进行包的转发，网络地址转换NAT、访问控制。

路由器包接收操作：

* 以太网电信号到达网线接口部分，路由器模块将其转换为数字信号，然后通过FCS进行错误校验。
* 基于MAC地址检查是否是发给自己的包，如果不是，则丢弃，如果是，则放到缓冲区中。

查询路由表确定输出端口：

* 更改MAC头部，根据MAC头部后方的IP头部内容进行包的转发。
* 根据路由表选择转发目标，这里与之前的路由转发一样。

路由器包发送操作：

* **查看目的IP**：首先，路由器从数据包的IP头部获取目的IP地址。
* **查询路由表**：路由器查询其路由表，找到与目的IP最匹配的条目。路由表中的条目可能是精确匹配、子网匹配或默认路由。
* **决定下一跳**：基于路由表的查询结果，路由器决定数据包的下一跳。这可以是直接连接的设备（如在同一局域网中的目标主机）或另一个路由器（网关）。
* 根据ARP协议找到目标IP的MAC地址，包会通过交换机到达指定IP。
* **更新MAC帧**。
* **可能会有NAT操作**，即更改源端口号/源IP
* 发送数据包并**更新接口计数器**。

通过层层转发，包最终到达目的地。在这个过程中，源IP与目的IP一直没有变。

#### 1.2.11 总结

总体过程如图：

<img src="..\图片\总体过程" alt="网络分层模型" style="zoom:50%;" />

1. 抵达服务器，检查MAC头部，若符合，则收下。
2. 检查IP头部，发现IP地址符合，根据IP头中的协议项，发现上层是TCP。
3. 检查TCP头部，查看序列号与其他状态位等，若序列号是需要的，则放回缓存并放回ACK，否则丢弃该包。
4. 服务器操作系统发现HTTP进程在监听这个端口，于是将包发给HTTP进程。
5. HTTP进程分析请求后发现客户端需要访问某页面，于是将该网页封装到HTTP相应报文中并发送给客户端。
6. 经过层层包装与层层转发，客户端收到该HTTP相应报文，交给浏览器渲染，网页显示出来了。
7. 最后，客户端结束连接，向服务器发起TCP四次挥手，连接断开。

注意，在路由器转发的时候，路由器只关心IP地址。

### 1.3 Linux中的过程

#### 1.3.1 网络模型

OSI七层模型：

* 应用层：负责给应用程序统一的接口
* 表示层：负责把数据转换成兼容另一个系统能识别的格式
* 会话层：负责建立、管理和终止表示层之间的通信会话
* 传输层：负责端到端的数据传输
* 网络层：负责数据的路由、转发、分片
* 数据链路层：负责数据的封帧和差错检测，以及MAC寻址
* 物理层：负责在物理网络中传输数据帧

TCP/IP网络模型：

* 应用层：负责向用户提供一组应用程序，如HTTP、DNS、FTP等
* 传输层：负责端到端的通信，比如TCP、UDP等
* 网络层：负责网络包的封装、分片、路由、转发，比如IP、ICMP等
* 网络接口层：负责网络包在物理网络中的传输，比如网络包的封帧、MAC寻址、差错检测，以及通过网卡传输网络帧等

两者对应关系示意图：

<img src="..\图片\OSI与TCP.png" alt="img" style="zoom:50%;" />

#### 1.3.2 Linux网络协议栈

网络包封装格式：

<img src="..\图片\封装.png" alt="img" style="zoom:50%;" />

数据链路层并不能传输任意大小的数据包，以太网的这一限制被称为MTU，通常为1500字节。

MTU越大，同等数据量下需要的分包越少，从而提高网络吞吐能力，过大的MTU也可能导致更多的分片，因为其他网络可能MTU更小。

Linux协议栈图示：

<img src="..\图片\协议栈.png" alt="img" style="zoom: 40%;" />

其中：

* 应用程序通过系统调用跟Socket层进行数据交互
* Socket层下面就是传输层、网络层和网络接口层
* 最下层为网卡驱动程序和硬件网卡设备

#### 1.3.3 接收网络包的流程

1. 网卡收到网络包，并使用DMA技术将其写入到指定的内存地址，即Ring Buffer（环形缓冲区），触发硬件中断。
2. （Linux 2.6 NAPI机制）CPU收到硬件中断，根据中断表调用中断处理函数，有以下步骤。
   1. 屏蔽中断
   2. 发起软中断，恢复刚才屏蔽的中断
3. ksoftirqd内核线程（软中断处理线程）收到软中断后开始轮询处理数据：从Ring Buffer中获取一个数据帧，用sk_buff结构表示，从而作为一个网络包交给网络协议栈进行逐层处理。
4. 进入网络接口层，检查报文合法性，若不合法则丢弃，然后找出上层协议类型，去掉帧头帧尾，交给网络层。
5. 进入网络层，判断网络包的走向，决定要转发还是交给上层。若确定要交给上层，则查看上一层的协议，接着去掉IP头部，交给传输层。
6. 进入传输层，去除头部，根据四元组[源IP、源端口，目的IP、目的端口]，找到对应Socket，并把数据放到Socket的接收缓冲区。
7. 应用程序调用Socket接口，将内核Socket接收缓冲区数据拷贝到应用层的缓冲区，唤醒用户进程。

自此，一个网络包发送完毕，如图：

![img](..\图片\收发流程.png)

这个过程的逆过程就是发送的流程。

#### 1.3.4 发送网络包的流程

1. 应用程序调用Socket发送数据包的接口（系统调用），内核申请一个内核态的sk_buff，将用户待发送的数据拷贝到sk_buff内存，并将其加入到发送缓冲区。
2. 网络协议栈从Socket发送缓冲区取出sk_buff，并按照TCP/IP协议从上到下逐层处理。
3. 若使用TCP协议，则会拷贝一个新的sk_buff副本，填充TCP头部。并将其交给网络层，当收到接收端的ACK之后，传输层才会将sk_buff内存释放（TCP可靠传输，支持丢失重传）。
4. 网络层选取路由、填充IP头部、netfilter过滤对超过MTU大小的数据包进行分片，然后将数据包交给网络接口层处理。
5. 网络接口层通过ARP协议获取下一跳的MAC地址，对sk_buff填充帧头和帧尾，接着将sk_buff放到网卡的发送队列中。
6. 上面工作完成后，触发软中断，然后网卡驱动程序从发送队列中读取sk_buff，将其挂到RingBuffer中，然后将sk_buff数据映射到网卡可访问的内存DMA区域，最后将其发送出去。
7. 数据发送完后，网卡触发硬中断释放内存，释放sk_buff内存和清理RingBuffer内存。

在整个发送过程中，涉及了三次内存拷贝操作：

1. 系统调用Socket时，内核申请内核态sk_buff内存，将用户待发送的数据拷贝到sk_buff中。
2. TCP可靠传输会拷贝一个sk_buff副本
3. 当IP层发现sk_buff大于MTU时，申请额外sk_buff，并将原来的sk_buff分为多个小的sk_buff。

在协议栈各层需要对数据包添加包头，为了在层级之间不发生拷贝，只用sk_buff一个结构体来描述所有的网络包，添加包的方式为调整sk_buff中的指针，如图所示：

![img](..\图片\sk_buff.jpg)



## 二、HTTP

### 2.1 HTTP是什么

HTTP是超文本传输协议，即HyperText Transfer Protocol

<img src="..\图片\3-HTTP三部分.png" alt="三个部分"  />

1. 是一种协议
2. 两点传输，可能是服务器到服务器。
3. 传输内容为超文本

所以：**HTTP是在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。**

### 2.2 HTTP状态码有哪些

如图：

<img src="..\图片\6-五大类HTTP状态码.png" alt=" 五大类 HTTP 状态码 " style="zoom: 50%;" />

* **1xx**状态码为提示信息

* **2xx**状态码为服务器成功处理客户端的请求

  * **200 OK**：最常见的状态码，表示一切正常。如果非HEAD请求，通常会有body数据
  * **204 No Content**：常见的状态码，与200 OK基本相同，但响应头没有body数据。
  * **206 Partial Content**：应用于HTTP分块下载或断点续传，表示相应返回的body数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

* **3xx**表示客户请求的资源发生了变动，需要客户端使用新的URL重新发送请求获取资源，即重定向。

  * **301 Moved Permanently**：永久重定向，表示资源不存在了，需要使用新的URL再次访问。
  * **302 Found**：临时重定向，表示请求的资源还在，但暂时需要用另一个URL来访问。

  301和302都会在响应头里使用字段Location，指明后续需要跳转的URL，浏览器会自动重定向新的URL。

  * **304 Not Modified**：不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称缓存重定向，告诉客户端可以继续使用缓存资源，用于缓存控制。

* **4xx**类状态码表示客户端发送的报文有误，服务器无法处理

  * **400 Bad Request**：表示客户端请求的报文有错误，但只是个笼统的错误。
  * **403 Forbidden**：表示服务器禁止访问资源，并不是客户端的请求出错
  * **404 Not Found**：表示请求的资源在服务器上不存在或者未找到，无法提供给客户端。

* **5xx**类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于服务器端的错误码。

  * **500 Internal Server Error**：笼统的错误码，并不知道服务器发生了什么错误。
  * **501 Not Implemented**：客户端请求的功能还不支持，类似“即将开业”
  * **502 Bad Gateway**：服务器作为网关或者代理时返回的错误码，表示服务器自身工作正常，访问后端服务器时发生了错误。
  * **503 Service Unavailable**：表示服务器当前很忙，暂时无法响应客户端，类似“网络繁忙，稍后再试”。

### 2.3 HTTP常见字段

**Host**字段：指定发完同一台服务器上的不同网站

<img src="..\图片\7-HOST字段.png" alt="img" style="zoom: 67%;" />

~~~http
Host: www.A.com
~~~

**Content-Length**字段：表明本次回应的数据长度

<img src="..\图片\8-content-length字段.png" alt="img" style="zoom:75%;" />

~~~http
Content-Length: 1000
~~~

这个字段后面的字节就属于下一个回应了。

HTTP协议通过设置**回车符、换行符**作为HTTP header的**边界**，通过**Content-Length字段**作为HTTP body的**边界**，这两个方式都是为了解决“**粘包**”的问题

**Connection**字段：常用于客户端要求服务器使用HTTP长连接机制，以便其他请求复用。

<img src="..\图片\9-connection字段.png" alt="img" style="zoom:75%;" />

~~~http
GET / HTTP/1.1
Connection: Keep-Alive
~~~

**Content-Type**字段：数据格式

<img src="..\图片\10-content-type字段.png" alt="img" style="zoom:75%;" />

~~~http
// 接受所有格式
Accept: */*	
~~~

~~~http
// 发送网页，编码为UTF-8
Content-Type: text/html; Charset=utf-8		
~~~

**Content-Encoding**字段：数据的压缩方法，表示服务器返回的数据使用了什么压缩格式。

<img src="..\图片\11-content-encoding字段.png" alt="img" style="zoom:75%;" />

~~~http
//客户端可以接受的编码方式
Accept-Encoding: gzip, deflate
~~~

~~~http
//服务器返回的数据采用了gzip压缩格式
Content-Encoding: gzip
~~~

### 2.4 GET与POST

**GET**

1. 目的：通常用于请求数据或信息

2. 数据传递：将参数包含在URL中。例如:

   <http://example.com/page?param1=value&param=value2>

3. 长度限制：因为数据在URL中，所以其长度有限制，这个限制取决于浏览器与服务器，通常限制在2000字左右。

4. 安全性：相对较低。由于所有参数都在URL中，这使得敏感信息容易被暴露（浏览器历史记录、服务器日志、Web缓存等）。

5. 幂等性：GET请求是只读请求，意味着多次执行相同的GET请求，结果应该是相同的。（但是也有例外，取决于开发者如何设置）。

**POST**

1. 目的：通常用于提交数据。
2. 数据传递：数据包含在请求体中，而不是在URL中。
3. 长度限制：理论上没有长度限制，但实际的限制取决于服务器配置。
4. 安全性：相对较高，数据不会出现在URL中，不会轻易暴露。但这并不意味着POST是绝对安全的，数据传输仍然可以被拦截，除非使用了加密（HTTPS）。
5. 幂等性：POST请求不是幂等的，重复发送相同的POST请求可能会产生不同的结果。（也有例外）。

**相同点**

1. 都是HTTP协议中定义的方法。
2. 都可以用于发送请求和传输数据。

**不同点**

1. 数据位置：GET在URL中，POST在请求体中。
2. 安全性：POST相对更安全，因为它不会在URL中暴露数据。
3. 数据大小：GET有大小限制，而POST理论上没有限制。
4. 用途：GET通常用于获取数据，POST通常用于提交数据。
5. 幂等性：GET是幂等的，POST不是。

**RFC2616**

在RFC2616中定义了GET和POST规范的核心语义，即上面所述内容，从这个角度看，有：

* GET方法就是**安全**且**幂等**的，可以对GET获取的数据做缓存，这个缓存可以做到浏览器上，也可以做到代理上（nginx），并且浏览器中GET请求可以保存为书签（就是一个带参数的URL）。
* POST因为是新增或者提交数据，会修改服务器上的数据，所以是**不安全**的，且多次提交就会创建多个资源，所以是**不幂等**的。所以，浏览器不会缓存POST请求，也不能把POST请求存为书签。

在实际开发中，许多细节取决于开发者，比如：

- RFC规范中没有规定GET请求是不能带body的，只是RFC规范中定义的GET请求是获取，这个语义下不需要body。
- POST请求中的URL也可以带有参数。

### 2.5 HTTP缓存技术

**强制缓存**

只要浏览器判断没有过期，就直接使用浏览器的本地缓存，决定使用缓存的主动性在于浏览器这边。

在浏览器按F12后在Network页可以看到请求头部，如下图

<img src="..\图片\强制缓存.png" alt="image-20231012140332417" style="zoom:80%;" />

强缓存是利用下面两个HTTP相应头部实现的（Respond Header），它们都用来表示资源在客户端缓存的有效期：

* Cache-Control，相对时间
* Expires，绝对时间

若两者同时存在，则Cache-Control的优先级高于Expires。

Cache-Control的选项多一些，设置更加精细，实现流程如下：

* 当浏览器第一次访问服务器资源时，服务器会返回这个资源的同时，**在Response头部加上Cache-Control**，其中设置了过期时间大小。
* 浏览器再次请求访问服务器中的该资源时，会先通过请求资源的时间与Cache-Control中设置的过期时间大小**对比**，计算该资源是否过期，如果没有过期，则使用该缓存，否则向服务器发送请求。
* 服务器再次收到请求后，**更新**Respond头部的Cache-Control。

**协商缓存**

当客户端请求资源时，若收到了304响应码，则表明还可以使用本地缓存的资源，通过服务器告诉客户端是否可以使用缓存的方式被称为协商缓存。

<img src="..\图片\缓存etag.png" alt="img" style="zoom: 50%;" />

协商缓存可以通过两种头部实现：

第一种：请求头部中的If-Modified-Since字段与响应头部中的Last-Modified字段实现

* 响应头部中的Last-Modified：当服务器首次相应一个请求的时候，可能会在响应头中加入Last-Modified字段。这个字段表示资源的最后修改时间。

* 请求头部的If-Modified-Since：其值为之前收到的Last-Modified的值，用来判断资源是否已经过期了。

  具体步骤为：

  1. 客户端想要请求某个资源的时候，首先判断本地是否有缓存，当客户端发现这个缓存可能已经过期时，会向服务器发起请求，将Last-Modified的值赋给If-Modified-Since，加在请求头部中。
  2. 服务器收到请求后，比较If-Modified-Since的值与Last-Modified的值，如果后者较大，即资源在之后又被修改过，则返回HTTP 200 OK并附上最新的资源。
  3. 否则返回HTTP 304进行缓存重定向，告诉浏览器可以安全使用本地资源。

第二种：



### 2.6 HTTP特性





### 2.7 HTTP与HTTPS





### 2.8 HTTP/1.1、HTTP/2、HTTP/3的演变





### 2.9 HTTP/1.1如何优化





### 2.10 HTTPS RSA 握手解析





### 2.11 HTTPS ECDHE 握手解析





### 2.12 HTTPS 如何优化





### 2.13 HTTP/2 优点





### 2.14 HTTP/3 优点





### 2.15 HTTP与RPC





### 2.16 HTTP与WebSocket





## 三、TCP

## 四、IP



# 操作系统



# 数据库



# Redis



# 语言

