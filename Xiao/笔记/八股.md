# 计算机网络

## 基础

### TCP/IP 网络模型

通用网络协议

#### 应用层

作用：应用软件实现。应用层专注与软件的应用功能，如：HTTP、FTP、Telnet、DNS、SMTP等。而不需要关心数据是如何传递的。

特点：应用层通常工作在操作系统的**用户态**，传输层及以下通常工作在**内核态**。

#### 传输层

作用：传输控制，为应用层提供网络支持，实现不同设备应用间通信。

传输协议：TCP、UDP。

特点：

1. 数据分块。当传输层传输的数据非常大时，直接传输不好控制，当传输层的数据包大小超过MSS时，需要将数据包分块。
2. 端口。接收方可能会有许多应用需要接受数据，因此需要编号将应用区分开，这个编号就是端口。传输层的报文中会携带端口号，接收方可以根据报文识别接收应用。

#### 网络层

作用：实现不同类型设备间传输，应对实际场景的网络环境。

传输协议：IP协议

特点：

1. 数据分片。当网络层传输的报文加上IP报头组装成IP报文大小超过MTU（以太网中为1500字节）时，路由器会对报文再次进行分片。
2. IP地址。使用IP地址给设备编号，通过子网掩码，路由器会根据目标IP地址的网络前缀决定数据报的下一跳路由器。

<img src="..\图片\路由转发" alt="IP地址的网络号" style="zoom: 50%;" />

#### 网络接口层

作用：实现以太网通信，提供链路级别服务，在以太网、WiFi这样的底层网络上发送原始数据包，工作在网络接口这个层次，使用网络接口标识网络上的设备。

以太网：在局域网内，把附近的设备连接起来，使它们之间可以进行通讯的技术。在判断包的目的地的时候，必须匹配才能发往目的地。

协议：ARP协议

特点：

1. MAC地址。在进行通信时，使用ARP协议获取对方MAC地址，从而发送数据包

#### 总结

TCP/IP网络分成：应用层、传输层、网络层、网络接口层。

<img src="..\图片\tcpip参考模型.drawio.png" alt="img" style="zoom:50%;" />

每层封装格式：

应用层：应用数据 ==》报文（message）

传输层：TCP头+应用数据 ==》段（segment）

网络层：IP头+TCP头+应用数据 ==》包（packet）

网络接口层：帧头+IP头+TCP头+应用数据+帧尾 ==》帧（frame）

所有数据单位可以统称为数据包。

### 从输入网址到网页显示

我的理解是：

1. **地名（网址）**：就像你想去一个城市或地标，但你需要具体的地址才能真正到达那里。
2. **地图（DNS）**：你查看地图或询问人来得知地名对应的具体地址。在网络中，这个“地址”就是IP地址。
3. **地球（根服务器）**：作为地图的基础，这是开始你的查询的地方，然后逐步缩小范围。
4. **国家-省份-市-区-门牌号**：这是DNS解析过程的层次，从最高级的域到最具体的地址。
5. **判断出发点（路由表）**：你的位置可能有多个出口或道路可选，你会选择一个最佳路径前往目的地。
6. **选择近的地点出发（子网选择）**：这类似于你决定从哪个门或窗出去，或者决定走哪条近的街道或小路，因为它们直接通向你的目的地。
7. **返回的过程**：就像你从目的地返回，你会沿着相同或不同的路径回到出发点。

#### 解析URL

URL组成：以http://xiaolincoding.com/network/1_base/what_happen_url.html#孤单小弟-http为例：

这里包含了：

* 协议部分：http://表示使用HTTP协议来访问该网页
* 域名部分：xiaolincoding.com表示该网页的域名或主机名。表示该网页托管在xiaolincoding.com域名下。
* 路径部分：/network/1_base/what_happen_url.html表示网页的具体位置。其中/表示服务器根目录，这个路径表明网页位于服务器的/network/1_base/目录下，并且文件名为what_happen_url。
* 片段标识符：#孤单小弟-http是URL中的片段标识符，用于指定特定的锚点或目标位置。指示网页的特定段落。

#### 生成发送给Web服务器的请求

解析完URL后，利用这些信息生成HTTP请求。如图：

<img src="..\图片\生成HTTP请求" alt="HTTP 的消息格式" style="zoom: 33%;" />

#### 真实地址查询-DNS

域名层级关系：

* 根DNS服务器（.）
* 顶级域DNS服务器（.com）
* 权威DNS服务器（server.com）

其中根DNS服务器的信息保存在互联网所有DNS服务器中。

域名查询顺序：

1. 查询浏览器缓存
2. 查询操作系统缓存
3. 查询hosts文件
4. 查询本地DNS服务器
   1. 查询根域
   2. 查询顶级域名
   3. 查询权威DNS服务器

#### 协议栈

浏览器（应用程序）调用Socket库，委托协议栈工作，即：

TCP/UDP ==> IP（包括ICMP和ARP） ==> 网卡驱动程序 ==>硬件

如图：

<img src="..\图片\协议栈" alt="img" style="zoom:50%;" />

#### TCP

**头部格式**：

<img src="..\图片\TCP头部" alt="TCP 包头格式" style="zoom: 45%;" />

头部包括以下部分：

- 源端口号：

  - 标识发送数据的源应用程序或进程的端口号：其中0-1023通常保留给一些总所周知的协议与服务，而较高的端口号通常由**动态**或**临时分配**给客户端应用程序。
  - 连接识别：用于在TCP连接中进行识别。每个TCP连接由源IP地址、源端口号、目标IP地址和目标端口号四元组唯一标识，从而保证每个连接都是唯一的。

- 目标端口号：类似源端口号，标识接受数据的端口

- 序号：解决包**乱序**的问题

- 确认号：确认对方是否收到。如果没有收到就应该重发，解决**丢包**问题。

- 状态位：

  - SYN：发起连接
  - ACK：回复
  - RST：重新连接
  - FIN：结束连接

  TCP面向连接，双方需要维护连接的状态，带状态包的发送可以改变状态。

- 窗口大小：通信双方都需要声明一个窗口大小（缓存大小），表明自己的处理能力，避免发送速度太快（撑死）或者太慢（饿死），从而实现流量控制与拥塞控制。

TCP进行数据传输之前，还需要进行**三次握手**建立连接，如图：

<img src="..\图片\TCP三次握手.drawio" alt="TCP 三次握手" style="zoom:33%;" />

* 服务器监听某个特定端口，处于LISTEN状态。
* 客户端主动发起连接SYN，之后处于SYN-SENT状态。
* 服务端收到发起的连接，返回SYN，并且ACK确认客户端的SYN，之后处于SYN-RCVD状态。
* 客户端收到SYN和ACK之后，发送对SYN确认的ACK，之后处于ESTABLISHED状态。
* 服务端收到ACK的ACK后，处于ESTABLISHED状态。

三次握手的目的就是**确认双方都有一发一收能力**。当某方确认后，就会处于ESTABLISHED状态。

**TCP的连接状态**

可以在Linux通过netstat -napt查看，如图：

![TCP 连接状态查看](..\图片\查看TCP连接状态.drawio)

**TCP分割数据**

如果HTTP请求消息比较长，超过了MSS的长度，这时TCP就需要把HTTP的数据拆解成一块块的数据发送。

<img src="..\图片\TCP分割数据" alt="MTU 与 MSS" style="zoom:50%;" />

* MTU：**一个网络包的最大长度**，以太网中一般为1500字节。
* MSS：**除去IP和TCP头部**后，一个网络包所能容纳的TCP数据的最大长度。

数据会被以MSS的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上TCP头部信息。然后交给IP模块来发送数据。如图：

<img src="..\图片\分割与分片" alt="数据包分割" style="zoom: 50%;" />

TCP不会关注HTTP消息是什么，只会决定传输层需要关注的部分，IP同理。但是**TCP会关注下层**，即IP的MTU以及IP头部大小来决定MSS大小。在建立TCP连接时，客户端和服务器会在TCP握手时交换MSS值。这样双方就知道对方可以接受的最大TCP数据包大小。在后续的数据传输中，TCP会将应用层的数据分割成适当大小的TCP数据包，确保它们不会超过MSS值，从而**避免分片或数据包过大**的问题。

**TCP报文生成**

TCP协议的端口：

* 浏览器监听的端口（随机生成）
* Web服务器监听的端口（HTTP默认端口号80，HTTPS默认443）

在双方建立连接后，将数据部分存入分割后的HTTP数据组成TCP报文，然后交给网络层处理。如图：

<img src="..\图片\完整TCP报文" alt="TCP 层报文" style="zoom: 45%;" />



#### IP

**IP头部格式**：

<img src="..\图片\IP头部格式" alt="IP 包头格式" style="zoom:30%;" />

在IP头部里包括：

* 源IP地址：客户端输出的IP地址
* 目标地址：即通过DNS域名解析得到的Web服务器的IP
* 协议号：06，表示协议为TCP。

**IP头部的源地址如何选择**：

假设客户端有多个网卡，就会有多个IP地址 ，那么IP头部的源地址应该选择哪个IP？有如下规则：

1. **子网匹配**：如果目标IP与某个接口在同一子网中，那么该接口的IP通常被选择为源IP。
2. **路由表**：当数据需要被路由到其他网络时，主机/设备会查看其路由表以决定出口接口。路由表中可能还会有为特定目标配置的源IP。
3. **操作系统策略**：操作系统可能有默认的策略或算法，例如，它们可能基于接口的度量值（metric）、速度或其他因素来选择源IP。
4. **应用程序指定**：某些应用程序可能会明确指定从哪个IP地址发送数据。
5. **绑定的地址**：服务端应用程序，如Web服务器或数据库，可能会绑定到特定的IP地址。这样，它只会从该特定地址接受和发送数据。
6. **源地址选择算法（RFC 6724）**：这是一个特别为IPv6定义的算法，但也可以应用于IPv4。该算法定义了一个来源和目的地址选择的机制，考虑到多种因素，如前缀的长度、地址的范围、策略表等。
7. **隐私和临时地址**：对于IPv6，有临时地址（隐私扩展）的概念，这意味着源地址可能会定期更改以保护用户的隐私。
8. **连接持久性**：某些协议或应用需要“粘性”连接，即始终从同一个源IP与特定的目标通信，即使其他因素（如路由变化）可能推荐使用不同的源IP。
9. **默认地址选择**：如果没有其他规则或策略明确指示，设备可能会使用其主IP地址（例如，第一个配置的或操作系统默认的接口上的地址）作为源IP。
10. **故障切换**：如果一个接口变得不可用，设备可能会选择另一个接口的IP地址作为源地址。

最简单情况下的路由表就是一个子网选择的过程。

**IP报文的生成**：

<img src="..\图片\IP头部完整格式" alt="IP 层报文" style="zoom:20%;" />

完整IP报文如上。

#### MAC

如果网络包需要在两点之间传递，则需要加上发送与接收两方的MAC地址。MAC头部如图：

<img src="..\图片\MAC头部" alt="MAC 包头格式" style="zoom: 50%;" />

* 发送方MAC包头：直接从网卡里读取
* 接收方包头：通过ARP协议获取接收方MAC地址。

在TCP/IP通信里，MAC包头的协议类型只使用：

* IP协议：0800
* ARP协议：0806

ARP协议获取目的MAC地址过程如下：

1. **确定下一跳的IP地址**：当主机需要与另一个主机通信时，首先需要查找路由表，以确定数据包的下一跳。如果目标主机与源主机在同一局域网内，那么下一跳就是目标主机。如果不是，则通常下一跳是一个网关或路由器。
2. **查询ARP缓存**：在发送数据之前，主机会首先检查其ARP缓存表，看是否已知下一跳IP地址对应的MAC地址。如果已知，那么可以直接用这个MAC地址，跳过ARP请求步骤。
3. **发送ARP请求广播**：如果ARP缓存中没有相关条目，那么主机会在局域网内发送一个ARP请求广播，询问谁拥有这个IP地址，同时希望其能回复其MAC地址。
4. **接收ARP响应并更新缓存**：拥有所请求IP地址的主机会回复一个ARP响应，其中包含其MAC地址。源主机接收到此响应后，会更新其ARP缓存表，将新的IP到MAC地址映射保存起来，以供将来使用。
5. **发送数据包**：有了目标的MAC地址，源主机可以构造Ethernet帧，并将数据包发送到正确的目的地。

MAC报文生成：

<img src="..\图片\MAC报文" alt="MAC 层报文" style="zoom: 25%;" />

#### 网卡

网络包只是一串二进制数字信息，需要将数字信息转换为电信号才能在网线上传输。

执行这一过程的是网卡，可以使用网卡驱动程序控制网卡，发送过程如下：

1. 网卡获取网络包并将其复制到网卡的缓冲区中。
2. 在开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。
3. 将包转换为电信号，通过网线发送出去。

如图：

<img src="..\图片\数据包.drawio.png" alt="数据包" style="zoom: 67%;" />



#### 交换机

交换机的主要功能为基于MAC地址进行帧转发。具体过程如下：

1. **信号接收**：电信号到达网线接口，交换机中的模块对其进行接收。
2. **信号解析**：交换机里的模块将电信号解析为数字帧（注意：在以太网中，信号本身已经是数字化的）。
3. **错误校验**：通过FCS校验错误。
4. **基于MAC地址转发**：检查交换机MAC地址表，若目的MAC地址存在，则发送到相应端口，否则广播该包并更新MAC地址表。

交换机的MAC地址表如下：

<img src="..\图片\交换机地址表" alt="交换机的 MAC 地址表" style="zoom:40%;" />

两个广播地址：

* MAC地址中的FF:FF:FF:FF:FF:FF
* IP地址中的255.255.255.255

#### 路由器

路由器和交换机的区别：

* 路由器：基于IP设计，三层网络设备，路由器的各个端口都具有MAC地址和IP地址；
* 交换机：基于以太网设计，二层网络设备，交换机的端口不具有MAC地址。

路由器原理：

* MAC地址：路由器端口具有MAC地址，可以成为以太网的收发方。
* IP地址：进行包的转发，网络地址转换NAT、访问控制。

路由器包接收操作：

* 以太网电信号到达网线接口部分，路由器模块将其转换为数字信号，然后通过FCS进行错误校验。
* 基于MAC地址检查是否是发给自己的包，如果不是，则丢弃，如果是，则放到缓冲区中。

查询路由表确定输出端口：

* 更改MAC头部，根据MAC头部后方的IP头部内容进行包的转发。
* 根据路由表选择转发目标，这里与之前的路由转发一样。

路由器包发送操作：

* **查看目的IP**：首先，路由器从数据包的IP头部获取目的IP地址。
* **查询路由表**：路由器查询其路由表，找到与目的IP最匹配的条目。路由表中的条目可能是精确匹配、子网匹配或默认路由。
* **决定下一跳**：基于路由表的查询结果，路由器决定数据包的下一跳。这可以是直接连接的设备（如在同一局域网中的目标主机）或另一个路由器（网关）。
* 根据ARP协议找到目标IP的MAC地址，包会通过交换机到达指定IP。
* **更新MAC帧**。
* **可能会有NAT操作**，即更改源端口号/源IP
* 发送数据包并**更新接口计数器**。

通过层层转发，包最终到达目的地。在这个过程中，源IP与目的IP一直没有变。

#### 总结

总体过程如图：

<img src="..\图片\总体过程" alt="网络分层模型" style="zoom:50%;" />

1. 抵达服务器，检查MAC头部，若符合，则收下。
2. 检查IP头部，发现IP地址符合，根据IP头中的协议项，发现上层是TCP。
3. 检查TCP头部，查看序列号与其他状态位等，若序列号是需要的，则放回缓存并放回ACK，否则丢弃该包。
4. 服务器操作系统发现HTTP进程在监听这个端口，于是将包发给HTTP进程。
5. HTTP进程分析请求后发现客户端需要访问某页面，于是将该网页封装到HTTP相应报文中并发送给客户端。
6. 经过层层包装与层层转发，客户端收到该HTTP相应报文，交给浏览器渲染，网页显示出来了。
7. 最后，客户端结束连接，向服务器发起TCP四次挥手，连接断开。

注意，在路由器转发的时候，路由器只关心IP地址。

### Linux中的过程

## HTTP

## TCP

## IP



# 操作系统



# 数据库



# Redis



# 语言

