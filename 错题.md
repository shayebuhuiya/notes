* 在**+=**后没有对两个数的加和求**余数**

  ~~~c++
  dp[i][left + j] += (dp[i - 1][left] + dp[i - 1][j]) % MOD;
  dp[i][left + j] %= MOD;
  ~~~

* 在使用动态规划时未考虑滚动数组

* setprecision会自动四舍五入

* (牛客网编译器) unordered_map和map在进行浮点数运算的时候得到的精度不同

* **不要把全局变量定义到头文件中**

  引用头文件只是简单的把头文件的内容粘贴到响应的位置，头文件的保护只是为了避免头文件的内容在一个文件中定义多次，但是不同文件中引用了该头文件的话，每个文件都会有这个头文件的副本。如果此时在这个头文件中定义了全局变量，则每个文件都有该全局变量，而全局变量的默认限定词为extern，此时该变量在整个项目中的多个cpp文件中形成副本，导致一个或多个重定义的符号错误。正确的操作应该是只在头文件中声明变量或者函数。

* 同一函数用inline定义多次，编译器会发生未定义行为，但不会报错。

* 如果某变量存在extern声明，在某文件也存在static类型的定义，则在该文件中该变量是static的。

* （通过mvsc的猜测）

  * 同名inline函数会优先选择main入口函数所在文件的函数定义或者声明作为函数展开，否则应该是按文件字顺序等可能的顺序展开，

  * 定义多个同名inline函数不会报错，但如果在非存在入口函数的文件中定义同名非inline函数会报错。

  * 如果main文件中同名inline函数有定义，则其他文件中不能存在同名非inline函数

  * 在mvsc中，变量不能用inline声明
  
* ~~~c++
  for(ListNode* p = head; p->next != nullptr; p = p->next){
      while(p->next != nullptr && p->next->val < p->val){
      	p->next = p->next->next;	
      }
      if(p->next == nullptr) break;
  }
  ~~~

  在这个for循环中，如果把里面的判断去掉，则会出错。

  注意：for循环是先进行操作，再进行判断的，当p->next == nullptr时，循环中还是会先使用p = p->next，然后再判断p->next != nullptr这个操作，此时，p为nullptr，p->next不成立，导致undefined behaviour。

  while循环同时判断了两个条件，其中包含了外层循环的退出条件，导致**内层使用外层循环退出条件时，外层没有退出，导致程序出错**。

* 
