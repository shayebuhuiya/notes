### 1、哈希表

哈希表(散列表)，是**根据关键值(Key)直接进行访问在内存存储位置**的数据结构。通过一个关键值的函数将所需的数据映射到表中的位置来访问数据，以**加快查找的速度**。映射函数是**散列函数**，存放记录的数组是**散列表**。

### 2、构造散列函数的方法

1. 直接定址法：$Hash(Key)=A*Key+B$，A、B为常数。

  缺点：关键码比较分散时，Hash表非常浪费空间。

2. 除数留余法：$Hash(Key)=Key\%p$，取关键值被某个不大于散列表长度的数p取余后的余数。

3. 平方取中法：取Key平方后的中间几位，并对散列表大小求余数作为散列地址。

  44^2=1936，取中得93，求余数得到散列值。

4. 折叠法：将数据项按照位数分为若干段，再将几段数字相加，最后对散列表大小求余。

  62767255分为62+76+72+55=265，若哈希表槽位有11个，求余得到1。

5. **数学分析法**：对于出生日期、手机号等部分信息高度重叠的信息，应考虑使用手机尾号、出生日等冲突概率较低的部分，具体问题具体分析。

6. 随机数法：$Hash(Key)=rand(Key)$。

### 3、哈希冲突

经过散列函数计算后，**不同的关键码映射到了同一个散列地址上**，产生了冲突，降低了搜索的效率。

哈希冲突的三个因素：散列函数设计、冲突处理、负载因子。

### 4、解决散列冲突的方法

1. **开放地址法**

  一旦发生了冲突，就取寻找下一个空的散列地址，只有散列表足够大，空的散列地址总能找到，并将记录存入。

  - 线性探测法：向前或向后探查直到寻找到空位。
     - 优点：无需附加空间。

     - 缺点：容易导致**一次聚集**，导致数据扎堆。

     - **删除时不能直接删掉**，否则会导致查找链断裂，必须将后续的元素都取出来重新安置，这样做代价很高。

       使用**lazy delete**删除标记的方法，改善删除问题。查找时碰到lazy delete标记的元素则继续往后找，插入时碰到则直接插入。

  - 二次探测法：与线性探测法类似，只是每次前进1、4、9、16位置，一定程度上**减少数据扎堆**，但是也有相同的缺点。

  - 双散列法：第一个哈希函数冲突，就使用第二个计算，减少冲突。

2. **开散列法（拉链法）**

  首先对关键码集合用一个散列函数计算它们存放的位置。将散列表地址相同的元素放到一个集合中，用链表连接起来。

  使用链表而不是数组，是因为碰撞的数量难以预测，可能会浪费空间。

3. **多子表多位置法**

  d-left哈希法：将哈希表分为d个子表，**每个表各有哈希方式**，将结果塞入碰撞次数最少的那个，如果都相等，就放入最左边那个。

  提高了装载率，但是每个侯选位置都要进行计算，开销较大，查询时也要查多个表。最好实现**并行查询**，避免对子表多次访问。

4. **布隆过滤器**

  是一种概率型数据结构，只查找key是否存在，不知道具体内容value。**布隆过滤器不存储具体数据，所以占用空间小，查询结果存在误差，但误差可控，同时不支持删除操作。**

  布隆过滤器是使用位图实现的，一个元素加入位图时，使用K个哈希函数进行映射，并将映射点置1。查找时再使用K个哈希函数检查这些映射点，**如果全为1，说明可能存在，如果有不为1的点，不存在。**

  布隆过滤器是**不能删除**的，因为一个为1的位置，不能确定被置1几次。

  缺点是存在误报率。可用于垃圾邮件过滤、海量数据的去重处理。

### 5、负载因子

装入的数量/总数量。负载因子越大，冲突率越大，因此冲突达到一定程度时，应当通过再散列扩大散列表，减小负载因子。