## 一、Buffer Pool

Innodb 存储引擎设计了一个**缓冲池（\*Buffer Pool\*）**，来提高数据库的读写性能。 

有了缓冲池后：

- 当**读取数据**时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。
- 当**修改数据**时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘。

### 1、Buffer Pool 有多大？

Buffer Pool 是在 MySQL 启动的时候，向操作系统申请的一片连续的内存空间，默认配置下 Buffer Pool 只有 `128MB` 。

可以通过调整 `innodb_buffer_pool_size` 参数来设置 Buffer Pool 的大小，一般建议设置成可用物理内存的 60%~80%。

### 2、Buffer Pool缓存什么？

Buffer Pool 除了缓存「**索引页**」和「**数据页**」，还包括了 **undo 页**，插入缓存、自适应哈希索引、锁信息等等。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/bufferpool%E5%86%85%E5%AE%B9.drawio.png)

#### 2.1、刚启动的缓存

在 MySQL 启动的时候，**InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的`16KB`的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页**。此时这些缓存页都是空闲的，之后随着程序的运行，才会有磁盘上的页被缓存到 Buffer Pool 中。 

MySQL 刚启动的时候，你会观察到使用的**虚拟内存空间很大，而使用到的物理内存空间却很小**，这是因为只有这些虚拟内存被访问后，操作系统才会触发**缺页中断**，接着将虚拟地址和物理地址建立映射关系。 

#### 2.2、缓存控制块

InnoDB 为**每一个缓存页都创建了一个控制块**，控制块信息包括「缓存页的表空间、页号、缓存页地址、链表节点」等等。控制块也是占有内存空间的，它是放在 Buffer Pool 的最前面，接着才是缓存页，如下图：

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/%E7%BC%93%E5%AD%98%E9%A1%B5.drawio.png)

控制块和缓存页之间灰色部分称为**碎片空间**。  剩余的那点儿空间不够一对控制块和缓存页的大小，这个用不到的内存空间就被称为碎片。 

#### 2.3、 查询一条记录，就只需要缓冲一条记录吗？ 

不是的。当我们查询一条记录时，InnoDB 是会把**整个页的数据加载到 Buffer Pool 中**，因为，通过**索引只能定位到磁盘中的页，而不能定位到页中的一条记录**。将页加载到 Buffer Pool 后，再通过页里的页目录去定位到某条具体的记录。

### 3、Buffer Pool 管理

#### 3.1、空闲页管理

Buffer Pool是一片连续的内存空间，为了能够快速找到空闲的缓存页，可以使用链表结构，将空闲缓存页的「控制块」作为链表的节点，这个链表称为 **Free 链表**（空闲链表）。 

 ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/freelist.drawio.png) 

##### Free链表内容

Free 链表上除了有**控制块**，还有一个**头节点**，该**头节点包含链表的头节点地址，尾节点地址，以及当前链表中节点的数量等信息**。

Free 链表节点是一个一个的控制块，而每个控制块包含着对应缓存页的地址，所以相当于 **Free 链表节点都对应一个空闲的缓存页**。

##### 取出空闲页方式

有了 Free 链表后，每当需要从磁盘中加载一个页到 Buffer Pool 中时，就从 Free链表中取一个空闲的缓存页，并且把该缓存页对应的控制块的信息填上，然后把该缓存页对应的控制块从 Free 链表中移除。

#### 3.2、脏页管理

更新数据的时候，不需要每次都要写入磁盘，而是将 Buffer Pool 对应的缓存页标记为**脏页**，然后再由后台线程将脏页写入到磁盘。 

##### Flush链表

链表的节点也是控制块，区别在于 Flush 链表的元素都是脏页。 

有了 Flush 链表后，后台线程就可以遍历 Flush 链表，将脏页写入到磁盘。 

#### 3.3、提高缓存命中率

##### 3.3.1、LRU算法

链表头部的节点是最近使用的，而链表末尾的节点是最久没被使用的。那么，当空间不够了，就淘汰**最久没被使用的节点**，从而腾出空间。

简单的 LRU 算法的实现思路是这样的：

- 当**访问**的页在 Buffer Pool 里，就直接把该页对应的 LRU 链表节点移**动到链表的头部**。
- 当访问的页不在 Buffer Pool 里，除了要把页放入到 LRU 链表的头部，如果LRU链表已经满了，还要**淘汰 LRU 链表末尾的节点**。

简单的 LRU 算法无法避免下面这两个问题：

- 预读失效；
- Buffer Pool 污染；

##### 3.3.2、预读失效

**MySQL的预读机制**：根据局部性原理，MySQL 在加载数据页时，会提前把它相邻的数据页一并加载进来，目的是为了减少磁盘 IO。

但是可能这些**被提前加载进来的数据页，并没有被访问**，相当于这个预读是白做了，这个就是**预读失效**。

如果使用简单的 LRU 算法，**这些预读页如果一直不会被访问到**，就会出现一个很奇怪的问题，**不会被访问的预读页却占用了 LRU 链表前排的位置**，而末尾淘汰的页，可能是频繁访问的页，这样就大大降低了缓存命中率。

##### 3.3.3、如何改进预读失效问题

让预读的页停留在 Buffer Pool 里的时间要尽可能的短，**让真正被访问的页才移动到 LRU 链表的头部**，从而保证真正被读取的热数据留在 Buffer Pool 里的时间尽可能长。 

改进了 LRU 算法，将 LRU 划分了 2 个区域：**old 区域 和 young 区域**。young 区域在 LRU 链表的前半部分，old 区域则是在后半部分，如下图：

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/mysql/innodb/young%2Bold.png)

old 区域占整个 LRU 链表长度的比例可以通过 `innodb_old_blocks_pct` 参数来设置，默认是 37，代表整个 LRU 链表中 young 区域与 old 区域比例是 63:37。

**划分这两个区域后，预读的页就只需要加入到 old 区域的头部，当页被真正访问的时候，才将页插入 young 区域的头部**。如果预读的页一直没有被访问，就会从 old 区域移除，这样就不会影响 young 区域中的热点数据。

##### 3.3.4、Buffer Pool污染

当某一个 SQL 语句**扫描了大量的数据**时，在 Buffer Pool 空间比较有限的情况下，可能会将 **Buffer Pool 里的所有页都替换出去，导致大量热数据被淘汰了**，等这些热数据又被再次访问的时候，由于缓存未命中，就会产生大量的磁盘 IO，MySQL 性能就会急剧下降，这个过程被称为 **Buffer Pool 污染**。 

> 即使查询出来的结果集很小，也会造成 Buffer Pool 污染。
>
> 比如，在一个数据量非常大的表，执行了这条语句：
>
> ```sql
> select * from t_user where name like "%xiaolin%";
> ```
>
> 可能这个查询出来的结果就几条记录，但是由于这条语句会发生**索引失效**，所以这个查询过程是**全表扫描**的，接着会发生如下的过程：
>
> - 从磁盘读到的页加入到 LRU 链表的 **old 区域头部**；
> - 当从页里读取行记录时，也就是**页被访问**的时候，就要将该页放到 **young 区域头部**；
> - 接下来拿行记录的 name 字段和字符串 xiaolin 进行模糊匹配，如果符合条件，就加入到结果集里；
> - 如此往复，直到扫描完表中的所有记录。
>
> 经过这一番折腾，原本 **young 区域的热点数据都会被替换掉**。 

##### 3.3.5、如何改进Buffer Pool污染

LRU 链表中 young 区域就是热点数据，只要我们**提高进入到 young 区域的门槛**，就能有效地保证 young 区域里的热点数据不会被替换掉。 

进入到 young 区域条件增加了一个**停留在 old 区域的时间判断**。在对某个处在 old 区域的缓存页进行第一次访问时，就在它对应的控制块中记录下来这个访问时间：

- 如果后续的访问时间与第一次访问的时间**在某个时间间隔内**，那么**该缓存页就不会被从 old 区域移动到 young 区域的头部**；
- 如果后续的访问时间与第一次访问的时间**不在某个时间间隔内**，那么**该缓存页移动到 young 区域的头部**；

这个间隔时间是由 `innodb_old_blocks_time` 控制的，默认是 1000 ms。也就说，**只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部**，这样就解决了 Buffer Pool 污染的问题。

> 另外，MySQL 针对 young 区域其实做了一个优化，为了**防止 young 区域节点频繁移动到头部**。young 区域前面 1/4 被访问不会移动到链表头部，只有后面的 3/4被访问了才会。 

#### 3.4、脏页刷盘

引入了 Buffer Pool 后，当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，但是磁盘中还是原数据。  **一般都会在一定时机进行批量刷盘 ，改进性能。**

> 如果没来得及刷盘就宕机怎么办？
>
> InnoDB 的更新操作采用的是 **Write Ahead Log** 策略，即**先写日志，再写入磁盘**，通过 **redo log 日志让 MySQL 拥有了崩溃恢复能力**。 

下面几种情况会触发脏页的刷新：

- 当 **redo log 日志满**了的情况下，会主动触发脏页刷新到磁盘；
- **Buffer Pool 空间不足**时，需要将一部分数据页淘汰掉，如果淘汰的是脏页，需要先将脏页同步到磁盘；
- MySQL 认为**空闲**时，后台线程会定期将适量的脏页刷入到磁盘；
- MySQL 正**常关闭**之前，会把所有的脏页刷入到磁盘；

在我们开启了慢 SQL 监控后，如果你发现**「偶尔」会出现一些用时稍长的 SQL**，这可能是因为脏页在刷新到磁盘时可能会给数据库带来性能开销，导致数据库操作抖动。如果间断出现这种现象，就需要调大 **Buffer Pool 空间**或 **redo log 日志**的大小。

### 4、总结

Innodb 存储引擎设计了一个**缓冲池（Buffer Pool）**，来提高数据库的读写性能。

Buffer Pool **以页为单**位缓冲数据，可以通过 `innodb_buffer_pool_size` 参数调整缓冲池的大小，默认是 128 M。

Innodb 通过三种链表来管理缓页：

- Free List （空闲页链表），管理空闲页；
- Flush List （脏页链表），管理脏页；
- LRU List，管理**脏页+干净页**，将最近且经常查询的数据缓存在其中，而不常查询的数据就淘汰出去。；

InnoDB 对 LRU 做了一些优化，我们熟悉的 LRU 算法通常是将最近查询的数据放到 LRU 链表的头部，而 InnoDB 做 3 点优化：

- 将 LRU 链表 分为**young 和 old 两个区域**，加入缓冲池的页，优先插入 old 区域；页被访问时，才进入 young 区域，目的是为了解决**预读失效**的问题。
- 当**「页被访问」且「 old 区域停留时间超过 `innodb_old_blocks_time` 阈值（默认为1秒）」**时，才会将页插入到 young 区域，否则还是插入到 old 区域，目的是为了解决**批量数据访问，大量热数据淘汰**的问题。
- 为了防止 young 区域节点频繁移动到头部。young 区域前面 1/4 被访问不会移动到链表头部，只有后面的 3/4被访问了才会。

可以通过调整 `innodb_old_blocks_pct` 参数，设置 young 区域和 old 区域比例。

在开启了慢 SQL 监控后，如果你发现「偶尔」会出现一些用时稍长的 SQL，这可因为脏页在刷新到磁盘时导致数据库性能抖动。如果在很短的时间出现这种现象，就需要调大 Buffer Pool 空间或 redo log 日志的大小。