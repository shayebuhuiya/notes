## 一、索引基础

### 1、索引定义

索引就是**数据的目录**。

### 2、索引分类

- 按「数据结构」分类：**B+tree索引、Hash索引、Full-text索引**。
- 按「物理存储」分类：**聚簇索引（主键索引）、二级索引（辅助索引）**。
- 按「字段特性」分类：**主键索引、唯一索引、普通索引、前缀索引**。
- 按「字段个数」分类：**单列索引、联合索引**。

#### 2.1、按数据结构分类

从数据结构的角度来看，MySQL 常见索引有 **B+Tree 索引、HASH 索引、Full-Text 索引**。

InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，**B+Tree 索引类型也是 MySQL 存储引擎采用最多的索引类型**。

在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为**聚簇索引**：

> 聚簇索引并不是一种单独的索引类型，而是一种**数据存储方式**。  当表有聚簇索引时，它的**行数据实际上存放在索引的叶子页**中，因为无法同时把数据行存放在两个不同的地方，所以**一个表只能有一个聚簇索引。** 
>
> **所有完整的用户记录都存放在聚簇索引的叶子节点。**
>
> 优点：
>
> - 可以把**相关数据保存在一起**，数据访问就更快。
> - 聚簇索引提高了**IO密集型应用**的性能。
> - 使用聚簇索引扫描的查询可以直接使用页节点中的主键值。
>
> 缺点：
>
> - 如果数据全部在内存中将失去优势。
> - **更新聚簇索引列的代价很高**，因为会强制每个被更新的行移动到新位置。
> - 基于聚簇索引的表插入新行或主键被更新导致行移动时，可能导致**页分裂**，表会占用更多磁盘空间。

- 如果有**主键**，默认会使用主键作为聚簇索引的索引键（key）；
- 如果没有主键，就选择**第一个不包含 NULL 值的唯一列**作为聚簇索引的索引键（key）；
- 在上面两个都没有的情况下，InnoDB 将自动生成一个**隐式自增 id 列**作为聚簇索引的索引键（key）；

其它索引都属于**辅助索引**（Secondary Index），也被称为**二级索引或非聚簇索引**。**创建的主键索引和二级索引默认使用的是 B+Tree 索引**。

##### 2.1.1、B+ tree索引的存放方式

**B+Tree 是一种多叉树**，**叶子节点才存放数据，非叶子节点只存放索引**，而且每个节点里的数据是**按主键顺序存放**的。每一层**父节点的索引值都会出现在下层子节点的索引值中**，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都有两个指针，分别指向下一个叶子节点和上一个叶子节点，形成一个**双向链表**。 

##### 2.1.2、B+ tree主键索引查询

> 比如，我们执行了下面这条查询语句：
>
> ```sql
> select * from product where id= 5;
> ```
>
> ![主键索引 B+Tree](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/btree.drawio.png)
>
> 这条语句使用了主键索引查询 id 号为 5 的商品。查询过程是这样的，B+Tree 会自顶向下逐层进行查找：
>
> - 将 5 与根节点的索引数据 (1，10，20) 比较，5 在 1 和 10 之间，所以根据 B+Tree的搜索逻辑，找到第二层的索引数据 (1，4，7)；
> - 在第二层的索引数据 (1，4，7)中进行查找，因为 5 在 4 和 7 之间，所以找到第三层的索引数据（4，5，6）；
> - 在叶子节点的索引数据（4，5，6）中进行查找，然后我们找到了索引值为 5 的行数据。

数据库的索引和数据都是存储在硬盘的，进行了 3 次 I/O 操作。

B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以**B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4次。**

##### 2.1.3、B+ tree二级索引查询

主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：

- **主键索引**的 B+Tree 的叶子节点存放的是**实际数据**，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
- **二级索引**的 B+Tree 的叶子节点存放的是**主键值**，而不是实际数据。

> 举例：这里将前面的商品表中的 product_no （商品编码）字段设置为二级索引，那么二级索引的 B+Tree 如下图。
>
> ![二级索引 B+Tree](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E4%BA%8C%E7%BA%A7%E7%B4%A2%E5%BC%95btree.drawio.png)
>
> 其中**非叶子的 key 值是 product_no（图中橙色部分），叶子节点存储的数据是主键值**（图中绿色部分）。
>
> 如果我用 product_no 二级索引查询商品，如下查询语句：
>
> ```
> select * from product where product_no = '0002';
> ```

**会先检二级索引中的 B+Tree 的索引值（**商品编码，product_no），找到对应的叶子节点，**然后获取主键值，然后再通过主键索引中的 B+Tree 树查询到对应的叶子节点**，然后获取整行数据。

**这个过程叫「回表」，也就是说要查两个 B+Tree 才能查到数据**。

> **二级索引不用回表的特殊情况**：当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引查，比如下面这条查询语句：
>
> 因为二级索引product_no里存放的就是查询对象：主键id。
>
> ```sql
> select id from product where product_no = '0002';
> ```
>
> **这种在二级索引的 B+Tree 就能查询到结果的过程就叫作「覆盖索引」，也就是只需要查一个 B+Tree 就能找到数据。**

##### 2.1.4、为什么 MySQL InnoDB 选择 B+tree 作为索引的数据结构？

***1、B+Tree vs B Tree***

B+Tree **只在叶子节点存储数据**，而 B 树的非叶子节点也要存储数据，所以 **B+Tree 的单个节点的数据量更小，在相同的磁盘 I/O 次数下，就能查询更多的节点**。

另外，B+Tree 叶子节点采用的是双链表连接，适合 MySQL 中常见的**基于范围的顺序查找**，而 B 树无法做到这一点。

***2、B+Tree vs 二叉树***

对于有 N 个叶子节点的 B+Tree，其**搜索复杂度为`O(logdN)`**，其中 d 表示节点允许的最大子节点个数为 d 个。

在实际的应用当中， d 值是大于100的，这样就保证了，即使数据达到千万级别时，B+Tree 的高度依然维持在 3~4 层左右，也就是说一次数据查询操作只需要做 **3~4 次的磁盘 I/O 操作**就能查询到目标数据。

而二叉树的每个父节点的儿子节点个数只能是 2 个，意味着**其搜索复杂度为 `O(logN)`**，这已经比 B+Tree 高出不少，因此**二叉树检索到目标数据所经历的磁盘 I/O 次数要更多**。

***3、B+Tree vs Hash***

Hash 在做等值查询的时候搜索复杂度为 O(1)。但是 **Hash 表不适合做范围查询**，它**更适合做等值的查询**，这也是 B+Tree 索引要比 Hash 表索引有着更广泛的适用场景的原因。

#### 2.2、按物理存储分类

从物理存储的角度来看，索引分为**聚簇索引（往往是主键索引）**、二级索引（辅助索引）。

- 主键索引的 B+Tree 的叶子节点存放的是**实际数据**，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
- 二级索引的 B+Tree 的叶子节点存放的是**主键值**，而不是实际数据。

如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是**覆盖索引**。

如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是**回表**。

#### 2.3、按字段特性分类

从字段特性的角度来看，索引分为**主键索引、唯一索引、普通索引、前缀索引**。

##### 2.3.1、主键索引

主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多**只有一个主键索引**，索引列的值**不允许有空值**。

##### 2.3.2、唯一索引

唯一索引建立在 UNIQUE 字段上的索引，一张表可以有**多个唯一索引**，索引列的值**必须唯一**，但是**允许有空值**。

##### 2.3.3、普通索引

普通索引就是建立在普通字段上的索引，**既不要求字段为主键，也不要求字段为 UNIQUE**。

##### 2.3.4、前缀索引

前缀索引是指**对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引**，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。

使用前缀索引的目的是为了**减少索引占用的存储空间，提升查询效率。**

#### 2.4、按字段个数分类

从字段个数的角度来看，索引分为**单列索引、联合索引**（复合索引）。

- 建立在单列上的索引称为单列索引，比如主键索引；
- 建立在多列上的索引称为联合索引；

##### 2.4.1、联合索引

通过将多个字段组合成一个索引，该索引就被称为联合索引。

> 举例：将商品表中的 product_no 和 name 字段组合成联合索引`(product_no, name)`，创建联合索引的方式如下：
>
> ```sql
> CREATE INDEX index_product_no_name ON product(product_no, name);
> ```
>
> 当在联合索引查询数据时，先按 product_no 字段比较，在 product_no 相同的情况下再按 name 字段比较。也就是说，联合索引查询的 B+Tree 是先按 product_no 进行排序，然后再 product_no 相同的情况再按 name 字段排序。
>
> 因此，使用联合索引时，存在**最左匹配原则**，也就是按照最左优先的方式进行索引的匹配，**不遵循最左匹配，联合索引就会失效。**
>
> 比如，如果创建了一个 `(a, b, c)` 联合索引，可以匹配上联合索引的查询：
>
> - where a=1；
> - where a=1 and b=2 and c=3；
> - where a=1 and b=2；
>
> 需要注意的是，因为有**查询优化器**，所以 **a 字段在 where 子句的顺序并不重要**。
>
> 因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:
>
> - where b=2；
> - where c=3；
> - where b=2 and c=3；
>

只单单使用b、c联合索引无效的原因：a 是全局有序的（1, 2, 2, 3, 4, 5, 6, 7 ,8），而 b 是全局是无序的（12，7，8，2，3，8，10，5，2）。**只有在 a 相同的情况才，b 才是有序的。**因此，直接执行`where b = 2`这种查询条件没有办法利用联合索引的，**利用索引的前提是索引里的 key 是有序的**。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95%E6%A1%88%E4%BE%8B.drawio.png)

##### 2.4.2、联合索引查询范围

联合索引有一些特殊情况，**并不是查询过程使用了联合索引查询，就代表联合索引中的所有字段都用到了联合索引进行索引查询**。

**情况一：select * from t_table where a > 1 and b = 2**

**在符合 a > 1 条件的二级索引记录的范围里，b 字段的值是无序的**。

因此，**Q1 这条查询语句只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引**。

**情况二：select * from t_table where a >= 1 and b = 2**

虽然在符合 a>= 1 条件的二级索引记录的范围里，b 字段的值是「无序」的，**但是对于符合 a = 1 的二级索引记录的范围里，b 字段的值是「有序」的**。当二级索引记录的 a 字段值为 1 时，**可以通过 b = 2 条件减少需要扫描的二级索引记录范围**。也就是说，**从符合 a = 1 and b = 2 条件的第一条记录开始扫描**，而不需要从第一个 a 字段值为 1 的记录开始扫描。

所以，**Q2 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询**。

**情况三：SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2**

不同的数据库对 BETWEEN ... AND 处理方式是有差异的。在 MySQL 中，BETWEEN 包含了 value1 和 value2 边界值，类似于 >= and =<。

**Q3 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询**。

**情况四：SELECT * FROM t_user WHERE name like 'j%' and age = 22**

a 字段可以在联合索引的 B+Tree 中进行索引查询，形成的扫描区间是['j','k')。

虽然在符合前缀为 ‘j’ 的 name 字段的二级索引记录的范围里，age 字段的值是「无序」的，**但是对于符合 name = j 的二级索引记录的范围里，age字段的值是「有序」的**

**Q4 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询**。

综上所示，**联合索引的最左匹配原则，在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。**

**注意，对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。**

#### 2.5、索引下推

对于联合索引（a, b），在执行 `select * from table where a > 1 and b = 2` 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2）。

- 在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个**回表**，存储引擎层交给Server层去判断，到「主键索引」上找出数据行，再对比 b 字段值。
- 而 MySQL 5.6 引入的**索引下推优化**（index condition pushdown)， **可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数**。

#### 2.6、索引区分度

越靠前的字段被用于索引过滤的概率越高，实际开发工作中**建立联合索引时，要把区分度大的字段排在前面，这样区分度大的字段越有可能被更多的 SQL 使用到**。

区分度就是某个字段 column 不同值的个数「除以」表的总行数。

如果索引的区分度很小，还不如不要索引。MySQL 一个查询优化器，查询优化器发现某个值出现在表的数据行中的百分比（惯用的百分比界线是"30%"）很高的时候，它一般会**忽略索引**，**进行全表扫描**。

#### 2.7、联合索引进行排序

针对针对下面这条 SQL，你怎么通过索引来提高查询效率呢？

```sql
select * from order where status = 1 order by create_time asc
```

这时不能仅仅给status建立索引，这样还会导致后续对create_time进行文件排序。

在 status 和 create_time 列建立联合索引，这样根据 status 筛选后的数据就是按照 create_time 排好序的，避免在文件排序，提高了查询效率。

### 3、什么时候需要/不需要创建索引

#### 3.1、索引的缺点

索引最大的好处是**提高查询速度**，但是索引也是有缺点的，比如：

- 需要占用物理空间，数量越大，**占用空间**越大；
- **创建索引和维护索引**要耗费时间，这种时间随着数据量的增加而增大；
- 会降低表的**增删改的效率**，因为每次增删改索引，B+ 树为了维护索引有序性，都需要进行动态维护。

#### 3.2、什么时候适用索引

- 字段有**唯一性**限制的，比如商品编码；
- 经常用于 **`WHERE` 查询条件**的字段，这样能够提高整个表的查询速度，如果查询条件不是一个字段，可以建立联合索引。
- 经常**用于 `GROUP BY` 和 `ORDER BY` 的字段**，这样在查询的时候就不需要再去做一次排序了，因为我们都已经知道**了建立索引之后在 B+Tree 中的记录都是排序好的**。

#### 3.3、什么时候不需要索引

- `WHERE` 条件，`GROUP BY`，`ORDER BY` 里**用不到的字段**，索引的价值是**快速定位**，如果起不到定位的字段通常是不需要创建索引的，因为索引是会占用物理空间的。
- 字段中存在**大量重复数据，不需要创建索引**，比如性别字段，只有男女，如果数据库表中，男女的记录分布均匀，那么无论搜索哪个值都可能得到一半的数据。
- **表数据太少**的时候，不需要创建索引；
- **经常更新的字段**不用创建索引，比如不要对电商项目的用户余额建立索引，因为索引字段频繁修改，由于**要维护 B+Tree的有序性，那么就需要频繁的重建索引**，这个过程是会影响数据库性能的。

### 4、优化索引

#### 4.1、前缀索引优化

使用某个字段中字符串的**前几个字符建立索引**，是为了减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。

不过，前缀索引有一定的局限性，例如：

- order by 就无法使用前缀索引；
- 无法把前缀索引用作覆盖索引

#### 4.2、覆盖索引优化-减少回表

覆盖索引是指 SQL 中 select的所有字段，在索引 B+Tree 的叶子节点上都能找得到的那些索引，从**二级索引中查询得到记录，而不需要通过聚簇索引查询获得，可以避免回表的操作**。

> 举例：
>
> 假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？
>
> 我们可以建立一个联合索引，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，查询将不会再次检索主键索引，从而避免回表。
>
> 所以，使用覆盖索引的好处就是，**不需要查询出包含整行记录的所有信息**，也就减少了大量的 I/O 操作。

#### 4.3、主键索引优化-自增、减小主键长度

**如果我们使用自增主键**，那么每次插入的新数据就会按顺序添加到当前索引节点的位置，不需要移动已有的数据，当页面写满，就会自动开辟一个新页面。因为每次**插入一条新记录，都是追加操作，不需要重新移动数据**，因此这种插入数据的方法效率非常高。

**如果我们使用非自增主键**，由于每次插入主键的索引值都是随机的，因此每次插入新的数据时，就可能会插入到现有数据页中间的某个位置，这将不得不移动其它数据来满足新数据的插入，甚至需要从一个页面复制数据到另外一个页面，我们通常将这种情况称为**页分裂**。**页分裂还有可能会造成大量的内存碎片，导致索引结构不紧凑，从而影响查询效率**。

另外，主键字段的长度不要太大，因为**主键字段长度越小，意味着二级索引的叶子节点越小（二级索引的叶子节点存放的数据是主键值），这样二级索引占用的空间也就越小**。

#### 4.4、索引最好设置为 NOT NULL	

索引列要设置为 NOT NULL 约束。有两个原因：

- 第一原因：**索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化**，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如**进行索引统计时，count 会省略值为NULL 的行。**

- 第二个原因：NULL 值是一个没意义的值，但是它会**占用物理空间，所以会带来的存储空间的问题**，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么[行格式 (opens new window)](https://xiaolincoding.com/mysql/base/row_format.html#innodb-行格式有哪些)中**至少会用 1 字节空间存储 NULL 值列表**，如下图的紫色部分：

  ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png)

#### 4.5、防止索引失效

发生索引失效的情况：

- 当我们使用**左或者左右模糊匹配**的时候，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效；
- 当我们在查询条件中对索引列做了**计算、函数、类型转换**操作，这些情况下都会造成索引失效；
- 联合索引要能正确使用**需要遵循最左匹配原则**，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
- 在 WHERE 子句中，如果在 **OR** 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

### 5、总结

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E7%B4%A2%E5%BC%95/%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93.drawio.png)



## 二、B+树

### 1、InnoDB是如何存储数据的

#### 1.1、数据页

InnoDB 里的 B+ 树中的**每个节点都是一个数据页**。**InnoDB 的数据是按「数据页」为单位来读写的**，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。

数据库的 I/O 操作的最小单位是页，**InnoDB 数据页的默认大小是 16KB**，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，**一次最少把内存中的 16K 内容刷新到磁盘中**。

![图片](https://cdn.xiaolincoding.com//mysql/other/243b1466779a9e107ae3ef0155604a17.png)



这 7 个部分的作用如下图：

![图片](https://cdn.xiaolincoding.com//mysql/other/fabd6dadd61a0aa342d7107213955a72.png)

在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向的链表，如下图所示：

![图片](https://cdn.xiaolincoding.com//mysql/other/557d17e05ce90f18591c2305871af665.png)

采用链表的结构是让数据页之间不需要是物理上的连续的，而是逻辑上的连续。

#### 1.2、页目录

**数据页中的记录按照「主键」顺序组成单向链表**，单向链表的特点就是插入、删除非常方便，但是**检索效率不高**，最差的情况下需要遍历链表上的所有节点才能完成检索。

因此，数据页中有一个**页目录**，起到记录的索引作用。

![图片](https://cdn.xiaolincoding.com//mysql/other/261011d237bec993821aa198b97ae8ce.png)

##### 1.2.1、页目录创建的过程

1. 将所有的记录划分成几个组，这些记录包括最小记录和最大记录，但不包括标记为“已删除”的记录；
2. 每个记录组的最后一条记录就是组内最大的那条记录，并且最后一条记录的头信息中会存储该组一共有多少条记录，作为 n_owned 字段（上图中粉红色字段）
3. 页目录用来存储每组最后一条记录的地址偏移量，这些地址偏移量会按照先后顺序存储起来，每组的地址偏移量也被称之为槽（slot），**每个槽相当于指针指向了不同组的最后一个记录**。

从图可以看到，**页目录就是由多个槽组成的，槽相当于分组记录的索引**。然后，因为记录是按照「主键值」从小到大排序的，所以**我们通过槽查找记录时，可以使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到对应的记录**，无需从最小记录开始遍历整个页中的记录链表。

##### 1.2.2、记录查询过程

查找主键为 11 的用户记录为例：

- 先二分得出槽中间位是 (0+4)/2=2 ，2号槽里最大的记录为 8。因为 11 > 8，所以需要从 2 号槽后继续搜索记录；
- 再使用二分搜索出 2 号和 4 槽的中间位是 (2+4)/2= 3，3 号槽里最大的记录为 12。因为 11 < 12，所以主键为 11 的记录在 3 号槽里；

> 这里有个问题，**「槽对应的值都是这个组的主键最大的记录，如何找到组里最小的记录」**？比如槽 3 对应最大主键是 12 的记录，那如何找到最小记录 9。
>
> 解决办法是：通过槽 3 找到 槽 2 对应的记录，也就是主键为 8 的记录。主键为 8 的记录的下一条记录就是槽 3 当中主键最小的 9 记录，然后开始向下搜索 2 次，定位到主键为 11 的记录，取出该条记录的信息即为我们想要查找的内容。

因为槽内记录有限制，所以即便是复杂度为O（N）的槽内查询，也不会导致复杂度过高。

槽内的记录就只有几条：

- 第一个分组中的记录只能有 1 条记录；
- 最后一个分组中的记录条数范围只能在 1-8 条之间；
- 剩下的分组中记录条数范围只能在 4-8 条之间。

### 2、B+树是如何查询的

#### 2.1、B+树的特点

InnoDB 里的 B+ 树中的**每个节点都是一个数据页**，B+树有以下特点：

- 只**有叶子节点（最底层的节点）才存放了数据**，非叶子节点（其他上层节）仅用来存放目录项作为索引。
- 非叶子节点分为不同层次，通过**分层来降低每一层的搜索量**；
- 所有节点按照索引键大小排序，构成一个**双向链表**，便于范围查询；

#### 2.2、B+树查找记录方式

如何实现快速查找主键为 6 的记录：

![图片](https://cdn.xiaolincoding.com//mysql/other/7c635d682bd3cdc421bb9eea33a5a413.png)

- **定位页**：从根节点开始，通过**二分法快速定位到符合页内范围包含查询值的页**，因为查询的主键值为 6，在[1, 7)范围之间，所以到页 30 中查找更详细的目录项；

  在非叶子节点（页30）中，继续通过二分法快速定位到符合页内范围包含查询值的页，主键值大于 5，所以就到叶子节点（页16）查找记录；
- **定位记录**：接着，在叶子节点（页16）中，通过**槽**查找记录时，使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到主键为 6 的记录。

可以看到，在定位记录所在哪一个页时，也是通过二分法快速定位到包含该记录的页。**定位到该页后，又会在该页内进行二分法快速定位记录所在的分组（槽号）**，最后在分组内进行遍历查找。

### 3、聚簇索引和二级索引

索引又可以分成聚簇索引和非聚簇索引（二级索引），它们区别就在于叶子节点存放的是什么数据：

- 聚簇索引的叶子节点存放的是实际数据，所有完整的用户记录都存放在聚簇索引的叶子节点；**一个表只能有一个聚簇索引。**
- 二级索引的叶子节点存放的是主键值，而不是实际数据。**一个表可以有多个二级索引。**

#### 3.1、聚簇索引创建

InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：

- 如果有主键，默认会使用主键作为聚簇索引的索引键；
- 如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键；
- 在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键；

#### 3.2、聚簇索引和和二级索引的不同

一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引/辅助索引），它也是利用了 B+ 树的数据结构，但是**二级索引的叶子节点存放的是主键值，不是实际数据。**

如果某个查询语句使用了二级索引，但是**查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「回表」，也就是说要查两个 B+ 树才能查到数据**。

不过，当查询的数据是主键值、或者是查询的列在二级索引中时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「**索引覆盖**」，也就是只需要查一个 B+ 树就能找到数据。

### 4、总结

#### 数据页-双向链表、记录-单向链表

InnoDB 的数据是按「**数据页**」为单位来读写的，默认数据页大小为 16 KB。每个**数据页之间通过双向链表**的形式组织起来，物理上不连续，但是逻辑上连续。

数据页内包含用户记录，每个记录之间用**单向链表**的方式组织起来，为了加快在数据页内高效查询记录，设计了一个**页目录**，页目录存储各个槽（分组），且主键值是有序的，于是可以通过**二分查找法**的方式进行检索从而提高效率。

为了高效查询记录所在的数据页，InnoDB 采用 **b+ 树**作为索引，每个节点都是一个数据页。

如果**叶子节点存储的是实际数据的就是聚簇索引**，一个表只能有一个聚簇索引；如果叶子节点存储的不是实际数据，而是**主键值则就是二级索引**，一个表中可以有多个二级索引。

在使用二级索引进行查找数据时，如果查询的数据能在二级索引找到，那么就是「索引覆盖」操作，如果查询的数据不在二级索引里，就需要先在二级索引找到主键值，需要去聚簇索引中获得数据行，这个过程就叫作「回表」。

### 5、MySQL使用B+树的原因

由于磁盘读写速度远远慢于内存，要设计一个适合 MySQL 索引的数据结构，至少满足以下要求：

- 能在**尽可能少的磁盘的 I/O 操作**中完成查询工作；
- 要能高效地查询某一个记录，也要能高效地执行**范围查找**；

#### 5.1、二分查找

在有序数组中可以二分查找高效定位数据。

#### 5.2、二分查找树

用**数组**来实现二分查找有一个问题：**在插入新元素时效率太低**。因为插入元素时，需要将这之后的元素后移一位。

**二叉查找树的特点是一个节点的左子树的所有节点都小于这个节点，右子树的所有节点都大于这个节点**，这样我们在查询数据时，不需要计算中间节点的位置了，只需将查找的数据与节点的数据进行比较。

但是二分查找树有严重的缺点：**当每次插入的元素都是二叉查找树中最大的元素，二叉查找树就会退化成了一条链表，查找数据的时间复杂度变成了 O(n)。**

#### 5.3、自平衡二叉树

为了解决二叉查找树会在极端情况下退化成链表的问题，后面就有人提出**平衡二叉查找树（AVL 树）**。

主要是在二叉查找树的基础上增加了一些条件约束：**每个节点的左子树和右子树的高度差不能超过 1**。也就是说节点的左子树和右子树仍然为平衡二叉树，这样查询操作的时间复杂度就会一直维持在 O(logn) 。

#### 5.4、B树

自平衡二叉树虽然能保持查询操作的时间复杂度在O(logn)，但是因为它本质上是一个二叉树，每个节点只能有 2 个子节点，那么**当节点个数越多的时候，树的高度也会相应变高，这样就会增加磁盘的 I/O 次数，从而影响数据查询的效率。**

**B 树的每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶，所以 B 树就是一个多叉树。**

> 举例：M = 3，那么就是一棵 3 阶的 B 树，特点就是每个节点最多有 2 个（M-1个）数据和最多有 3 个（M个）子节点。

#### 5.5、B+树

B+ 树与 B 树差异的点，主要是以下这几点：

- 叶子节点（**最底部的节点**）才会存放实际数据（**索引+记录**），**非叶子节点只会存放索引**；
- 所有索引都会在叶子节点出现，**叶子节点之间构成一个有序链表**；
- **非叶子节点的索引也会同时存在在子节点中，并且是在子节点中所有索引的最大（或最小）**。
- 非叶子节点中**有多少个子节点，就有多少个索引**；

##### 5.5.1、单点查询

B 树进行单个索引查询时，最快可以在 O(1) 的时间代价内就查到，而从平均时间代价来看，会比 B+ 树稍快一些。

但是 B 树的**查询波动会比较大**，因为每个节点即存索引又存记录，所以有时候访问到了非叶子节点就可以找到索引，而有时需要访问到叶子节点才能找到索引。

B+ 树的非叶子节点不存放实际的记录数据，**仅存放索引**，因此数据量相同的情况下，相比既存索引又存记录的 B 树，**B+树的非叶子节点可以存放更多的索引**，因此 B+ 树可以比 B 树**更「矮胖」**，查询底层节点的磁盘 I/O次数会更少。

##### 5.5.2、插入和删除效率

B+ 树有大量的冗余节点，这样使得删除一个节点的时候，可以直接从叶子节点中删除，甚至可以不动非叶子节点，这样删除非常快。

但是B树删除节点时可能会导致非常复杂的树形变化。

因此，**B+ 树的插入和删除效率更高。**

##### 5.5.3、范围查询

B 树和 B+ 树等值查询原理基本一致，先从根节点查找，然后对比目标数据的范围，最后递归的进入子节点查找。

因为 **B+ 树所有叶子节点间还有一个链表进行连接，这种设计对范围查找非常有帮助。**而 B 树没有将所有叶子节点用链表串联起来的结构，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。

因此，存在大量范围检索的场景，适合使用 B+树，比如数据库。而对于大量的单个索引查询的场景，可以考虑 B 树，比如 nosql 的MongoDB。

#### 5.6、MySQL中的B+树

Innodb 使用的 B+ 树有一些特别的点，比如：

- B+ 树的叶子节点之间是用「双向链表」进行连接，这样的好处是既能向右遍历，也能向左遍历。
- B+ 树点节点内容是数据页，数据页里存放了用户的记录以及各种信息，每个数据页默认大小是 16 KB。

Innodb 根据**索引类型不同，分为聚集和二级索引**。 InnoDB 存储引擎一定会为表创建一个聚集索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个，而二级索引可以创建多个。

#### 5.7总结

InnoDB 是 MySQL 默认的存储引擎，它就是采用了 B+ 树作为索引的数据结构。

要设计一个 MySQL 的索引数据结构，不仅仅考虑数据结构**增删改的时间复杂度**，更重要的是要考虑**磁盘 I/0 的操作次数**。因为索引和记录都是存放在硬盘，硬盘是一个非常慢的存储设备，我们在查询数据的时候，最好能在尽可能少的磁盘 I/0 的操作次数内完成。

**二分查找树**虽然是一个天然的二分结构，能很好的利用二分查找快速定位数据，但是它存在一种极端的情况，每当插入的元素都是树内最大的元素，就会导致二分查找树**退化成一个链表**，此时查询复杂度就会从 O(logn)降低为 O(n)。

为了解决二分查找树退化成链表的问题，就出现了**自平衡二叉树**，保证了查询操作的时间复杂度就会一直维持在 O(logn) 。但是它本质上还是一个二叉树，每个节点只能有 2 个子节点，随着元素的增多，树的高度会越来越高。而树的高度决定于磁盘 I/O 操作的次数，就会影响查询性能。

B 树和 B+ 都是通过多叉树的方式，会将树的高度变矮，所以这两个数据结构非常适合检索存于磁盘中的数据。

MySQL 默认的存储引擎 InnoDB 采用的是 B+ 作为索引的数据结构，原因有：

- B+ 树的非叶子节点不存放实际的记录数据，仅存放索引，因此数据量相同的情况下，相比存储即存索引又存记录的 B 树，**B+树的非叶子节点可以存放更多的索引**，因此 B+ 树可以比 B 树更「矮胖」，查询底层节点的磁盘 I/O次数会更少。
- B+ 树有大量的冗余节点（所有非叶子节点都是冗余索引），这些冗余索引让 **B+ 树在插入、删除的效率都更高**，比如删除根节点的时候，不会像 B 树那样会发生复杂的树的变化；
- B+ 树叶子节点之间用链表连接了起来，**有利于范围查询**，而 B 树要实现范围查询，因此只能通过树的遍历来完成范围查询，这会涉及多个节点的磁盘 I/O 操作，范围查询效率不如 B+ 树。



## 三、索引性能

### 1、MySQL单表不要超过2000W行

- MySQL 的表数据是以页的形式存放的，页在磁盘中不一定是连续的。
- 页的空间是 16K, 并不是所有的空间都是用来存放数据的，会有一些固定的信息，如，页头，页尾，页码，校验码等等。
- 在 B+ 树中，叶子节点和非叶子节点的数据结构是一样的，区别在于，叶子节点存放的是实际的行数据，而非叶子节点存放的是主键和页号。
- 索引结构不会影响单表最大行数，2000W 也只是推荐值，**超过了这个值可能会导致 B + 树层级更高，影响查询性能。**

### 2、索引失效

#### 2.1、对索引使用左模糊、左右模糊匹配

也就是 `like %xx` 或者 `like %xx%` 这两种方式都会造成索引失效。

左模糊是指%林，左边的信息不确定。

#### 2.2、对索引字段使用函数

例如在对索引字段使用len()函数后，就会失效，因**为索引保存的是原始的字段值，而不是函数计算后的值。**如果还想使用索引，就对函数计算后的值也建立索引。

#### 2.3、对索引进行表达式计算

一旦对索引字段进行了表达式计算，例如+1，-1就会索引失效。

#### 2.4、对索引进行隐式转换

**MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较**。

> 例子一：select * from t_user where phone = 1300000001;
>
> 这里的phone是varchar类型。因为 phone 字段为字符串，会自动把字符串转为数字，所以这条语句相当于：
>
> ```sql
> select * from t_user where CAST(phone AS signed int) = 1300000001;
> ```
>
> 这相当于是对phone字段使用了CAST函数，这就是**对索引使用函数**，导致索引失效。
>
> 例子二：select * from t_user where id = "1";
>
> 这里的id是int类型。因为字符串部分是输入参数，也就需要将字符串转为数字，所以这条语句相当于：
>
> ```sql
> select * from t_user where id = CAST("1" AS signed int);
> ```
>
> 索引字段并没有用任何函数，**CAST 函数是用在了输入参数**，因此是**可以走索引扫描的**。
>

#### 2.5、联合索引非最左匹配

对主键字段建立的索引叫做聚簇索引，对普通字段建立的索引叫做二级索引。

那么**多个普通字段组合在一起创建的索引就叫做联合索引**，也叫组合索引。联合索引要能正确使用需要遵循**最左匹配原则**，也就是按照最左优先的方式进行索引的匹配。

> 如果查询条件是以下这几种，因为不符合最左匹配原则，所以就无法匹配上联合索引，联合索引就会失效:
>
> - where b=2；
> - where c=3；
> - where b=2 and c=3；

有一个比较特殊的查询条件：where a = 1 and c = 3 ，符合最左匹配吗？这种其实严格意义上来说是属于**索引截断**，不同版本处理方式也不一样。

MySQL 5.5 的话，前面 a 会走索引，在联合索引找到主键值后，开始**回表**，到主键索引读取数据行，Server 层从存储引擎层获取到数据行后，然后在 Server 层再比对 c 字段的值。

从 MySQL 5.6 之后，有一个**索引下推功能**，可以在存储引擎层进行索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，再返还给 Server 层，从而减少回表次数。

**索引下推的大概原理是**：截断的字段不会在 Server 层进行条件判断，而是会被**下推到「存储引擎层」进行条件判断**（因为 c 字段的值是在 `(a, b, c)` 联合索引里的），然后**过滤出符合条件的数据后再返回给 Server 层**。由于在引擎层就过滤掉大量的数据，无需再回表读取数据来进行判断，减少回表次数，从而提升了性能。

#### 2.6、where子句中的or

在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

因为or条件会对两个列都进行判断，**只要一个不是索引列，就会全表扫描。**

#### 2.7、总结

- 当我们使用左或者左右模糊匹配的时候，也就是 `like %xx` 或者 `like %xx%`这两种方式都会造成索引失效；
- 当我们在查询条件中对索引列使用函数，就会导致索引失效。
- 当我们在查询条件中对索引列进行表达式计算，也是无法走索引的。
- MySQL 在遇到字符串和数字比较的时候，会自动把字符串转为数字，然后再进行比较。如果字符串是索引列，而条件语句中的输入参数是数字的话，那么索引列会发生**隐式类型转换**，由于隐式类型转换是通过 CAST 函数实现的，**等同于对索引列使用了函数**，所以就会导致索引失效。
- 联合索引要能正确使用需要遵循最左匹配原则，也就是按照最左优先的方式进行索引的匹配，否则就会导致索引失效。
- 在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。

#### 2.8、模糊匹配索引失效例子

1、select * from s where name like “xxx”；

2、select * from s where name like “xxx%”；

3、select * from s where name like “%xxx”；

4、select * from s where name like “%xxx%”；

##### 2.8.1、情景一

表中有多个字段，id 是自增主键索引，name 是二级索引，其他字段都是非索引字段。

1、2会走索引扫描，3、4会发生索引失效，进行全表扫描。

##### 2.8.2、情景一

表中有2个字段，id 是自增主键索引，name 是二级索引，没有其他字段。

1、2会走索引扫描，3、4用上了**二级索引**，而且用上了**覆盖索引**。

这张表的字段没有「非索引」字段，所以 `select *` 相当于 `select id,name`，然后**这个查询的数据都在二级索引的 B+ 树，因为二级索引的 B+ 树的叶子节点包含「索引值+主键值」，所以查二级索引的 B+ 树就能查到全部结果了，这个就是覆盖索引。**

所以3、4是全扫描二级索引树得到的结果。

> 为什么全扫描二级索引树，而不是扫描聚簇索引树？
>
> 因为**二级索引树的记录东西很少，就只有「索引列+主键值」**，而聚簇索引记录的东西会更多，比如聚簇索引中的叶子节点则记录了**主键值、事务 id、用于事务和 MVCC 的回滚指针以及所有的剩余列**。
>
> 再加上，这个 select * 不用执行回表操作。所以， **MySQL 优化器认为直接遍历二级索引树要比遍历聚簇索引树的成本要小的多**，因此 MySQL 选择了「全扫描二级索引树」的方式查询数据。

为什么表中是多个字段之后，就需要全表扫描，而不是查询聚簇索引树呢？

加了其他字段后，`select * from t_user where name like "%xx";` 要查询的数据就**不能只在二级索引树里找**了，得需要**回表**操作才能完成查询的工作。

这时查询需要在二级索引树中逐一遍历，获取主键后，**再到聚簇索引树中**检索到对应的数据行。优化器认为上面这样的查询过程的成本实在太高了，所以直接选择**全表扫描**的方式来查询数据。

##### 2.8.3、左模糊匹配%xx一定全表扫描吗？

使用左模糊匹配（like "%xx"）并不一定会走全表扫描，**关键还是看数据表中的字段。**

### 3、count(*) 和 count(1) 

![图片](https://cdn.xiaolincoding.com//mysql/other/af711033aa3423330d3a4bc6baeb9532.png)

#### 3.1、count() 是什么？

count() 是一个聚合函数，函数的参数不仅可以是字段名，也可以是其他任意表达式，该函数作用是**统计符合查询条件的记录中，函数指定的参数不为 NULL 的记录有多少个**。

#### 3.2、count(主键字段)

情况一：如果表里**只有主键索引，没有二级索引**时，那么，InnoDB **循环遍历聚簇索引**，将读取到的记录返回给 server 层，然后读取记录中的 id 值，就会 id 值判断是否为 NULL，如果不为 NULL，就将 count 变量加 1。

情况二：如果表里有二级索引时，InnoDB 循环遍历的对象就不是聚簇索引，而是二级索引。因为**相同数量的二级索引记录可以比聚簇索引记录占用更少的存储空间，所以二级索引树比聚簇索引树小**，这样遍历二级索引的 I/O 成本比遍历聚簇索引的 I/O 成本小，因此「优化器」优先选择的是二级索引。

#### 3.3、count(1)

读取主键索引还是二级索引，和count(主键字段)是一样的。

将读取到的记录返回给 server 层，**但是不会读取记录中的任何字段的值**，因为 count 函数的参数是 1，不是字段，所以不需要读取记录中的字段值。

因此，**count(1)的效率比count(主键字段)高**。

#### 3.4、count(*)

*在select和count中的语义不同。

**count(\*) 执行过程跟 count(1) 执行过程基本一样的**，性能没有什么差异。

而且 MySQL 会对 count(*) 和 count(1) 有个优化，如果有多个二级索引的时候，优化器会使用**key_len 最小的二级索引进行扫描**。只有当没有二级索引的时候，才会采用主键索引来进行统计。

#### 3.5、count(字段)

对于这个查询来说，会采用**全表扫描**的方式来计数，所以它的执行效率是比较差的。

#### 3.6小结

count(1)、 count(*)、 count(主键字段)在执行的时候，如果表里存在二级索引，**优化器就会选择二级索引进行扫描**。

所以，如果要执行 count(1)、 count(*)、 count(主键字段) 时，**尽量在数据表上建立二级索引**，这样优化器会自动采用**字段长度最小**的二级索引进行扫描，相比于扫描主键索引效率会高一些。

再来，就是不要使用 count(字段) 来统计记录个数，因为它的效率是最差的，会采用全表扫描的方式来统计。如果你非要统计表中该字段不为 NULL 的记录个数，建议给这个字段建立一个二级索引。

### 4、优化count(*)

#### 4.1、近似值

如果对结果精度要求不高，可以使用 show table status 或者 explain 命令来表进行估算。

InnoDB中的 show table status 和 explain是会返回估计的行数。

执行 explain 命令效率是很高的，因为它**并不会真正的去查询。**

#### 4.2、额外表保存计数值

想精确的获取表的记录总数，我们可以将这个计数值保存到单独的一张计数表中。

当我们在数据表插入一条记录的同时，将计数表中的计数字段 + 1。也就是说，在新增和删除操作时，我们需要额外维护这个计数表。
