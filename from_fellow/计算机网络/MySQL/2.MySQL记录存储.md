## 一、MySQL的数据存放位置

### 1、数据存放方式

MySQL的数据存放位置和存储引擎相关。以InnoDB为例：

我们每创建一个 database（数据库） 都会在 /var/lib/mysql/ 目录里面创建一个以 database 为名的目录，然后保存表结构和表数据的文件都会存放在这个目录里。

- db.opt，用来存储当前数据库的默认字符集和字符校验规则。
- t_order.frm ，t_order 的**表结构**会保存在这个文件。在 MySQL 中建立一张表都会生成一个**.frm 文件**，该文件是用来保存每个表的元数据信息的，主要包含表结构定义。
- t_order.ibd，t_order 的**表数据**会保存在这个文件。MySQL 中每一张表的数据都存放在一个独立的 **.ibd 文件**。

**一张数据库表的数据是保存在「 表名字.ibd 」的文件里的，这个文件也称为独占表空间文件。**

### 2、表空间文件的结构

**表空间由段（segment）、区（extent）、页（page）、行（row）组成**，InnoDB存储引擎的逻辑存储结构大致如下图：

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%A8%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.drawio.png)

#### 2.1、行

数据库表中的**记录都是按行（row）进行存放**的，每行记录根据不同的行格式，有不同的存储结构。

#### 2.2、页

**InnoDB 的数据是按「页」为单位来读写的**，也就是说，当需要读一条记录的时候，并不是将这个行记录从磁盘读出来，而是以页为单位，将其整体读入内存。

**默认每个页的大小为 16KB**，也就是最多能保证 16KB 的连续存储空间。**页是 InnoDB 存储引擎磁盘管理的最小单元**，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。

页的类型有很多，常见的有数据页、undo 日志页、溢出页等等。数据表中的行记录是用「数据页」来管理的 。

#### 2.3、区

InnoDB 存储引擎是用 B+ 树来组织数据的。

B+ 树中每一层都是通过双向链表连接起来的，如果是以页为单位来分配存储空间，那么链表中相邻的两个页之间的物理位置并不是连续的，可能离得非常远，那么磁盘查询时就会有大量的随机I/O，随机 I/O 是非常慢的。**让链表中相邻的页的物理位置也相邻，这样就可以使用顺序 I/O 。**

在表中数据量大的时候，为某个索引分配空间的时候就不再按照页为单位分配了，而是**按照区（extent）为单位分配**。每个区的大小为 1MB，对于 16KB 的页来说，连续的 64 个页会被划为一个区，这样就使得**链表中相邻的页的物理位置也相邻，就能使用顺序 I/O 了**。

#### 2.4、段

表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。

- 索引段：存放 B + 树的**非叶子节点**的区的集合；
- 数据段：存放 B + 树的**叶子节点**的区的集合；
- 回滚段：存放的是回滚数据的区的集合，MVCC 利用了回滚段实现了多版本查询数据。

## 二、InnoDB行格式

行格式（row_format），就是一条记录的存储结构。

InnoDB 提供了 4 种行格式，分别是 Redundant、**Compact、Dynamic和 Compressed** 行格式。

- Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。
- Compact：由于 Redundant 不是一种紧凑的行格式，所以 MySQL 5.0 之后引入了 Compact 行记录存储方式，**Compact 是一种紧凑的行格式**，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。
- **Dynamic 和 Compressed 两个都是紧凑的行格式**，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默认使用 Dynamic 行格式。

### 1、compact行格式

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/COMPACT.drawio.png)

一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分。

#### 1.1、记录的额外信息

记录的额外信息包含 3 个部分：变长字段长度列表、NULL 值列表、记录头信息。

##### 1.1.1、变长字段长度列表（逆序存放，不必须有）

例如，char是定长的，varchar是变长的，因此需要把数据占用的大小存储起来，读取时根据**变长字段长度列表**存储的长度读取信息，其他的TEXT、BLOB等变长字段也是这么实现的。

> 创建表如下：
>
> ```sql
> CREATE TABLE `t_user` (
>   `id` int(11) NOT NULL,
>   `name` VARCHAR(20) DEFAULT NULL,
>   `phone` VARCHAR(20) DEFAULT NULL,
>   `age` int(11) DEFAULT NULL,
>   PRIMARY KEY (`id`) USING BTREE
> ) ENGINE = InnoDB DEFAULT CHARACTER SET = ascii ROW_FORMAT = COMPACT;
> ```
>
> 现在 t_user 表里有这三条记录：
>
> ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/t_test.png)
>
> 接下来，我们看看看看这三条记录的行格式中的 「变长字段长度列表」是怎样存储的。
>
> 先来看第一条记录：
>
> - name 列的值为 a，真实数据占用的字节数是 1 字节，十六进制 0x01；
> - phone 列的值为 123，真实数据占用的字节数是 3 字节，十六进制 0x03；
> - age 列和 id 列不是变长字段，所以这里不用管。
>
> 这些变长字段的真实数据占用的字节数会按照列的顺序**逆序存放**，所以「变长字段长度列表」里的内容是「 03 01」，而不是 「01 03」。
>
> **第二条记录**的行格式中，「变长字段长度列表」里的内容是「 04 02」；
>
> **第三条记录**中 phone 列的值是 NULL，**NULL 是不会存放在行格式中记录的真实数据部分里的**，所以「变长字段长度列表」里不需要保存值为 NULL 的变长字段的长度。
>
> ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E5%8F%98%E9%95%BF%E5%AD%97%E6%AE%B5%E9%95%BF%E5%BA%A6%E5%88%97%E8%A1%A82.png)

**为什么「变长字段长度列表」的信息要按照逆序存放？**

**原因一**：「记录头信息」中指向下一个记录的指针，指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是**向左读就是记录头信息，向右读就是真实数据，比较方便。**

**原因二**：「变长字段长度列表」中的信息之所以要逆序存放，是因为这样可以**使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时在一个 CPU Cache Line 中，这样就可以提高 CPU Cache 的命中率**。

当数据表没**有变长字段**的时候，比如全部都是 int 类型的字段，这时候表里的行格式就**不会有「变长字段长度列表」**了，因为没必要，不如去掉以节省空间。 

##### 1.1.2、NULL值列表（逆序存放，高位补零，不必须有）

表中的某些列可能会存储 NULL 值，如果**把这些 NULL 值都放到记录的真实数据中会比较浪费空间**，所以 Compact 行格式把这些值为 NULL 的列存储到 **NULL值列表**中。

如果存在允许 NULL 值的列，则**每个列对应一个二进制位（bit）**，二进制位按照列的顺序逆序排列。

- 二进制位的值为`1`时，代表该列的值为NULL。
- 二进制位的值为`0`时，代表该列的值不为NULL。

另外，**NULL 值列表必须用整数个字节的位表示（1字节8位）**，如果使用的二进制位个数不足整数个字节，则在字节的**高位补 `0`**。

> ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/t_test.png)
>
> **第一条记录**，第一条记录所有列都有值，不存在 NULL 值，所以用二进制来表示是：00000**000**（高位补零）；
>
> **第二条记录**，第二条记录 age 列是 NULL 值，所以，对于第二条数据，NULL值列表用十六进制表示是 0x04。
>
> ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/null%E5%80%BC%E5%88%97%E8%A1%A83.png)
>
> 第三条记录则是：00000**110**。

**必须有NULL值列表吗？**

不一定有，**当数据表的字段都定义成 NOT NULL 的时候，这时候表里的行格式就不会有 NULL 值列表了**。

所以在设计数据库表的时候，通常都是建议将字段设置为 NOT NULL，这样可以至少节省 1 字节的空间（NULL 值列表至少占用 1 字节空间）。

**NULL值列表是固定1字节空间吗？**

不会，如果是9哥字段值是NULL，会创建2字节空间的NULL值列表。

##### 1.1.3、记录头信息

记录头信息中包含的内容很多，几个比较重要的：

- delete_mask ：标识此条数据是否被删除。从这里可以知道，我们执行 **detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1**。
- next_record：下一条记录的位置。从这里可以知道，记录与记录之间是通过链表组织的。在前面我也提到了，**指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。**
- record_type：**表示当前记录的类型**，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录

#### 1.2、记录的真实数据

记录真实数据部分除了我们定义的字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%AE%B0%E5%BD%95%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE.png)

- row_id：如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。如果**既没有指定主键，又没有唯一约束，那么 InnoDB 就会为记录添加 row_id 隐藏字段**。row_id**不是必需**的，占用 6 个字节。

- trx_id：**事务id**，表示这个数据是由哪个事务生成的。 trx_id是**必需**的，占用 6 个字节。

- roll_pointer：这条记录**上一个版本的指针**。roll_pointer 是**必需**的，占用 7 个字节。

trx_id 和roll_pointer是**MVCC机制**使用的。



## 三、varchar(n) 中 n 最大值是多少？

MySQL 规定除了 TEXT、BLOBs 这种大对象类型之外，其他所有的列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过 65535 个字节。

### 1、单字段情况

如果创建varchar(65535)会报错，产生storage overhead。**因为一行数据的最大字节数 65535，其实是包含「变长字段长度列表」和 「NULL 值列表」所占用的字节数的**。

**NULL 值列表占用的字节**：如果字段允许为NULL的，**会用 1 字节来表示「NULL 值列表」**。

**变长字段列表占用的字节**：

- 条件一：如果变长字段允许存储的最大字节数小于等于 255 字节，就会用 1 字节表示「变长字段长度」；
- 条件二：如果变长字段允许存储的最大字节数大于 255 字节，就会用 2 字节表示「变长字段长度」；

我们这里字段类型是 varchar(65535) ，字符集是 ascii，所以代表着变长字段允许存储的最大字节数是 65535，符合条件二，所以会用 2 字节来表示「变长字段长度」。

**在数据库表只有一个 varchar(n) 字段且字符集是 ascii 的情况下，varchar(n) 中 n 最大值 = 65535 - 2 - 1 = 65532**。

如果创建varchar(65535 - 3 = 65532) 就会成功。

### 2、多字段情况

**如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 <= 65535**。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E5%A4%9A%E5%AD%97%E6%AE%B5%E7%9A%84%E6%83%85%E5%86%B5.png)

### 3、n 代表的是最多存储的字符数量，并不是字节大小。

要算 varchar(n) 最大能允许存储的字节数，**还要看数据库表的字符集**，因为字符集代表着，1个字符要占用多少字节。

- 比如 ascii 字符集， 1 个字符占用 1 字节，那么 varchar(100) 意味着最大能允许存储 100 字节的数据。varchar(n) 的 n 最大取值就是 65532。

- 在 UTF-8 字符集下，一个字符最多需要三个字节，varchar(n) 的 n 最大取值就是 65532/3 = 21844。

## 四、行溢出后处理

一个页的大小一般是 `16KB`，也就是 `16384字节`，而一个 varchar(n) 类型的列最多可以存储 `65532字节`，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会**发生行溢出，多的数据就会存到另外的「溢出页」中**。

### 1、Compact 行格式溢出页处理

如果一个数据页存不了一条记录，**InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中**。在一般情况下，InnoDB 的数据都是存放在 「数据页」中。但是当发生行溢出时，溢出的数据会存放到「溢出页」中。

当发生行溢出时，在**记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中**，然后**真实数据处用 20 字节存储指向溢出页的地址**，从而可以找到剩余数据所在的页。大致如下图所示。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%8C%E6%BA%A2%E5%87%BA.png)

### 2.Compressed 和 Dynamic 行格式溢出页处理

Compressed 和 Dynamic 这两个行格式和 Compact 非常类似，主要的区别在于处理行溢出数据时有些区别。

这两种格式采用完全的行溢出方式，记录的真实数据处**不会存储该列的一部分数据，只存储 20 个字节的指针来指向溢出页**。而实际的数据都存储在溢出页中，看起来就像下面这样：

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/row_format/%E8%A1%8C%E6%BA%A2%E5%87%BA2.png)

## 五、问题总结

### 1、MySQL的NULL值怎么存放

MySQL 的 Compact 行格式中会用「**NULL值列表**」来标记值为 NULL 的列，NULL 值并不会存储在行格式中的真实数据部分。

NULL值列表会占用 1 字节空间，当表中所有字段都定义成 NOT NULL，行格式中就不会有 NULL值列表，这样可节省 1 字节的空间。

### 2、MySQL 怎么知道 varchar(n) 实际占用数据的大小？

MySQL 的 Compact 行格式中会用「**变长字段长度列表**」存储变长字段实际占用的数据大小。

### 3、varchar(n) 中 n 最大取值为多少？

一行记录最大能存储 65535 字节的数据，但是这个是**包含「变长字段字节数列表所占用的字节数」和「NULL值列表所占用的字节数」**。所以， 我们在算 varchar(n) 中 n 最大值时，需要减去这两个列表所占用的字节数。

如果一张表只有一个 varchar(n) 字段，且允许为 NULL，字符集为 ascii。varchar(n) 中 n 最大取值为 65532。

计算公式：65535 - 变长字段字节数列表所占用的字节数 - NULL值列表所占用的字节数 = 65535 - 2 - 1 = 65532。

如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 <= 65535。

### 4、行溢出后如何处理？

如果一个数据页存不了一条记录，InnoDB 存储引擎会自动将溢出的数据存放到「溢出页」中。

**Compact 行格式**针对行溢出的处理是这样的：当发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把**剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址**，从而可以找到剩余数据所在的页。

**Compressed 和 Dynamic 这两种格式**采用**完全的行溢出方式**，记录的真实数据处不会存储该列的一部分数据，**只存储 20 个字节的指针来指向溢出页**。而实际的数据都存储在溢出页中。
