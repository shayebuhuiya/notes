## 一、锁基础

### 1、全局锁

#### 1.1、全局锁加锁方式

执行后，**整个数据库就处于只读状态了**，这时其他线程执行以下操作，都会被阻塞：

- 对数据的增删改操作，比如 insert、delete、update等语句；
- 对表结构的更改操作，比如 alter table、drop table 等语句。

此外，当会话断开了，全局锁会被自动释放。

#### 1.2、全局锁应用场景

全局锁主要应用于做**全库逻辑备份**，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。

#### 1.3、全局锁缺点

加上全局锁，意味着整个数据库都是只读状态。

那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成**业务停滞**。

#### 1.4、替代方式

如果数据库的引擎支持的事务支持**可重复读的隔离级别**，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。

因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的**隔离性**，这样备份期间备份的数据一直是在开启事务时的数据。

### 2、表级锁

#### 2.1、普通表级锁

需要注意的是，表锁除了会限制别的线程的读写外，**也会限制本线程接下来的读写操作**。也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，也是会被阻塞的。

不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，**InnoDB 牛逼的地方在于实现了颗粒度更细的行级锁**。

#### 2.2、元数据锁

**元数据锁**（MDL）。

我们不需要显式的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：

- 对一张表进行 CRUD 操作时，加的是 **MDL 读锁**；
- 对一张表做结构变更操作的时候，加的是 **MDL 写锁**；

MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。

##### 2.2.1、MDL读锁

当有线程在执行 select 语句（ 加 MDL 读锁）的期间，如果有其他线程要更改该表的结构（ 申请 MDL 写锁），那么将会被阻塞，直到执行完 select 语句（ 释放 MDL 读锁）。

##### 2.2.2、MDL写锁

当有线程对表结构进行变更（ 加 MDL 写锁）的期间，如果有其他线程执行了 CRUD 操作（ 申请 MDL 读锁），那么就会被阻塞，直到表结构变更完成（ 释放 MDL 写锁）。

##### 2.2.3、MDL何时释放

MDL 是在事务提交后才会释放，这意味着**事务执行期间，MDL 是一直持有的**。这导致一些问题：

在操作队列中，一旦有一个线程申请不到MDL写锁，**后续有对该表的 select 语句，就都会被阻塞**，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。

> 为什么线程 因为申请不到 MDL 写锁，而导致后续的申请读锁的查询操作也会被阻塞？
>
> 这是因为申请 MDL 锁的操作会形成一个队列，队列中**写锁获取优先级高于读锁**，一旦出现 MDL 写锁等待**，会阻塞后续该表的所有 CRUD 操作。**
>

#### 2.3、意向锁

普通的 select 是不会加行级锁的，**普通的 select 语句是利用 MVCC 实现一致性读，是无锁的**。

##### 2.3.1、意向锁分类

- 在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；
- 在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；

意向共享锁和意向独占锁是**表级锁**，不会和**行级的共享锁和独占锁**发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁和独占表锁发生冲突。

##### 2.3.2、意向锁的作用

如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。

那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁。那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。

所以，**意向锁的目的是为了快速判断表里是否有记录被加锁**。

#### 2.4、AUTO-INC锁

表里的主键通常都会设置成自增的，之后可以在插入数据时，可以不指定主键的值，数据库会自动给主键赋值递增的值，这主要是通过 **AUTO-INC 锁**实现的。

AUTO-INC 锁是特殊的表锁机制，锁**不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放**。

**在插入数据时，会加一个表级别的 AUTO-INC 锁**，然后为被 `AUTO_INCREMENT` 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。

那么，一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，**从而保证插入数据时，被 `AUTO_INCREMENT` 修饰的字段的值是连续递增的。**

##### 2.4.1、改进AUTO-INC锁

在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种**轻量级的锁**来实现自增。

一样也是在插入数据的时候，会为被 `AUTO_INCREMENT` 修饰的字段加上轻量级锁，**然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁**。

### 3、行级锁

InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。

共享锁（S锁）满足读读共享，读写互斥。独占锁（X锁）满足写写互斥、读写互斥。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/x%E9%94%81%E5%92%8Cs%E9%94%81.png)

#### 3.1、Record Lock

Record Lock 称为**记录锁**，锁住的是一条记录。而且**记录锁是有 S 锁和 X 锁之分**的：

- 当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（**S 型与 S 锁兼容**），但是不可以对该记录加 X 型记录锁（**S 型与 X 锁不兼容**）;
- 当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（**S 型与 X 锁不兼容**），也不可以对该记录加 X 型记录锁（**X 型与 X 锁不兼容**）。

#### 3.2、Gap Lock

Gap Lock 称为**间隙锁**，只存在于**可重复读**隔离级别，目的是为了解决可重复读隔离级别下**幻读**的现象。

假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/gap%E9%94%81.drawio.png)

间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，**间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的**。

#### 3.3、 Next-Key Lock

Next-Key Lock 称为**临键锁**，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。

假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/%E4%B8%B4%E9%94%AE%E9%94%81.drawio.png)

所以，next-key lock **即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中**。

具有相同范围的Next-Key Lock之间会互相阻塞。

#### 3.4、插入意向锁

一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。

如果有的话，插入操作就会发生**阻塞**，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个**插入意向锁**，表明有事务想在某个区间插入新记录，但是现在处于等待状态。

> 举个例子，假设事务 A 已经对表加了一个范围 id 为（3，5）间隙锁。
>
> ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/gap%E9%94%81.drawio.png)
>
> 当事务 A 还没提交的时候，事务 B 向该表插入一条 id = 4 的新记录，这时会判断到插入的位置已经被事务 A 加了间隙锁，于是事物 B 会生成一个**插入意向锁**，然后将锁的状态设置为等待状态
>
> （*PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，只有当锁状态为正常状态时，才代表事务成功获取到了锁*）
>
> 此时事务 B 就会发生阻塞，直到事务 A 提交了事务。

插入意向锁名字虽然有意向锁，但是它并**不是意向锁，它是一种特殊的间隙锁，属于行级别锁**。



## 二、加锁

### 1、什么SQL语句加行级锁？

**普通的 select 语句是不会对记录加锁**的（除了串行化隔离级别），因为它属于快照读，是通过 **MVCC（多版本并发控制）**实现的。

如果要在查询时对记录加行级锁，可以使用下面这两个方式，这两种查询会加锁的语句称为**锁定读**。

```sql
//对读取的记录加共享锁(S型锁)
select ... lock in share mode;

//对读取的记录加独占锁(X型锁)
select ... for update;
```

上面这两条语句必须在一个事务中，**因为当事务提交了，锁就会被释放**，所以在使用这两条语句的时候，要加上 begin 或者 start transaction 开启事务的语句。

**除了上面这两条锁定读语句会加行级锁之外，update 和 delete 操作都会加行级锁，且锁的类型都是独占锁(X型锁)**。

### 2、行级锁的种类

不同隔离级别下，行级锁的种类是不同的。

在读已提交隔离级别下，行级锁的种类只有记录锁，也就是仅仅把一条记录锁上。

在可重复读隔离级别下，行级锁的种类除了有记录锁，还有间隙锁（目的是为了避免幻读），所以行级锁的种类主要有三类：

- Record Lock，**记录锁**，也就是仅仅把一条记录锁上；
- Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；
- Next-Key Lock：**临键锁**，Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。

### 3、怎么加行级锁

**加锁的对象是索引，加锁的基本单位是 next-key lock**，它是由记录锁和间隙锁组合而成的，**next-key lock 是前开后闭区间，而间隙锁是前开后开区间**。

退化：**在能使用记录锁或者间隙锁就能避免幻读现象的场景下， next-key lock 就会退化成记录锁或间隙锁**。

#### 3.1、唯一索引等值查询

当我们用唯一索引进行等值查询的时候，查询的记录存不存在，加锁的规则也会不同，以查询条件是查询唯一索引id=1为例：

- 当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会**退化成「记录锁」**。

  因为这是主键索引，其他事务插入id=1时会发生**主键冲突**，无法插入。

  因为给id=1加了**记录锁**，所以无法删除。只靠记录锁就能避免幻读。

- 当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会**退化成「间隙锁」**。

  因为对应的记录id=1不存在，不能加记录锁。

  SQL就根据id=1前后的记录，以前后数据为区间加上间隙锁。

#### 3.2、唯一索引范围查询

#### 3.3、非唯一索引等值查询

#### 3.4、非唯一索引范围查询

#### 3.5、没有加索引的查询

### 4、update没加索引导致锁全表

当我们执行 update 语句时，实际上是会对记录加独占锁（X 锁）的，如果其他事务对持有独占锁的记录进行修改时是会被阻塞的。

另外，这个锁并不是执行完 update 语句就会释放的，而是会**等事务结束时才会释放**。

#### 4.1、锁全表场景

在 InnoDB 事务中，对记录加锁带基本单位是 next-key 锁，但是会因为一些条件会退化成间隙锁，或者记录锁。加锁的位置准确的说，锁是加在索引上的而非行上。

> 比如，在 update 语句的 where 条件使用了唯一索引，那么 next-key 锁会退化成记录锁，也就是只会给一行记录加锁。
>
> ![在这里插入图片描述](https://cdn.xiaolincoding.com//mysql/other/d2326f98cbb34fc09ca4013703251501.png)

**在 update 语句的 where 条件没有使用索引，就会全表扫描，于是就会对所有记录加上 next-key 锁（记录锁 + 间隙锁），相当于把整个表锁住了**。

![img](https://cdn.xiaolincoding.com//mysql/other/1aa886fe95e7bc791c296e2d342fa435.png)

#### 4.2、如何避免

我们可以将 MySQL 里的 `sql_safe_updates` 参数设置为 1，开启**安全更新**模式。

update 语句必须满足如下条件之一才能执行成功：

- 使用 where，并且 where 条件中必须有索引列；
- 使用 limit；
- 同时使用 where 和 limit，此时 where 条件中可以没有索引列；

delete 语句必须满足以下条件能执行成功：

- 同时使用 where 和 limit，此时 where 条件中可以没有索引列；



## 三、死锁

### 1、死锁原因

可重复读隔离级别下，是存在**幻读**的问题。

**Innodb 引擎为了解决「可重复读」隔离级别下的幻读问题，就引出了 next-key 锁**，它是记录锁和间隙锁的组合。

- Record Lock，记录锁，锁的是记录本身；
- Gap Lock，间隙锁，锁的就是两个值之间的空隙，以防止其他事务在这个空隙间插入新的数据，从而避免幻读现象。

行锁的释放时机是在事务提交（commit）后，锁就会被释放，并不是一条语句执行完就释放行锁。

#### 1.1、死锁案例

![img](https://cdn.xiaolincoding.com//mysql/other/90c1e01d0345de639e3426cea0390e80-20230309222252447.png)

事务 A 在执行下面这条语句的时候：

```sql
select id from t_order where order_no = 1007 for update;
```

**在二级索引（INDEX_NAME : index_order）上加的是 X 型的 next-key 锁，锁范围是`(1006, +∞]`**。

当事务 B 往事务 A next-key 锁的范围 (1006, +∞] 里插入 id = 1008 的记录就会被锁住：

```sql
Insert into t_order (order_no, create_date) values (1008, now());
```

因为当我们执行以下插入语句时，会在插入间隙上获取插入意向锁，**而插入意向锁与间隙锁是冲突的，所以当其它事务持有该间隙的间隙锁时，需要等待其它事务释放间隙锁之后，才能获取到插入意向锁。而间隙锁与间隙锁之间是兼容的，所以所以两个事务中 `select ... for update` 语句并不会相互影响**。

案例中的事务 A 和事务 B 在执行完后 `select ... for update` 语句后都持有范围为`(1006,+∞]`的next-key 锁，而接下来的插入操作为了获取到插入意向锁，**都在等待对方事务的间隙锁释放**，于是就造成了循环等待，导致死锁。

> 为什么间隙锁与间隙锁之间是兼容的？
>
> **间隙锁的意义只在于阻止区间被插入**，因此是可以共存的。**一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁**，共享和排他的间隙锁是没有区别的，他们相互不冲突，且功能相同，即两个事务可以同时持有包含共同间隙的间隙锁。
>
> 注意1：**next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的**。
>
> 注意2：但对于**记录锁**，我们是要考虑 X 型与 S 型关系。
>
> 注意3：对于这种范围为 (1006, +∞] 的 next-key lock，两个事务是可以同时持有的，不会冲突。因为 +∞ 并不是一个真实的记录，自然就不需要考虑 X 型与 S 型关系。

#### 1.2、插入意向锁

**插入意向锁是一种特殊的间隙锁，但不同于间隙锁的是，该锁只用于并发插入操作**。如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。

**插入意向锁的生成时机：**

每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，**如果已加间隙锁，此时会生成一个插入意向锁**，然后锁的状态设置为**等待状态**（PS：MySQL 加锁时，是先生成锁结构，然后设置锁的状态，如果锁状态是等待状态，并不是意味着事务成功获取到了锁，**只有当锁状态为正常状态时，才代表事务成功获取到了锁**），现象就是 Insert 语句会被阻塞。

### 2、Insert 语句是怎么加行级锁的？

Insert 语句在**正常执行时是不会生成锁结构**的，它是靠聚簇索引记录自带的 trx_id 隐藏列来作为**隐式锁**来保护记录的。 

#### 2.1、隐式锁

当事务需要加锁的时，如果这个锁不可能发生冲突，InnoDB会**跳过加锁**环节，这种机制称为**隐式锁**。隐式锁是 InnoDB 实现的一种**延迟加锁机制**，其特点是只有在可能发生冲突时才加锁，从而**减少了锁的数量**，提高了系统整体性能。 

隐式锁就是在 Insert 过程中不加锁，只有在**特殊情况**下，才会将隐式锁转换为显示锁 ：

##### 2.1.1、特殊情况1：记录之间加有间隙锁

每插入一条新记录，都需要看一下待插入记录的下一条记录上是否已经被加了间隙锁，**如果已加间隙锁，此时会生成一个插入意向锁**，然后锁的状态设置为等待状态，现象就是 Insert 语句会被阻塞。

##### 2.1.2、特殊情况2：遇到唯一键冲突

如果在插入新记录时，插入了一个与「**已有的记录的主键或者唯一二级索引列值相同**」的记录，此时插入就会失败，然后对于这条记录加上了 **S 型的锁**。

- 如果**主键索引重复**，插入新记录的事务会给已存在的主键值重复的聚簇索引记录**添加 S 型记录锁**。
- 如果**唯一二级索引重复**，插入新记录的事务都会给已存在的二级索引列值重复的二级索引记录**添加 S 型 next-key 锁**。

> 案例：在隔离级别可重复读的情况下，开启两个事务，前后执行相同的 Insert 语句，此时**事务 B 的 Insert 语句会发生阻塞**。
>
> ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/%E5%94%AF%E4%B8%80%E7%B4%A2%E5%BC%95%E5%8A%A0%E9%94%81.drawio.png)步骤1：事务 A 先插入 order_no 为 1006 的记录，可以插入成功，此时对应的唯一二级索引记录被「隐式锁」保护。
>
> 步骤2*事务 A 插入的 order_no 值为 1006 的记录上的「隐式锁」会变「**显式锁**」且锁类型为 **X 型**的记录锁，所以事务 B 向获取 **S 型 next-key 锁**时会遇到锁冲突，事务 B 进入阻塞状态。

##### 2.1.3、唯一键冲突时，添加S型索引的作用

解决了唯一索引的重复问题。

并发多个事务的时候，第一个事务插入的记录，并不会加锁，而是会用**隐式锁保护唯一二级索引的记录**。

但是当第一个事务还未提交的时候，有其他事务插入了与第一个事务相同的记录，第二个事务就会**被阻塞**，**因为此时第一事务插入的记录中的隐式锁会变为显示锁且类型是 X 型的记录锁，而第二个事务是想对该记录加上 S 型的 next-key 锁，X 型与 S 型的锁是冲突的**，所以导致第二个事务会等待，直到第一个事务提交后，释放了锁。

如果 order_no 不是唯一二级索引，那么两个事务，前后执行相同的 Insert 语句，是不会发生阻塞的

### 3、如何避免死锁

死锁的四个必要条件：**互斥、占有且等待、不可强占用、循环等待**。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。 

#### 3.1、设置事务等待锁的超时时间

当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 `innodb_lock_wait_timeout` 是用来设置超时时间的，默认值时 50 秒。 

#### 3.2、开启主动死锁检测

主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 `innodb_deadlock_detect` 设置为 on，表示开启这个逻辑，默认就开启。 

#### 3.3、预防死锁

上两个都是**死锁发生**后的解决方式。可以回归到业务的角度**预防死锁**。

对订单做幂等性校验的目的是为了保证不会出现重复的订单，那我们可以直接将 order_no 字段设置为**唯一索引列**，利用它的唯一性来保证订单表不会出现重复的订单，这样就能避免加锁，但是一旦插入已经存在的订单记录就会抛出异常。

### 4、死锁案例

#### ![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/%E9%94%81/%E5%AD%97%E8%8A%82mysql%E9%9D%A2%E8%AF%95%E9%A2%98.png) 4.1、T1分析

共加了两个锁，分别是：

- 表锁：X 类型的意向锁；
- 行锁：X 类型的间隙锁；

重点关注行锁，此时事务 A 在**主键索引**上加的是**间隙锁，锁范围是`(20, 30)`**。 

> 锁范围如何确认？
>
> 如果 LOCK_MODE 是 next-key 锁或者间隙锁，那么 LOCK_DATA 就表示**锁的范围最右值**，此次的事务 A 的 LOCK_DATA 是 30。 
>
>  锁范围的最左值是 t_student 表中 **id 为 30 的上一条记录的 id 值**，即 20。 

#### 4.2、T2分析

B事物在T2的操作与A事物在T1的操作一样，**加的是间隙锁，锁范围是`(20, 30)`**。 

两个事务的间**隙锁之间是相互兼容**的，不会产生冲突。 

**间隙锁的意义只在于阻止区间被插入**，因此是可以共存的。**一个事务获取的间隙锁不会阻止另一个事务获取同一个间隙范围的间隙锁**，共享（S型）和排他（X型）的间隙锁是没有区别的，他们相互不冲突，且功能相同。 

#### 4.3、T3分析

事务 A 的状态为等待状态，因为向事务 B 生成的间隙锁（范围 `(20, 30)`）中插入了一条记录，所以事务 A 的插入操作生成了一个**插入意向锁**。 

**插入意向锁是一种特殊的间隙锁，但不同于间隙锁的是，该锁只用于并发插入操作**。

**尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。所以，插入意向锁和间隙锁之间是冲突的**。 

> 插入意向锁的生成时机？
>
> 每插入一条新记录，都需要看一下**待插入记录的下一条记录上是否已经被加了间隙锁**，如果已加间隙锁，此时会生成一个插入意向锁，然后锁的状态设置为等待状态，现象就是 Insert 语句会被阻塞。 

#### 4.4、T4分析

事务 B 在生成插入意向锁时而导致被阻塞，这是因为事务 B 向事务 A 生成的范围为 (20, 30) 的间隙锁插入了一条记录，而插入意向锁和间隙锁是冲突的，所以事务 B 在获取插入意向锁时就陷入了等待状态。 

#### 4.5、死锁原因

本次案例中，事务 A 和事务 B 在执行完后 update 语句后都持有范围为`(20, 30）`的间隙锁，而接下来的插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，满足了死锁的四个条件：**互斥、占有且等待、不可强占用、循环等待**，因此发生了死锁。 

### 5、总结

两个事务即使生成的**间隙锁的范围是一样的，也不会发生冲突**，因为间隙锁目的是为了防止其他事务插入数据，因此间隙锁与间隙锁之间是相互兼容的。

在执行插入语句时，如果插入的记录在其他事务持有间隙锁范围内，插入语句就会被阻塞，因为插入语句在碰到间隙锁时，会生成一个插入意向锁，然后**插入意向锁和间隙锁之间是互斥的关系**。

如果**两个事务分别向对方持有的间隙锁范围内插入一条记**录，而插入操作为了获取到插入意向锁，都在等待对方事务的间隙锁释放，于是就造成了循环等待，满足了死锁的四个条件：**互斥、占有且等待、不可强占用、循环等待**，因此发生了死锁。



## 四、解决幻读

### 1、幻读

同一个查询在不同的时间产生不同的结果集时，事务中就会出现所谓的幻象问题。例如，如果 SELECT 执行了两次，但第二次返回了第一次没有返回的行，则该行是“幻像”行。

### 2、MySQL解决幻读的方式

MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它**很大程度上避免幻读**现象，解决的方案有两种：

- 针对**快照读**（普通 select 语句），是**通过 MVCC 方式解决了幻读**，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。
- 针对**当前读**（select ... for update 等语句），是**通过 next-key lock（记录锁+间隙锁）方式解决了幻读**，因为当执行 select ... for update 语句的时候，会加上 **next-key lock**，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。

### 3、增删改时的索引问题

有一点要注意的是，在执行 update、delete、select ... for update 等具有加锁性质的语句，一定要检查语句是否走了索引，如果是全表扫描的话，会对每一个索引加 next-key 锁，相当于把整个表锁住了。
