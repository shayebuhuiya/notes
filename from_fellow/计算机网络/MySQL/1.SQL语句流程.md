## 一、MySQL的基本架构

1. MySQL的架构分为两层：Server层和存储引擎层。

    ![查询语句执行流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B.png) 

   - **Server 层负责建立连接、分析和执行 SQL**。MySQL 大多数的核心功能模块都在这实现，主要包括**连接器，查询缓存、解析器、预处理器、优化器、执行器等**。另外，所有的**内置函数**和所有跨存储引擎的功能（如存储过程、触发器、视图等。）都在 Server 层实现。
   - **存储引擎层负责数据的存储和提取**。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。现在最常用的存储引擎是 InnoDB，从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。**索引**就是由存储引擎层实现的。



## 二、连接器

### 1、连接MySQL服务

```shell
# -h 指定 MySQL 服务得 IP 地址，如果是连接本地的 MySQL服务，可以不用这个参数；
# -u 指定用户名，管理员角色名为 root；
# -p 指定密码，如果命令行中不填写密码（为了密码安全，建议不要在命令行写密码），就需要在交互对话里面输入密码
mysql -h$ip -u$user -p
```

- 连接的过程需要**先经过TCP三次握手**。

- 通过用户密码验证后，连接器会获取该用户的权限，保存起来，后续的任何操作都会基于连接开始时读到的权限进行权限逻辑处理。

  所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也**不会影响已经存在连接的权限**。修改完成后，**只有再新建的连接才会使用新的权限设置**。 

### 2、查看MySQL服务连接的所有客户端

执行 `show processlist` 命令进行查看。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/mysql/sql%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B/%E6%9F%A5%E7%9C%8B%E8%BF%9E%E6%8E%A5.png) 

比如上图的显示结果，共有两个用户名为 root 的用户连接了 MySQL 服务，其中 id 为 6 的用户的 Command 列的状态为 `Sleep` ，这意味着该用户连接完 MySQL 服务就没有再执行过任何命令，也就是说这是一个空闲的连接，并且空闲的时长是 736 秒（ Time 列）。

### 3、空闲连接

Command列为sleep的连接。

> 空闲连接会一直占用吗？
>
> MySQL定义了**空闲连接的最大空闲时长， 由 `wait_timeout`** 参数控制，默认是8小时，如果超过这个时间，连接器就会把空闲连接断开。
>

#### 3.1、手动断开连接的方式

使用 kill connection + id 的命令手动断开空闲的连接。

#### 3.2、MySQL连接数限制

MySQL 服务支持的**最大连接数由 max_connections 参数控制**，系统就会拒绝接下来的连接请求，并报错提示“Too many connections”。 

#### 3.3、短连接和长连接

MySQL 的连接也跟 HTTP 一样，有短连接和长连接的概念，它们的区别如下：

```c
// 短连接
连接 mysql 服务（TCP 三次握手）
执行sql
断开 mysql 服务（TCP 四次挥手）

// 长连接
连接 mysql 服务（TCP 三次握手）
执行sql
执行sql
执行sql
....
断开 mysql 服务（TCP 四次挥手）
```

**优点：**长连接的好处就是可以**减少建立连接和断开连接的过程**，所以一般是推荐使用长连接。

**缺点：**使用长连接后可能会**占用内存增多**，因为 MySQL 在执行查询过程中临时**使用内存管理连接对象**，这些连接对象资源只有在连接断开时才会释放。这样会发生 MySQL 服务被系统杀掉，异常重启的现象。

##### 3.3.1、解决长连接占用内存的问题

- 第一种，**定期断开长连接**。既然断开连接后就会释放连接占用的内存资源，那么我们可以定期断开长连接。

- 第二种，**客户端主动重置连接**。MySQL 5.7 版本实现了 `mysql_reset_connection()` 函数的接口，注意这是**接口函数不是命令**，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。

  这个过程**不需要重连和重新做权限验证**，但是会**将连接恢复到刚刚创建完时的状态**。

### 4、连接器的工作总结

- 与客户端进行 TCP 三次握手**建立连接**；
- **校验客户端的用户名和密码**，如果用户名或密码不对，则会报错；
- 如果用户名和密码都对了，会**读取该用户的权限**，然后后面的权限逻辑判断都基于此时读取到的权限。



## 三、查询缓存（已停用）

连接器工作完成后，客户端就可以向 MySQL 服务发送 SQL 语句了，MySQL 服务收到 SQL 语句后，就会解析出 SQL 语句的第一个字段，看看是什么类型的语句。

如果 SQL 是查询语句（select 语句），MySQL 就会先去**查询缓存（ Query Cache ）**里查找缓存数据，看看之前有没有执行过这一条命令，这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。

**但是MySQL查询缓存命中率太低，已经停用**。因为对于一个更新频繁的表，一旦发生更新就会清楚缓存。

MySQL 8.0 版本**移除的是 server 层的查询缓存**，并不是 Innodb 存储引擎中的 buffer pool。 



## 四、解析器

解析器做两件事：

-  **词法分析**。MySQL 会根据输入的字符串识别出关键字出来，构建出 **SQL 语法树**，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。 
-  **语法分析**。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句**是否满足 MySQL 语法**。如果输入的SQL语法不对，就会在解析器阶段报错。

检查表、字段是否存在不是由解析器完成的，而是在**执行阶段的预处理**完成的。



## 五、执行SQL

### 1、每条SELECT查询语句的三个阶段

- prepare阶段：预处理
- optimize阶段：优化
- execute阶段：执行

### 2、预处理器

- **检查 SQL 查询语句中的表或者字段是否存在；**
- 将 `select *` 中的 `*` 符号，扩展为表上的所有列；

### 3、优化器

**优化器主要负责将 SQL 查询语句的执行方案确定下来**，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。 

> 查看SQL具体使用了怎样的索引的方法：可以在**查询语句前加上explain。** 这样就会输出这条 SQL 语句的执行计划，然后执行计划中的 key 就表示执行过程中使用了哪个索引 。
>

### 4、执行器

真正执行语句，执行器会与存储引擎交互，**交互以记录为单位**。

执行器与存储引擎有**三种交互方式**：

#### 4.1、主键索引查询

```sql
select * from product where id = 1;
```

这条查询语句的查询条件用到了**主键索引**，而且是等值查询，同时主键 id 是唯一，不会有 id 相同的记录，所以**优化器决定选用访问类型为 const 进行查询**，也就是使用**主键索引**查询一条记录，那么执行器与存储引擎的执行流程是这样的：

- 执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为**优化器**选择的访问类型为 const，这个函数指针被指向为 **InnoDB 引擎索引查询的接口**，把条件 `id = 1` 交给存储引擎，**让存储引擎定位符合条件的第一条记录**。
- **存储引擎**通过**主键索引的 B+ 树**结构定位到 id = 1的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；
- **执行器**从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则**发送给客户端**，如果不符合则跳过该记录。
- **执行器查询的过程是一个 while 循环**，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。

#### 4.2、全表扫描

```sql
select * from product where name = 'iphone';
```

这条查询语句的查询条件**没有用到索引**，所以优化器决定选用访问类型为 ALL 进行查询，也就是全表扫描的方式查询，那么这时执行器与存储引擎的执行流程是这样的：

- 执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为**优化器选择的访问类型为 all**，这个函数指针被指向为 **InnoDB 引擎全扫描的接口**，**让存储引擎读取表中的第一条记录**；
- **执行器**会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；如果是则**将记录发给客户**的（是的没错，**Server 层每从存储引擎读到一条记录就会发送给客户端**，之所以客户端显示的时候是直接显示所有记录的，是因为客户端是等查询语句查询完成后，才会显示出所有的记录）。
- 执行器查询的过程是**一个 while 循环**，所以还会再查一次，会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 all，read_record 函数指针指向的还是 InnoDB 引擎全扫描的接口，所以接着**向存储引擎层要求继续读刚才那条记录的下一条记录**，存储引擎把下一条记录取出后就将其返回给执行器（Server层），执行器继续判断条件，不符合查询条件即跳过该记录，否则发送到客户端；
- 一直重复上述过程，**直到存储引擎把表中的所有记录读完**，然后向执行器（Server层） 返回了读取完毕的信息；
- 执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。

#### 4.3、索引下推

索引下推能够减少**二级索引**在查询时的回表操作，提高查询的效率，因为它**将 Server 层部分负责的事情，交给存储引擎层去处理**了。

案例：如果对 age 和 reward 字段建立了联合索引（age，reward）：

现在有下面这条查询语句：

```sql
select * from t_user  where age > 20 and reward = 100000;
```

联合索引当遇到范围查询 (>、<) 就会停止匹配，也就是 **age 字段能用到联合索引，但是 reward 字段则无法利用到索引**。

##### 4.3.1、不使用下推索引

- Server 层首先调用存储引擎的接口定位到**满足查询条件的第一条二级索引记录**，也就是定位到 age > 20 的第一条记录；
- **存储引擎**根据**二级索引的 B+ 树**快速定位到这条记录后，获取主键值，然后**进行回表操作**，将完整的记录返回给 Server 层；
- Server 层在**判断该记录的 reward 是否等于 100000**，如果成立则将其发送给客户端；否则跳过该记录；
- 接着，继续向存储引擎索要下一条记录，存储引擎在二级索引定位到记录后，获取主键值，然后**回表操作**，将完整的记录返回给 Server 层；
- 如此往复，直到存储引擎把表中的所有记录读完。

可以看到，**没有索引下推的时候，每查询到一条二级索引记录，都要进行回表操作**，然后将记录返回给 Server，接着 **Server 再判断**该记录的 reward 是否等于 100000。

##### 4.3.2、使用下推索引

- Server 层首先调用存储引擎的接口定位到满足查询条件的第一条二级索引记录，也就是定位到 age > 20 的第一条记录；
- 存储引擎定位到二级索引后，**先不执行回表**操作，而是先判断一下该索引中包含的列（reward列）的条件（reward 是否等于 100000）是否成立。如果**条件不成立**，则直接**跳过该二级索引**。如果**成立**，则**执行回表**操作，将完成记录返回给 Server 层。
- Server 层在判断其他的查询条件（本次查询没有其他条件）是否成立，如果成立则将其发送给客户端；否则跳过该记录，然后向存储引擎索要下一条记录。
- 如此往复，直到存储引擎把表中的所有记录读完。

可以看到，使用了索引下推后，虽然 reward 列无法使用到联合索引，但是因为它包含在联合索引（age，reward）里，所以**直接在存储引擎过滤**出满足 reward = 100000 的记录后，才去执行回表操作获取整个记录。相比于没有使用索引下推，节省了很多回表操作。

当你发现执行计划里的 Extra 部分显示了 “Using index condition”，说明使用了索引下推。



