## 一、进程管理

进程是资源分配的基本单位。

> 单核的 CPU 在某一个瞬间，只能运行一个进程。但在 1 秒钟期间，它可能会运行多个进程，这样就产生**并行的错觉**，实际上这是**并发**。
>
> 并行：同时执行多个任务，多核CPU系统，多个线程可以并行执行。
>
> 并发：同一时间间隔内，处理多个任务的能力。

### 1、进程的七态模型

一个运行中的程序，就是一个进程。进程有**五种基本状态：创建、结束；运行、就绪、阻塞。**

- 运行状态：该时刻进程占据CPU；
- 就绪状态：可运行，由于其他进程处于运行状态而暂时停止运行；
- 阻塞状态：正在等待某一事件发生而暂时停止运行。

<img src="https://raw.githubusercontent.com/absolutelyd/image/main/img/8-%E8%BF%9B%E7%A8%8B%E4%BA%94%E4%B8%AA%E7%8A%B6%E6%80%81-16830133198025.webp" alt="img" style="zoom:50%;" />

如果有大量阻塞的进程会占据内存，会造成内存浪费，希望将阻塞的进程物理内存换出到硬盘，就增加了两种挂起状态：

- 阻塞挂起状态：进程在外存，等待某个事件；
- 就绪挂起状态：进程在外存，只要进入内存就会执行。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/10-%E8%BF%9B%E7%A8%8B%E4%B8%83%E4%B8%AD%E7%8A%B6%E6%80%81.jpg" alt="七种状态变迁" style="zoom:50%;" />

### 2、进程控制结构PCB

**进程控制块PCB（process control block）**数据结构描述进程。**PCB 是进程存在的唯一标识**，这意味着一个进程的存在，必然会有一个 PCB，如果进程消失了，那么 PCB 也会随之消失。

#### 2.1、PCB内容

- 进程描述信息：进程标识符，用户标识符。
- 进程的控制和管理信息：进程当前状态（七态模型）、进程优先级。
- 资源分配清单：虚拟、物理地址空间、打开的文件列表，使用的IO设备。
- CPU相关信息：进程被切换时，**CPU的状态信息、CPU寄存器信息**保存在PCB中，可以断点执行。

#### 2.2、PCB组织形式

PCB通过链表的方式进行组织，具有相同状态的进程链在一起，组成队列：就绪队列、阻塞队列。也可以使用索引表的方式组织PCB，不过一般选择链表，因为经常面临进程创建、销毁等调度行为。

### 3、进程控制

#### 3.1、创建进程

1. **申请一个空白的PCB**，向PCB中填写控制和管理进程的信息，例如进程的唯一标识。
2. 为进程**分配运行资源**，例如内存。
3. 将PCB插入到**就绪队列**。

#### 3.2、终止进程

三种终止方式：**正常结束、异常结束、外界干预**。子进程被终止，就会把父进程处继承的资源还给父进程；父进程被中止时，子进程就会变成**孤儿进程**，由1号进程收养。

1. 查找需要终止进程的**PCB**。
2. 终止正在执行状态的进程，将**CPU资源**分配给其他进程；如果有**子进程**，将子进程交给1号进程接管。
3. 将该进程的**全部资源还给操作系统**。
4. 将**进程PCB从所在队列删除**。

#### 3.3、阻塞进程

当进程需要等待某一事件完成时，它可以调用阻塞语句把自己阻塞等待。而一旦被阻塞等待，它只能由另一个进程唤醒。

1. 找到要阻塞进程标识号对应的**PCB**。
2. 如果进程是运行态，保护线程，将状态转换为**阻塞态**。
3. 将PCB插入到阻塞队列。

#### 3.4、唤醒进程

唤醒必须是其他进程发消息。

1. 从**阻塞队列**找到对应的PCB；
2. 将其从阻塞队列移出，设置为**就绪状态**；
3. 将**PCB插入到就绪队列**中，等待调度程序调度。

### 4、进程的上下文切换

从一个进程切换到另一个进程运行，是进程的上下文切换。

- **CPU上下文：CPU寄存器、程序计数器**。

- CPU上下文切换：把前一个任务的CPU上下文保存起来，加载新任务的上下文到这些寄存器和计数器。

- **进程上下文**：**虚拟内存、栈、全局变量**等用户空间的资源；**内核堆栈、寄存器**等内核空间的资源。

  进程是由内核管理和调度的，所以**进程的切换只能发生在内核态**。

通常，把交换的信息保存在PCB中。运行另外一个进程时，从这个**进程PCB取出上下文信息恢复到CPU**中。

#### 4.1、发生上下文切换的场景

1. **时间片调度**：当某个进程的时间片耗尽了，进程就从运行状态变为就绪状态，系统从就绪队列选择另外一个进程运行；
2. **等待资源**：进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行；
3. **主动挂起**：当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度；
4. **高优先级进程抢占**：当有优先级更高的进程运行时，当前进程会被挂起，由高优先级进程来运行；
5. **硬件中断**：发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。

### 5、线程

是**独立运行的基本单位**，是进程当中的一条执行流程。解决了**进程的实体间无法并发运行，切换进程代价大**的问题，线程之间可以**并发运行、共享相同的地址空间**。线程也有一个**线程控制块TCB**来控制。

#### 5.1、线程的优缺点

优点：一个进程可以共存多个线程；各个线程可以**并发执行**；各个线程之间可以**共享地址空间和文件资源**。

缺点：一个线程崩溃，整个进程都会崩溃（C/C++语言）。

#### 5.2、进程线程比较

1. **性质不同**：进程是**资源分配**（内存、打开的文件等）的单位，线程是 **CPU 调度**的单位；

2. **拥有资源不同**：进程拥有一个**完整的资源**平台，而线程只独享必不可少的资源，如**寄存器和栈**；

3. **效率不同**：不管是时间效率，还是空间效率线程比进程都要高：

   - **线程创建速度快**：线程不会涉及内存管理信息、文件管理信息，而是共享它们；

   - **线程终止速度快**：线程释放的资源相比进程少很多；

   - **同一个进程内的线程切换比进程切换快**：线程虚拟内存共享，同一个进程的线程都具有同一个页表，那么在切换的时候**不需要切换页表**。

     而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；

   - **同一进程线程数据交互效率高**：同一进程的各线程间共享内存和文件资源，线程之间数据传递的时不需要经过内核，线程之间的数据交互效率更高；

4. **线程也有七态模型**：线程也有线程同样具有就绪、阻塞、执行三种基本状态，同样具有状态之间的转换关系。

#### 5.3、线程的上下文切换

取决于线程是不是属于同一个线程：

- 当两个线程不是属于同一个进程，则切换的过程就跟进程上下文切换一样；
- 当两个线程是属于同一个进程，因为虚拟内存是共享的，**只需要切换线程的私有数据、寄存器等不共享的数据**；

#### 5.4、线程的实现

三种线程的实现方式：

- **用户线程（User Thread）**：在用户空间实现的线程，由用户态的线程库来完成线程的管理；
- **内核线程（Kernel Thread）**：在内核中实现的线程，是由内核管理的线程；
- **轻量级进程（LightWeight Process）**：在内核中来支持用户线程；

##### 5.4.1、用户线程

用户线程是基于用户态的线程管理库来实现的，操作系统看不到线程的TCB，不直接参与线程管理。多个用户线程对应同一个内核线程。

**优点：**TCB由用户线程库管理，可以在不支持线程技术的操作系统使用；线程切换不需要进入内核态，速度快。

**缺点：**没有内核管理线程，如果一个线程阻塞就会阻塞所有用户线程；用户线程没有打断其他运行线程的特权，这只能由操作系统进行；时间片只能分给进程，这样每个线程只能分进程的时间片，分到的很少，速度慢。

##### 5.4.2、内核线程

内核线程是由操作系统管理的，线程对应的 TCB 放在操作系统里的，线程的创建、终止和管理都是由操作系统负责。一个用户线程对应一个内核线程。

**优点：**某个内核线程阻塞不影响其他线程；可以直接分配时间片给线程，获得更多CPU运行时间；

**缺点：**支持内核线程的操作系统中，由内核来维护进程和线程的陕西该文信息，线程的创建、终止、切换都由系统调用完成，开销大。

##### 5.4.3、轻量级线程

轻量级进程LWP是**内核支持的用户线程**，一个进程可有一个或多个 LWP，而且 LWP 是由内核管理并像普通进程一样被调度。

每个 LWP 是跟内核线程一对一映射的，LWP与用户线程有3种不同的映射：

- LWP与用户线程一对一：优点是实现了并行，一个LWP阻塞不影响其他LWP。缺点是创建开销大。

- LWP与用户线程一对多：多个用户线程对应一个LWP，一个LWP再对应一个内核线程。优点是用户线程可以任意创建，切换效率高。缺点是一个用户线程阻塞，会导致整个进程阻塞。

- LWP与用户线程多对多：综合了前两者优点，大多数线程切换发生在用户空间。


### 6、调度

就绪->运行，运行->阻塞，运行->结束会触发调度。具体的调度算法在专门章节。

### 7、进程通信

#### 7.1、管道

管道的通信方式效率低，不适合频繁的交换数据。

##### 7.1.1、匿名管道

```bash
$ ps auxf | grep mysql
```

linux的|就是一个匿名管道，前面的一个命令的输出，作为后一个命令的输入，匿名管道传输是单向的，而且传输的是无格式的字节流数据。

创建匿名管道使用的**系统调用**：

```c
int pipe(int fd[2])
```

- 管道的读取端描述符 `fd[0]`，另一个是管道的写入端描述符 `fd[1]`。匿名管道是**特殊的文件**，只存在内存，**不存于文件系统**。

  管道本质是内核的一串缓存，写端写入的数据放在内核缓存中，读端就是从内核读取这一段数据。

- 在 shell 里通过「`|`」匿名管道将多个命令连接在一起，实际上也就是创建了多个子进程，那么在我们编写 shell 脚本时，能使用一个管道搞定的事情，就不要多用一个管道，这样可以减少创建子进程的系统开销。

- **匿名管道，它的通信范围是存在父子关系的进程**。

##### 7.1.2、命名管道

```bash
$ mkfifo myPipe  使用mkfifo的命令创建命名管道。
```

命名管道以文件的方式存在。可以往管道内写入数据，用以下命令读取管道。

```bash
$ echo "hello" > myPipe  // 将数据写进管道
$ cat < myPipe  // 读取管道里的数据
hello
```

**命名管道，它可以在不相关的进程间也能相互通信**。

##### 7.1.3、父子进程匿名管道通信

`fork` 创建子进程，创建的子进程会复制父进程的文件描述符，两个进程各有两个「 `fd[0]` 与 `fd[1]`」，两个进程就可以通过各自的 fd 写入和读取同一个管道文件实现跨进程通信了。为了避免读写混乱，一般会做这样的限制：

- 父进程关闭读取的 fd[0]，只保留写入的 fd[1]；
- 子进程关闭写入的 fd[1]，只保留读取的 fd[0]；

如果需要双向通信，则应该创建两个管道。

#### 7.2、消息队列

消息队列是**保存在内核中的消息链表**。发送数据时，分成一个个消息体（用户自定义的数据类型），**每个消息体都是固定大小的存储块**，不是管道那样无格式的数据流。类似于发邮件，发送方把消息体放在队列里，接收方接收消息体。

消息队列的缺点：

- 通信不及时。
- **不适合大数据的传输**。内核中每个消息体都有最大长度限制，整个队列的全部消息体总长度也是有上限的。
- 存在**用户态和内核态之间数据拷贝开销。**读写都需要进入内核态。

#### 7.3、共享内存

拿出一块**虚拟地址空间，映射到相同的物理内存**。这样一个进程写入的东西，其他进程就能看到了，不需要拷贝。

有了共享内存后，多个进程同时修改一块内存，就会有冲突，因此需要**信号量**保护共享内存。

#### 7.4、信号量

信号量是一个**整型的计数器**，主要用于实现进程间的**互斥与同步**，而不是用于缓存进程间通信的数据。**信号量表示资源的数量**，控制信号量的方式有**两种原子操作**：

- **P 操作**，信号量减去 1，相减后如果信号量 < 0，则表明资源已被占用，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使用，进程可正常继续执行。
- **V 操作**，信号量加上 1，**相加后如果信号量 <= 0**（说明释放资源后，仍然没有多余资源，也就是当前还有进程在等待资源），则表明当前有阻塞中的进程，于是会将该进程唤醒运行；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；

P 操作是用在进入共享资源之前，V 操作是用在离开共享资源之后，这两个操作是必须成对出现的。

##### 7.4.1、共享内存的信号量

- 进程A访问共享内存前，先执行P操作，信号量变为0；
- 进程B访问共享内存，执行P操作，信号量变为-1，说明临界资源被占用。
- 进程A访问完共享内存，执行V操作，信号量恢复为0，唤醒进程B，使得进程B可以访问共享内存。

##### 7.4.2、互斥与同步

- **互斥信号量**：信号量初始化为1，就代表这是互斥信号量，可保证任意时刻只有一个线程访问共享资源；
- **同步信号量：**信号量初始化为0，可保证线程 A 应在线程 B 之前执行；

#### 7.5、信号

信号是进程间通信机制中**唯一的异步通信机制**，是一种**异常情况下的工作模式**。可以在任何时候发送信号给某一进程。**用户进程对信号的3种处理方式：**

- 执行默认操作。例如Ctrl+C 产生 `SIGINT` 信号，表示终止该进程；Ctrl+Z 产生 `SIGTSTP` 信号，表示停止该进程，但还未结束。
- 捕捉信号。以执行信号处理函数。可以自定义一个信号处理函数。
- 忽略信号。两个信号无法捕捉和忽略： `SIGKILL` 和 `SEGSTOP`，用于在任何时候中断或结束某一进程。

#### 7.6、Socket

管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，**跨网络与不同主机上的进程之间通信，就需要 Socket 通信**。Socket 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。

有三种不同通信的编程模式：

##### 7.6.1、针对TCP协议通信的Socket编程

1. 服务端和客户端初始化 `socket`，得到**文件描述符**；
2. 服务端调用 `bind`，将**绑定在 IP 地址和端口**;
3. 服务端调用 `listen`，进行**监听**；
4. 服务端调用 `accept`，**等待客户端连接**；
5. 客户端调用 `connect`，向服务器端的地址和端口**发起连接请求**；
6. 服务端 `accept` 返回用于传输的 `socket` 的**文件描述符**；
7. 客户端调用 `write` 写入数据；服务端调用 `read` 读取数据；
8. 客户端断开连接时，会调用 `close`，那么服务端 `read` 读取数据的时候，就会读取到了 `EOF`，待处理完数据后，服务端调用 `close`，表示连接关闭。

服务端调用 `accept` 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。监听的 socket 和真正用来传送数据的 socket，是「**两个**」 socket，一个叫作**监听 socket**，一个叫作**已完成连接 socket**。

成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。

##### 7.6.2、针对UDP协议通信的Socket编程

UDP 是没有连接的，也就没有所谓的发送方和接收方，只要有一个 socket ，多台机器就可以任意通信。所以不需要三次握手，**不需要调用 listen 和 connect**，但是 UDP 的交互仍然需要 IP 地址和端口号，因此**也需要 bind**。

每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。

##### 7.6.3、针对本地进程通信的Socket编程

本地 socket 被用于在**同一台主机上进程间通信**：

- 本地 socket 的编程接口和 IPv4 、IPv6 套接字编程接口是一致的，可以支持「字节流」和「数据报」两种协议；
- 本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；

本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是**绑定一个本地文件**，这也就是它们之间的最大区别。

### 8、多线程冲突

#### 8.1、同步与互斥

**互斥**：多线程执行**操作共享变量**的这段代码会导致**竞争状态**，这使得每次运行会得到不同结果，导致结果存在**不确定性**。对于访问共享资源的代码片段，应该是**互斥**的，保证一个线程再临界区执行时，其他线程应该被阻止进入临界区。

**同步**：并发进程/线程在一些关键点上可能需要**互相等待与互通消息**，这种相互制约的等待与互通信息称为进程/线程同步。

同步与互斥通过**锁、信号量**实现。

#### 8.2、锁

使用加锁操作和解锁操作可以解决并发线程/进程的**互斥**问题。根据锁的实现可以分成**自旋锁**和**无等待锁**。

##### 8.2.1、CPU的原子操作

现代CPU提供了一个**原子操作**指令：测试和置位（Test-and-Set）指令。

```c
int TestAndSet(int *old_ptr, int new) {
    int old = *old_ptr;
    *old_ptr = new;
    return old;
}
```

把old_ptr的值更新为new的新值，返回old_ptr的旧值。这些代码可以**原子执行**。

##### 8.2.2、利用原子操作实现的忙等待锁

设置一个互斥信号量lock，初始化为0，只有测试和置位原子操作返回的是0的时候才会成功加锁，否则就一直循环。

```c
void init(lock_t *lock) {
    lock->flag = 0;
}

void lock(lock_t *lock) {
	while(TestAndSet(&lock->flag, 1) == 1);
}

void unlock(lock_t *lock) {
    lock->flag = 0;
}
```

- 没有其他线程持有锁，flag是0，调用TestAndSet(&lock->flag, 1)会返回0，线程会跳出while循环，获取锁。
- 其他线程持有锁，本线程调用lock，会停在while循环中，本线程会一直忙等。

这种锁在获取不到时就会一直while循环，不做任何事情，是忙等待锁，也就是**自旋锁**。自旋锁需要抢占式的调度器（不断通过时钟中断一个线程，保证能运行其他线程），否则在单核CPU上无法使用。

##### 8.2.3、无等待锁

无等待锁就是获取不到锁的时候，不用自旋，而是**把当前线程放入锁的等待队列**，执行**调度程序**，把CPU让给其他线程。

```c
void init(lock_t *lock) {
    lock->flag = 0;
}

void lock(lock_t *lock) {
	while(TestAndSet(&lock->flag, 1) == 1){
        // 保存运行线程TCB，并将TCB插入到等待队列
        // 设置该线程为等待状态
        // 调度程序
    }
}

void unlock(lock_t *lock) {
    lock->flag = 0;
}
```

#### 8.3、生产-消费者问题

生产者-消费者问题描述：

- **生产者**在生成数据后，放在一个缓冲区中；
- **消费者**从缓冲区取出数据处理；
- 任何时刻，**只能有一个**生产者或消费者可以访问缓冲区；

问题分析：

- 任何时刻只能有一个线程操作缓冲区，说明操作缓冲区是临界代码，**需要互斥**；
- 缓冲区空时，消费者必须等待生产者生成数据；缓冲区满时，生产者必须等待消费者取出数据。说明生产者和消费者**需要同步**。

信号量：

- 互斥信号量 `mutex`：用于互斥访问缓冲区，初始化值为 1；
- 资源信号量 `fullBuffers`：用于消费者询问缓冲区是否有数据，有数据则读取数据，初始化值为 0（表明缓冲区一开始为空）；
- 资源信号量 `emptyBuffers`：用于生产者询问缓冲区是否有空位，有空位则生成数据，初始化值为 n （缓冲区大小）；

实现代码：

```c++
#define N 100
semaphore mutex = 1;
semaphore emptyBuffers = N;
semaphore fullBuffers = 0;

void producer() {
    while(TRUE) {
        P(emptyBuffers);
        P(mutex);
        // 生成的数据放到缓冲区
        V(mutex);
        V(fullBuffers);
    }
}

void consumer() {
    while(TRUE) {
        P(fullBuffer);
        P(mutex);
        // 缓冲区读取数据
        V(mutex);
        V(emptyBuffers);
    }
}
```

#### 8.4、哲学家就餐问题

**问题描述：**

- `5` 个哲学家，围绕着一张圆桌吃面；桌子只有 `5` 支叉子，每两个哲学家之间放一支叉子；
- 哲学家围在一起先思考，思考中途饿了就会想进餐；哲学家需要拿到左右两边的叉子才进餐；
- 吃完后，会把两支叉子放回原处，继续思考。

如果只是让哲学家先拿左边，再拿右边，会在极端情况下，让所有人拿起左边的，却没有右边的，陷入死锁。

##### 8.4.1、方案一：只允许一个哲学家就餐

在哲学家拿叉子之前需要获取信号量，同一时间只有一个哲学家拿叉子、进食。虽然解决了死锁问题，但是效率很低。

##### 8.4.2、方案二：分支结构

按照编号采取不同的分支结构，避免哲学家可以同时拿起左边叉子的极端情况。**让偶数编号的哲学家「先拿左边的叉子后拿右边的叉子」，奇数编号的哲学家「先拿右边的叉子后拿左边的叉子」。**V操作不会阻塞，不需要分支。

虽然也有一些极端情况，但是至少有人能拿起两双筷子，效率更高。

##### 8.4.3、方案三：原子操作

结合CPU原子操作的想法，让哲学家要么两个叉子都拿起，要么都不能拿起。用一个数组 state 来记录每一位哲学家的三个状态，分别是在进餐状态、思考状态、饥饿状态（正在试图拿叉子）。

一个哲学家只有在**两个邻居都没有进餐时**，才可以进入进餐状态。在放下筷子时，如果两边哲学家阻塞，就唤醒他们拿筷子。

#### 8.5、读者-写者问题

生产、消费者问题，哲学家进餐问题对于互斥访问有限的竞争问题（如 I/O 设备）一类的建模过程十分有用。「读者-写者」问题，它为**数据库访问**建立了一个模型。

**问题描述：**

- 「读-读」允许：同一时刻，允许多个读者同时读。
- 「读-写」互斥：没有写者时读者才能读，没有读者时写者才能写。
- 「写-写」互斥：没有其他写者时，写者才能写。

##### 8.5.1、方案一：读者优先策略

- 信号量 `wMutex`：控制写操作的互斥信号量，初始值为 1。读者**读之前会获取写操作信号量，直到最后一个读者退出才会释放**。正因此，存在读者时，后续读者能不断进入，写者会阻塞，是读者优先策略。

- 读者计数 `rCount`：正在进行读操作的读者个数，初始化为 0；

- 信号量 `rCountMutex`：控制对 rCount 读者计数器的互斥修改，初始值为 1；

```c++
semaphore wMutex;
semaphore rCountMutex;
int rCount = 0;

void writer() {
    while(TRUE) {
        P(wMutex);
        write();
        V(wMutex);
    }
}

void reader() {
    while(TRUE) {
        P(rCountMutex);
        if(rCount == 0) {
            P(wMutex);
        }
        rCount ++;
        V(rCountMutex);
        read();
        
        P(rCountMutex);
        rCount --;
        if(rCount == 0) {
            V(wMutex);
        }
        V(rCountMutex);
    }
}
```

##### 8.5.2、方案二：写者优先策略

新增如下变量：

- 信号量 `rMutex`：读写互斥量，初始值为 1。**写者都会持有该信号量，直到最后一个写者退出才释放**，保证了写者优先。
- 信号量 `wDataMutex`：写操作互斥量，初始值为 1，读者全部退出才会释放，写操作要获取这个信号量才能写。
- 写者计数 `wCount`：记录写者数量，初始值为 0；
- 信号量 `wCountMutex`：控制 wCount 互斥修改，初始值为 1；

```c++
semaphore rMutex; // 控制读者进入的互斥信号量
semaphore wDataMutex; // 控制写操作的互斥信号量

int rCount = 0;
semaphore rCountMutex; // 控制对rCount的互斥修改
int wCount = 0;
semaphore wCountMutex; // 控制对rCount的互斥修改

void writer() {
    while(TRUE) {
        P(wCountMutex);
        if(wCount == 0){
            P(rMutex);
        }
        wCount++;
        V(wCountMutex); // 或者读写互斥量也不能立即开始写，要让最后一个读者退出才能开始写
        P(wDataMutex);// 写操作互斥
        write();
        V(wDataMutex);
        
        P(wCountMutex);
        wCount--;
        if(wCount == 0){ // 只有没有写者时，才能让读者运行
            V(rMutex);
        }
        V(wCountMutex);
    }
}

void reader() {
    while(TRUE) {
        P(rMutex); // 当有写者持有该互斥量时，读者都被阻塞
        P(rCountMutex);
        if(rCount == 0) {
            P(wDataMutex);
        }
        rCount ++;
        V(rCountMutex);
        V(rMutex); 
        read();
        
        P(rCountMutex);
        rCount --;
        if(rCount == 0) { //最后一个读者退出时才能写
            V(wDataMutex);
        }
        V(rCountMutex);
    }
}
```

##### 8.5.3、方案三：公平策略

**只能一个写者访问临界区**（这是与写者优先的区别），可以有多个读者同时访问临界资源，只需要**在读者优先策略上加一个flag，让有写者等待时，后续读者不会无限进入**（与读者优先的区别）。

```c++
semaphore wDataMutex;// 写操作互斥量，保证读完才写
semaphore flag; // 实现公平竞争

semaphore rCountMutex;
int rCount = 0;

void writer() {
    while(TRUE) {
        P(flag);
        P(wDataMutex);
        write();
        V(wDataMutex);
        V(flag);
    }
}

void reader() {
    while(TRUE) {
        P(flag);
        P(rCountMutex);
        if(rCount == 0) {
            P(wDataMutex);
        }
        rCount ++;
        V(rCountMutex);
        V(flag);
        read();
        
        P(rCountMutex);
        rCount --;
        if(rCount == 0) {
            V(wDataMutex);
        }
        V(rCountMutex);
    }
}
```

### 9、死锁

两个线程为了保护两个不同的**共享资源**使用了两个互斥锁，应用不当可能会造成两个线程**都在等待对方释放锁**，相互等待无法继续运行，就是发生了死锁。

#### 9.1、死锁产生的条件

- **互斥**：多个进程不能同时使用同一个资源；
- **持有并等待**：线程A在等待资源2的同时，不会释放自己已经持有的资源；
- **不可剥夺**：线程已经持有资源，在自己使用完之前不能被其他线程获取。
- **环路等待条件**：两个线程获取资源的顺序构成了环形链。例如线程A持有资源2，请求1，线程持有资源1，请求2。

#### 9.2、避免死锁发生

只要破坏死锁产生的四个必要条件中的一个就可以。

##### 9.2.1、资源有序分配法

破坏了环路等待条件，进程A和B请求资源的顺序是一样的。

##### 9.2.2、银行家算法

避免在资源分配过程中，导致了系统的不安全状态。

### 10、悲观锁、乐观锁

#### 10.1、互斥锁、自旋锁 - 最基础的两种锁

当加锁失败时，**互斥锁用「线程切换」**来应对，**自旋锁则用「忙等待」**来应对。

##### 10.1.1、互斥锁

**互斥锁**加锁失败后，线程会**释放 CPU** ，给其他线程，所以线程加锁的代码就会被阻塞。

**实现方式**：互斥锁由**操作系统内核实现**，有**两次线程上下文切换的成本**：

- 当**线程加锁失败**时，内核会把线程的状态从「运行」状态设置为「睡眠」状态，然后把 CPU 切换给其他线程运行；
- 当**锁被释放时**，之前「睡眠」状态的线程会变为「就绪」状态，然后内核会在合适的时间，把 CPU 切换给该线程运行。

**特点**：如果能确定锁住的代码执行时间很短，就不该用互斥锁，避免上下文切换的代价。

##### 10.1.2、自旋锁

**自旋锁**加锁失败后，线程会**忙等待**，直到它拿到锁。

**实现方式**：自旋锁由**CPU提供的CAS（Compare And Swap）函数**实现：在用户态完成加锁解锁，**不产生线程的上下文切换**。

加锁分为两个步骤：查看锁的状态是否空闲；将锁设置为当前线程所有。CAS将两个步骤合并成一个硬件级指令，形成**原子指令**。

**特点**：单核CPU上，需要抢占式的调度器（不断通过时钟中断线程，切换其他线程运行），否则自旋锁永远不会放弃CPU，在单核CPU上无法使用。自旋锁**开销少**。

#### 10.2、读写锁

读写锁适用于能明确区分读操作、写操作的场景。

**实现方式**：类似于多线程冲突的读者-写者问题：

- 读优先锁：获取**写锁会被阻塞**，直到**所有读锁释放才能获取写锁**。对于读线程并发性更好，但是容易导致写线程一直获取不到锁。

- 写优先锁：获取**写锁被阻塞**，但是**后续所有的读锁也阻塞**，无法获得，直到读锁释放后，获取写锁。保证写进程不会被饿死，但是读进程可能会被饿死。
- 公平读写锁：把读写进程按照先进先出的方式加入队列。

#### 10.3、乐观锁、悲观锁

**悲观锁**：**互斥锁、自旋锁、读写锁都是悲观锁**，认为多线程同时修改共享资源的概率高，容易出现冲突，**访问共享资源前先上锁**。

**乐观锁（无锁编程）**：假定冲突的概率很低，先修改完共享资源，再验证这段时间有没有发生冲突。没有其他线程修改资源就操作完成，有其他线程修改过这个资源就放弃操作。

**在线文档的乐观锁模式**：浏览器下载文档时带上版本号，先让用户编辑文档；用户提交修改时，会带上原始文档版本号，版本号不一致就提交失败，版本号一致就会修改成功。

乐观锁虽然去除了加锁解锁的操作，但是一旦发生冲突，重试的成本非常高，所以**只有在冲突概率非常低，且加锁成本非常高的场景时，才考虑使用乐观锁。** 

### 11、一个进程最多可以创建多少线程？

要看操作系统、系统位数、硬件条件：

- **进程的虚拟内存限制**。创建一个线程，操作系统会为其分配一个**栈空间**，一个线程会占据10M左右的虚拟内存。

  Linux32位系统的3G用户空间能创建300多个线程。Windows的一个进程只能使用2G空间，一个进程能创建200多个。

- 系统参数限制。Linux的系统线程编号有上限，支持的线程总数也有上限。

### 12、线程崩溃了，进程也会崩溃吗？

#### 12.1、C/C++ 中线程崩溃，进程会直接崩溃

进程中，各个线程之间的地址空间共享，**某个线程对地址的非法访问会导致内存的不确定性**，会**影响到其他线程**，操作系统会直接使用**信号**让进程崩溃。

**信号**机制崩溃：kill信号执行的是系统调用，控制权交给内核，内核给指定的进程发送信号。

- 如果进程没有注册自己的信号处理函数，操作系统会执行默认的信号处理程序。
- 如果进程**注册了自己的信号处理函数**，收到kill信号后，可以调用exit()退出。
