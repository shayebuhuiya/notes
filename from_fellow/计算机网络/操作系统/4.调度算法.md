## 一、调度算法

### 1、进程调度算法

进程调度原则：

- **吞吐量**：权衡长任务、短任务的完成数量，提高系统的吞吐量（单位时间内CPU完成进程的数量）；
- **周转时间、等待时间**：周转时间=运行时间+等待时间，避免程序等待很长，运行时间很短；
- **响应时间**：交互式应用，响应时间很重要。
- **CPU利用率**：发生IO事件导致CPU空闲时，直接从就绪队列选一个进程来执行，提高CPU利用率；

#### 1.1、先来先服务调度FCFS

每次从就绪队列选择最先进入队列的进程。**FCFS 对长作业有利**（长作业长期占据CPU，后面的短作业长期等待），适用于 CPU 繁忙型作业的系统，而**不适用于 I/O 繁忙型作业**（IO繁忙会多次进出队列）的系统。

#### 1.2、最短作业优先调度SJF

优先选择运行时间最短的进程执行。**对长作业不利**。

#### 1.3、高响应比优先调度HRRN

先执行响应比高的进程，**权衡短作业和长作业**。

响应比优先级：**（等待时间+要求服务时间）/要求服务时间**。要求服务时间是不可预知的，因此是一个理想型算法，不可实现。

- 如果两个进程等待时间相同，要求的服务时间越短，响应比越高，容易被选中。

- 如果两个进程要求的服务时间相同，等待时间越长，响应比越高，兼顾了长作业。

#### 1.4、时间片轮转调度

每个进程分配一个时间段。

#### 1.5、最高优先级调度HPF

从就绪队列中选择最高优先级的进程运行。这可能会导致低优先级的进程永不运行。

- 静态优先级：创建进程就确定优先级，整个运行时间优先级都不变。
- 动态优先级：根据进程动态变化调整优先级。
- 非抢占式：就绪队列中出现优先级高的进程，先运行完当前进程。
- 抢占式：就绪队列出现优先级高的进程，当前进程挂起，运行优先级高的进程。

#### 1.6、多级反馈队列调度算法

综合**时间片轮转**、**最高优先级**算法。

- **多级：**较高优先级队列为空，才调度低优先级队列的任务。队列优先级越低，时间片越长，**长作业**会多次跳转队列，可以分到的时间片越来越长。

  **任务在队列跳转方式：**新进程加入第一级队列的末尾，**队列内先来先服务**调度。如果第一级队列规定的时间片内没有完成，就转入第二级列。

- **反馈：**如果有新进程加入更高优先级队列，就会停止当前进程并将其移入队末尾，让较高优先级的进程运行，这样可以保证**实时任务的响应时间**。

兼顾**周转时间、响应时间**，同时**兼顾了长短作业**。

##### 1.6.1、priority boost 机制防止低优先级长任务饿死

可能在交互类任务太多时导致低优先级的长任务饿死。多级反馈队列中还有一个priority boost机制，一段时间后，会让所有任务提升到最高优先级队列，防止一直有新的任务来，让低优先级的长任务饿死。

### 2、内存页面置换算法

**缺页中断**：CPU访问的页面不在物理内存时，产生缺页中断。

**缺页中断和一般中断有2点不同：**

- 缺页中断会在指令执行期间，而不是执行完成后产生；

- 中断返回后会**回到指令起点重新执行**，而不是回到下一条指令执行。

**缺页中断处理流程**：

1. CPU访问一条Load M指令，CPU寻找M对应的**页表项**（存放逻辑地址与物理地址的映射关系）；
2. 该页表项是有效的，CPU可以直接访问内存，若是**页表项无效**，CPU会**发送缺页中断。**
3. 操作系统执行**缺页中断处理函数**，找到页面在磁盘中对应的位置，在物理内存中找到空闲页，换入内存。如果**没有空闲页**，就会触发**页面置换**算法。
4. **页表项的状态位修改为有效**的，重新执行导致CPU缺页异常的指令。

**页面置换算法功能：**当出现缺页异常，需调入新页面而内存已满时，**选择一个物理页面换出到磁盘**，然后把需要访问的页面换入到物理页。

#### 2.1、最佳页面置换算法

置换在**未来最长时间不访问的页面**。计算内存中每个逻辑页面下一次访问的时间，选择未来最长时间不访问的页面，但是这无法实现，因此算法作用仅仅是衡量其他算法的效率。

#### 2.2、先进先出置换算法

选择在内存驻留时间很长的页面进行置换。

##### 2.2.1、Belady异常

内存中可以使用的页数上升，页的命中率反而下降。

异常原因：因为**FIFO置换算法完全没有考虑使用频率**，即使可用的页数变多，多留存下来的部分，接下来被访问的概率也不一定大。

#### 2.3、最近最久未使用置换算法LRU

选择最长时间没有被访问页面进行置换，假设很久没有使用的页面，在未来较长一段时间也不会使用。

实现的代价很高，要在内存中**维护一个所有页面的链表**，每次访问都要找到一个页面删除，把他移动到表头。

#### 2.4、时钟页面置换算法

把所有页面保存在一个环形链表中，一个指针指向最老的页面。

- 缺页中断时，访问位是0就淘汰页面，新的页面插入这个位置，指针前移一个位置；
- 访问位是1，把访问位置1，指针前移，直到找到一个访问位为0的页面。

#### 2.5、最不常用算法LFU

选择访问次数最少的页面将其淘汰。对**每个页面设置一个访问计数器**，每次访问就将计数器加1，缺页中断时淘汰计数器最少的一个。

**缺点：**

- 是给每个页面加上计数器，硬件成本高；
- 并且删除页面时，需要遍历链表，成本较高；
- **只考虑了频率，没考虑时间**，忽略了一些访问次数多，但是很久没有访问的页面，这一点可以通过定期把访问次数除以2，让过去高访问次数页面逐渐被淘汰。

### 3、磁盘调度算法

#### 3.1、先来先服务FCFS

实现简单，但是大量进程竞争使用磁盘，访问的磁道会很分散，寻道时间会过长。

#### 3.2、最短寻道时间SSF

优先从当前磁头位置寻找所需寻道时间最短的请求。缺点是容易导致某些请求的饥饿，磁头只在一小块区域移动。

#### 3.3、扫描算法SCAN

解决了SSF磁头只在一小块区域的问题，规定磁头在一个方向上移动，访问所有未完成的请求，直到磁头达到这个方向上最后的磁道，才调换方向。

不会产生饥饿现象，但是会导致中间部分比其他部分响应频率多

#### 3.4、循环扫描C-SCAN

磁道只响应一个方向的请求，只有朝一个特定方向移动才处理磁道访问请求，返回时**快速移动到最边缘的磁道，直接复位磁头。**

相比起扫描算法，各个位置磁道响应频率比较平均。

#### 3.5、LOOK与C-LOOK

优化扫描算法与循环扫描，磁头移动到**最远的请求位置**，立即反向移动，**不会移动到磁盘的最末端。**
