## 一、TCP/IP网络模型

**分层的网络模型目的**：在不同的设备上通信需要一套**通用的网络协议**。

### 1、四层网络每一层的封装样式

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="img" style="zoom:50%;" /> 

## 二、网页显示过程

从键入网址，到网页信息显示的过程。

### 1、HTTP

#### 1.1、URL(Uniform resource locator，统一资源定位系统)

在键入网址后，浏览器的**第一步工作是对URL进行解析**，从而生成发送给web服务器的请求信息。

##### 1.1.1、URL元素组成

- URL开头表示访问数据的协议：HTTP、HTTPS。
- //后面的字符串表示服务器的名称。
- 之后输入web服务器名。
- 最后是数据源的路径名：/ + 目录名 + / … + 文件名。

URL实际上是在**请求服务器里的文件资源**。如果**没有路径名时，访问根目录下设置的默认文件** `/index.html` 或者 `/default.html` 这些文件，这样就不会发生混乱了。  

#### 1.2、HTTP请求

对URL进行解析后，浏览器确定了Web服务器和文件名，**第二步是生成HTTP请求信息**。

### 2、真实地址查询DNS

通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 `Web` 服务器。这要**查询服务器域名对应的 IP 地址**。

#### 2.1、DNS(Domain Name System)域名系统

用于**查询服务器域名对应的 IP 地址** ，DNS表中保存了Web服务器域名和IP之间的对应关系，**DNS的特点是只指路，不带路。**

#### 2.2、域名的层级关系

DNS中的域名都是用句点分割的，**越靠右表示层级越高。**这里的句点代表了不同层次之间的**界限**。**域名的层级关系类似一个树状结构：**

- 根 DNS 服务器（.）

- 顶级域 DNS 服务器（.com）

- 权威 DNS 服务器（server.com）

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/5.jpg" alt="DNS 树状结构" style="zoom:33%;" />

**根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中**。这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。

#### 2.3、DNS解析域名的工作流程

1. 客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP 是啥，并发给**本地 DNS 服务器**。
2. 本地域名服务器收到客户端的请求后：
   - 如果缓存里的表格能找到 www.server.com，则它直接返回 IP 地址。
   - 如果没有，本地 DNS 会去问它的**根域名服务器**： 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。
3. 根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，给出了**.com 顶级域名服务器**的地址。
4. 本地 DNS 收到顶级域名服务器的地址后，就问.com 顶级域名服务器： www.server.com 的 IP 地址。
5. 顶级域名服务器给出了 www.server.com 区域的**权威 DNS 服务器****的地址。
6. 本地 DNS 于是转向问权威 DNS 服务器，它是域名解析结果的原出处，所以称之为权威。
7. 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。
8. 本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。 


#### 2.4、DNS缓存

实际解析过程中，**浏览器会先查看自己的缓存**，如果没有再去访问**操作系统缓存**，如果还是没有，才会最终访问**本地DNS服务器**。

### 3、指南帮手-协议栈

通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的**协议栈**。浏览器通过**调用Socket库，委托协议栈工作。**协议栈上一半是负责收发数据的TCP和UDP协议，下面一半是IP协议控制网络包收发过程。

协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，**上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。**

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/7.jpg" alt="img" style="zoom:50%;" />

#### 3.1、IP协议

**IP中包含ICMP协议和ARP协议**：

- ICMP协议（Internet Control Message Protocol）：用于告知网络包传送过程中产生的**错误**以及各种**控制信息**。
- ARP协议（Address Resolution Protocol）：用于根据**IP地址**查询相应的以太网**MAC地址**。

IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。 

### 4、可靠传输：TCP

HTTP 是基于 TCP 协议传输的。

#### 4.1、TCP报文头部

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/8.jpg" alt="TCP 包头格式" style="zoom: 50%;" />

- **源端口号和目标端口号**是必不可少的，标注应发给哪个应用。
- **包序号**：解决了**包乱序**问题。
- **确认号**：确认发出去对方有收到，否则应该重新发送，解决了**丢包**问题。
- **状态位**： 例如 `SYN` 是发起一个连接，`ACK` 是回复，`RST` 是重新连接，`FIN` 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。 
- **窗口大小**：实现了TCP的**流量控制**。通信双发标识自己能处理的能力，避免发送太快或者太慢。
- **拥塞控制**：控制自己发送的速度，避免网络堵塞。

#### 4.2、TCP三次握手

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手" style="zoom:33%;" /> 

- 一开始，客户端和服务端都处于 `CLOSED` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态。
- 然后客户端主动发起连接 `SYN`（同步序列编号），之后处于 **`SYN-SENT` 状态。**
- 服务端收到发起的连接，返回 `SYN`，并且 `ACK` 客户端的 `SYN`，之后处于 **`SYN-RCVD` 状态**（表示接受到了SYN报文）。
- 客户端收到服务端发送的 `SYN` 和 `ACK` 之后，发送对 `SYN` 确认的 `ACK`，之后**处于 `ESTABLISHED` 状态**，因为它一发一收成功了。
- 服务端收到 `ACK` 的 `ACK` 之后，处于 `ESTABLISHED` 状态，因为它也一发一收了。

所以三次握手目的是**保证双方都有发送和接收的能力**。

> ##### 查看TCP的连接状态
>
> 在Linux中可以通过 `netstat -napt` 命令查看TCP的连接状态。
>

#### 4.3、TCP分割数据

如果 HTTP 请求消息比较长，超过了**最大报文段长度`MSS`** 的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。 

- `MTU`最大传输单元：一个网络包的最大长度，以太网中一般为 `1500` 字节。

- `MSS`最大报文段长度：**除去 IP 和 TCP 头部**之后，一个网络包所能容纳的 TCP 数据的最大长度。

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/11.jpg" alt="MTU 与 MSS" style="zoom: 33%;" />

- 在TCP协议中，数据会被以 `MSS` 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。  


#### 4.4、TCP报文生成

TCP 协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（HTTP 默认端口号是 `80`， HTTPS 默认端口号是 `443`）。

在双方建立了连接后，**TCP 报文中的数据部分就是存放 HTTP 头部 + 数据**，组装好 TCP 报文之后，就需交给下面的网络层处理。

### 5、远程定位-IP

TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成**网络包**发送给通信对象。

#### 5.1、IP报头格式

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/14.jpg" alt="IP 包头格式" style="zoom: 33%;" />

- 源地址IP，即是客户端输出的 IP 地址；
- 目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。

-  **协议号：**因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的**协议号**，要填写为 `06`（十六进制），表示协议为 TCP。 
-  **TTL：生存时间值。**单位是路由器**跳数**。每次路由器转发都会-1，保证报文不会无休止发送。

#### 5.2、路由表规则

在存在多块网卡时，这个时候就需要根据**路由表**规则，来判断哪一个网卡作为源地址 IP。

1. 遍历路由表，首先用**目标地址**和**第一条目的子网掩码**进行 **与运算**，得到结果与这一条目的Destination进行比对，如果不一致匹配失败。

2. 接下来继续匹配，直到成功。

3. 比较特殊的是，目标地址和子网掩码都是 `0.0.0.0`，这表示**默认网关**。如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器，**`Gateway` 即是转发给的路由器的 IP 地址**。

### 6、两点传输MAC

生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 **MAC 头部**。

#### 6.1、MAC 头部

MAC头部是以太网使用的头部，只有三个信息：**发送方 MAC 地址**、**接收方目标 MAC 地址**和**协议类型**，用于**两点之间的传输。**一般在 TCP/IP 通信里，MAC 包头的**协议类型**只使用：

- `0800` ： IP 协议
- `0806` ： ARP 协议

**发送方**的 MAC 地址：MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。

**接收方**的 MAC 地址：通过路由表获取接收方的IP地址后，**通过ARP协议获取MAC地址**。

#### 6.2、ARP协议

ARP协议将IP地址转换为MAC地址：ARP 协议会在以太网中以**广播**的形式，对以太网所有的设备进行询问，对应IP的设备就会回应自己的MAC地址。 

#### 6.3、ARP缓存

每次**操作系统**会将本次查询结果放入缓存，在查询时先查询缓存，不存在的话就发送ARP广播。在发包时：

- 先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。
- 而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。 

### 7、网卡-出口

网卡将**数字信息转换为电信号**，才能在网线上传输。

控制网卡靠**网卡驱动程序**。网卡驱动获取网络包之后，会将其**复制**到网卡内的缓存区中，接着会在其**开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列**。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%8C%85.drawio.png" alt="数据包" style="zoom: 67%;" /> 

- 起始帧分界符是一个用来表示包起始位置的标记；
- 末尾的 `FCS`（帧校验序列）用来检查包传输过程是否有损坏；

### 8、交换机-送别者

交换机的设计是将网络包**原样**转发到目的地。交换机工作在 MAC 层，也称为**二层网络设备**。 

#### 8.1、交换机工作流程

1. 电信号到达网线接口，交换机里的模块进行接收，并将**电信号转换为数字信号**。

2. 然后通过包末尾的 **`FCS` 校验错误**，如果没问题则**放到缓冲区**。

3. 与网卡不同的是，**交换机的端口不具有MAC地址**，因此还需要检查这个包的接收方MAC地址是否在自己的MAC地址表中有记录。如果有就发送到对应的端口。


#### 8.2、找不到指定的MAC地址

**交换机的 MAC 地址表**主要包含两个信息：**设备的 MAC 地址**；这个设备连接的**交换机端口号**。

**原因：**地址表中找不到指定的 MAC 地址。这可能是因为**具有该地址的设备还没有向交换机发送过包**，或者这个设备**一段时间没有工作**导致地址被从地址表中删除了。 

**处理方式：**将这个包转发给所有除了源端口之外的其他端口，**只有相应的接收者才接收包，而其他设备则会忽略这个包。**如果得到响应之后，就会把这个MAC地址写入MAC表，下一次就不用广播了。

**以太网的设计本来就是将包发送到整个网络的**，这样做很合适。 

> **以太网：**电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。

#### 8.3、广播地址

如果接收方 MAC 地址是一个**广播地址**，那么交换机会将包发送到除源端口之外的所有端口。以下两个属于广播地址：

- MAC 地址中的 `FF:FF:FF:FF:FF:FF`
- IP 地址中的 `255.255.255.255`

### 9、路由器-出境大门

网络包经过交换机之后，现在到达了**路由器**，并在此被转发到下一个路由器或目标设备。现在的路由器大多也具有了交换机的功能。

#### 9.1、路由器和交换机的区别

- 因为**路由器**是基于 IP 设计的，俗称**三层**网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；
- 而**交换机**是基于以太网设计的，俗称**二层**网络设备，交换机的端口不具有 MAC 地址。

#### 9.2、路由器的基本原理

- 路由器的**端口具有 MAC 地址**，因此它就**能够成为以太网的发送方和接收方**；

- 同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的。

当转发包时，首先路由器端口会接收发给自己的以太网包，然后**路由表**查询转发目标，再由相应的端口作为发送方将以太网包发送出去。

#### 9.3、路由器接收包

1. 首先，电信号到达网线接口部分，路由器中的模块会**将电信号转成数字信号**，然后**通过包末尾的 `FCS` 进行错误校验。**

2. 如果没问题则**检查 MAC 头部中的接收方 MAC 地址**，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。


总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。

#### 9.4、查询路由表确定输出端口

1、完成包接收操作之后，路由器就会**去掉**包开头的 MAC 头部。**MAC 头部的作用就是将包送达路由器**，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会**被丢弃**。

2、接下来，路由器会根据 MAC 头部后方的 `IP` 头部中的内容进行包的转发操作。 转发操作分为几个阶段：

  - 首先是查询**路由表**判断转发目标。 根据包的接收方 IP 地址**查询路由表中的目标地址栏，以找到相匹配的记录**。 路由表：

    <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/24.jpg" alt="路由器转发" style="zoom:50%;" /> 

  - 每个条目的子网掩码和 `192.168.1.100` IP 做 **& 与运算**后，得到的结果与对应条目的目标地址进行匹配，如果匹配就会作为候选转发目标，如果不匹配就继续与下个条目进行路由匹配。

  - 实在找不到匹配路由时，就会选择**默认路由**，路由表中子网掩码为 `0.0.0.0` 的记录表示「默认路由」。 

#### 9.5、路由器的发送操作

1. 根据**路由表的网关列**判断对方的地址。

   - 如果**网关是一个 IP 地址**，则这个IP 地址就是我们要转发到的目标地址，**还未抵达终点**，还需继续需要路由器转发。

   - 如果**网关为空**，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明**已抵达终点**。

2. 知道对方的 IP 地址之后，**接下来需要通过 `ARP` 协议根据 IP 地址查询 MAC 地址**，并将查询的结果作为接收方 MAC 地址。路由器也有 ARP 缓存，因此**首先会在 ARP 缓存中查询**，如果找不到则发送 ARP 查询请求。

3. 网络包完成后，接下来会将其**转换成电信号并通过端口发送出去**。发送出去的网络包会**通过交换机到达下一个路由器**。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。

4. 接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。

在网络包传输的过程中，**源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址**，因为需要 MAC 地址在以太网内进行**两个设备**之间的包传输。 

### 10、服务端与客户端-互相扒皮

1. 数据包抵达服务器后，服务器会先扒开数据包的 **MAC 头部**，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。 

2. 接着继续扒开数据包的 **IP 头**，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 **TCP 协议**。 

3. 于是，扒开 **TCP 的头**，里面有**序列号**，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。**TCP头部里面还有端口号**， **HTTP 的服务器正在监听这个端口号。** 

4. 于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 **HTTP 进程**。

   服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 **HTTP 响应报文**里。

5. **HTTP 响应报文**也需要**穿上 TCP、IP、MAC 头部**，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。 

6. 客户端同样的接收这个报文，获取数据。

7. 最后，客户端要离开了，向服务器发起了 **TCP 四次挥手**，至此双方的连接就断开了。 

### 11、其他网络问题

#### 1、如果发送的包不是本地局域网中的，怎样填写MAC地址？

如果目标主机不是本地局域网，**填入的MAC地址是路由器**，也就是把数据包转发给路由器，路由器一直转发下一个路由器。直到转发到目标主机的路由器，**发现 IP 地址是自己局域网内的主机**，就会 arp 请求获取目标主机的 MAC 地址，从而转发到这个服务器主机。 

转发的过程中，**源IP地址和目标IP地址是不会变**的（前提：没有使用 NAT 网络的），**源 MAC 地址和目标 MAC 地址是会变化**的。 

## 三、Linux网络

### 1、OSI网络模型

国际标准化组织制定了开放式系统互联通信参考模型（*Open System Interconnection Reference Model*），也就是 **OSI 网络模型**，该模型主要有 7 层，分别是**应用层、表示层、会话层、传输层、网络层、数据链路层以及物理层。** 

每一层负责的职能不同：

- 应用层：负责给应用程序提供统一的接口。
- 表示层：负责把数据转换成兼容另一个系统能识别的格式。
- 会话层：负责建立、管理和中止表示层实体之间的通信会话。
- 传输层：负责端到端的数据传输，
- 网络层：负责数据的路由、转发、分片。
- 数据链路层：负责数据的封帧和差错检测，以及MAC寻址。
- 物理层：负责在物理网络中传输数据帧。

### 2、TCP/IP模型

但是OSI模型太复杂，难以具体实现，**更常用的是TCP/IP网络模型：**

- 应用层：负责向用户提供一组应用程序，比如HTTP、DNS、FTP等。

- 传输层：负责**端到端**的通信，比如TCP、UDP。

- 网络层：负责**网络包的封装、分片、路由、转发**，比如IP、ICMP。

- 网络接口层：负责网络包**在物理网络中的传输**，比如网络包的封帧、MAC寻址，差错检测，以及网卡传输网络帧等。

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/OSI%E4%B8%8ETCP.png" alt="img" style="zoom: 50%;" /> 

### 3、Linux网络协议栈

#### 3.1、各层增加的部分

- 传输层：给应用数据前面增加了TCP头。

- 网络层：给TCP数据包增加了IP头。

- 网络接口层：给IP数据包前后分别增加了帧头和帧尾。

  <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png" alt="img" style="zoom:50%;" />

在增加了报头后，需要注意不能超过**最大传输单元MTU**的限制（是物理链路层的限制，以太网中是1500字节，也就规定了单次传输的最大 IP 包大小）如果超过了就会对报文进行切片。如果 MTU 越小，需要的分包就越多，那么网络吞吐能力就越差，相反的，如果 MTU 越大，需要的分包就越少，那么网络吞吐能力就越好。

#### 3.2、网络协议栈

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%8D%8F%E8%AE%AE%E6%A0%88.png" alt="img" style="zoom: 50%;" /> 

- 应用程序通过系统调用，和Socket层进行数据交互。
- Socket下是传输层，网络层，网络接口层。
- 最下面的一层是网卡驱动程序和硬件网卡设备。

#### 3.3、Linux网络技术

##### 3.3.1、DMA技术

网卡接受到一个网络包：通过DMA技术（Direct Memory Access，**DMA是直接存储器访问**的缩写。可以让**外设直接访问内存，数据传输交给DMA控制器完成，减少了CPU的负担**），将网络包写入到**Ring Buffer环形缓冲区**，告知操作系统这个网络包已经到达，告知方式就是NAPI机制。

##### 3.3.2、NAPI 机制

告知网络包到达的一种方式是触发中断。但是**频繁中断要求CPU处理每个传入的数据包，导致CPU使用率高**。

所以为了解决频繁中断带来的性能开销，Linux 内核在 2.6 版本中引入了 **NAPI 机制**，它是**混合「中断和轮询」**的方式来接收网络包，**不采用中断的方式读取数据**，而是首先**采用中断唤醒数据接收的服务程序，然后 `poll` 的方法来轮询数据。** 

NAPI能够**延迟处理**传入的数据包，使得驱动程序可以在单个中断处理多个数据包。

因此，当有网络包到达时，会通过 DMA 技术，将网络包写入到指定的内存地址，接着**网卡向 CPU 发起硬件中断**，当 CPU 收到硬件中断请求后，根据中断表，调用已经注册的中断处理函数。

##### 3.3.3、硬件中断处理函数

硬件中断处理函数会做如下的事情：

- 需要先**「暂时屏蔽中断」**，表示已经知道内存中有数据了，告诉网卡下次再收到数据包直接写内存就可以了，不要再通知 CPU 了，这样可以提高效率，**避免 CPU 不停的被中断**。
- 接着，发起**「软中断」**，然后**恢复刚才屏蔽的中断。**

至此，硬件中断处理函数的工作就已经完成。硬件中断处理函数做的事情很少，主要耗时的工作都交给软中断处理函数了。

##### 3.3.4、软中断的处理

内核中的 ksoftirqd 线程专门负责软中断的处理，当 ksoftirqd 内核线程收到软中断后，就会来**轮询处理数据**。

ksoftirqd 线程会从 **Ring Buffer 中获取一个数据帧**，用 sk_buff 表示，从而可以作为一个网络包交给网络协议栈进行逐层处理。

#### 3.4、Linux接收网络包

1. **网络接口层**：在这一层会**检查报文的合法性**，如果不合法则丢弃，合法则会找出该网络包的上层协议的类型，比如是 IPv4，还是 IPv6，接着再**去掉帧头和帧尾，然后交给网络层**。

2. **网络层**：则取出 IP 包，判断网络包下一步的走向，比如是**交给上层处理还是转发出去**。当确认这个网络包要发送给本机后，就会从 IP 头里看看上一层协议的类型是 TCP 还是 UDP，接着**去掉 IP 头，然后交给传输层**。

3. **传输层：**取出 TCP 头或 UDP 头，根据四元组「源 IP、源端口、目的 IP、目的端口」 作为标识，找出对应的 Socket，并把**数据放到 Socket 的接收缓冲区**。

4. **应用层：**程序调用 Socket 接口，**将内核的 Socket 接收缓冲区的数据「拷贝」到应用层的缓冲区**，然后唤醒用户进程。

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E6%94%B6%E5%8F%91%E6%B5%81%E7%A8%8B.png" alt="img" style="zoom:50%;" /> 

#### 3.5、Linux发送网络包

1. **应用层**：应用程序会**调用 Socket 发送数据包的接口**，由于这个是**系统调用**，所以会**从用户态陷入到内核态中的 Socket 层**，内核会申请一个内核态的 sk_buff 内存，**将用户待发送的数据拷贝到 sk_buff 内存，并将其加入到发送缓冲区**。 接下来，网络协议栈从 Socket 发送缓冲区中取出 sk_buff，并按照 TCP/IP 协议栈从上到下逐层处理。 

2. **传输层**：如果使用的是 TCP 传输协议发送数据，那么**先拷贝一个新的 sk_buff 副本** ，这是因为 sk_buff 后续在调用网络层，最后到达网卡发送完成的时候，这个 sk_buff 会被释放掉。而 TCP 协议是支持**丢失重传**的，在收到对方的 ACK 之前，这个 sk_buff 不能被删除。所以内核的做法就是每次调用网卡发送的时候，实际上传递出去的是 sk_buff 的一个拷贝，等收到 ACK 再真正删除。接着，**对 sk_buff 填充 TCP 头**。

   > 为什么每一层都用 sk_buff 这**同一个数据结构**？
   >
   > 在每一层传递时，都是用sk_buff这一个统一的结构体，避免了各层在增加和删去报头时的重复拷贝。
   >
   > 在各层之间切换sk_buff的使用时，是**通过调整 sk_buff 中 `data` 的指针**：
   >
   > - 当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb->data 的值，来逐步剥离协议首部。
   >
   > - 当要发送报文时，创建 sk_buff 结构体，数据缓存区的头部预留足够的空间，用来填充各层首部，在经过各下层协议时，通过减少 skb->data 的值来增加协议首部。 

3. **网络层**：**选取路由、填充IP头、对超过MTU大小的数据包进行分片**。 处理完这些工作后会交给网络接口层处理。

4. **网络接口层**：通过 ARP 协议获得下一跳的 MAC 地址，然后**对 sk_buff 填充帧头和帧尾**，接着将 sk_buff 放到**网卡的发送队列**中。  

5. 接下来会触发**「软中断」**告诉网卡驱动程序，这里有新的网络包需要发送，驱动程序会**从发送队列中读取 sk_buff**，将这个 sk_buff **挂到 RingBuffer 中**，接着**将 sk_buff 数据映射到网卡可访问的内存 DMA 区域**，最后触发真实的发送。 

6. 在发送完成后，网卡设备触发一个**硬中断**释放内存，**释放sk_buff内存和清理Ring Buffer内存**。

7. 最终，收到TCP报文的**ACK应答**后，传输层**释放原始的sk_buff**。

##### 3.5.1、发送网络数据时发生的内存拷贝

1. 第一次拷贝，调用发送数据的系统调用时，内核会申请一个内核态的sk_buff内存，将**用户待发送的数据拷贝到sk_buff内存**，并将其发送到缓冲区。
2. 第二次拷贝，在使用TCP传输协议时，从传输层进入网络层，每一个**sk_buff都会被克隆成一个新的副本**送往网络层。为了实现TCP的可靠传输，TCP的原始sk_buff还在保存。
3. 第三次拷贝，当**IP层发现sk_buff大于MTU**时才需要进行，会再**申请额外的sk_buff，并将原来的sk_buff拷贝为多个sk_buff。**