## 一、HTTP基本概念

### 1、HTTP

HTTP：HyperText Transfer Protocol，超文本传输协议。

**HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。** 

### 2、HTTP状态码

### <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/6-%E4%BA%94%E5%A4%A7%E7%B1%BBHTTP%E7%8A%B6%E6%80%81%E7%A0%81.png" alt=" 五大类 HTTP 状态码 " style="zoom:50%;" /> 

2.1、`1xx` 类状态码属于**提示信息**，是协议处理中的一种中间状态，实际用到的比较少。

2.2、`2xx` 类状态码表示服务器**成功**处理了客户端的请求，也是我们最愿意看到的状态。

- 「**200 OK**」是最常见的成功状态码，表示一切正常。如果是非 `HEAD` 请求，服务器返回的响应头都会有 body 数据。
- 「**204 No Content**」也是常见的成功状态码，与 200 OK 基本相同，但响应头没有 body 数据。
- 「**206 Partial Content**」是应用于 HTTP 分块下载或断点续传，表示响应返回的 body 数据并不是资源的全部，而是其中的一部分，也是服务器处理成功的状态。

2.3、`3xx` 类状态码表示客户端请求的资源发生了变动，需要**客户端用新的 URL 重新发送请求获取资源**，也就是**重定向**。

- 「**301 Moved Permanently**」表示永久重定向，说明请求的资源已经不存在了，需改用新的 URL 再次访问。
- 「**302 Found**」表示临时重定向，说明请求的资源还在，但暂时需要用另一个 URL 来访问。301 和 302 都会在响应头里使用字段 `Location`，指明后续要跳转的 URL，浏览器会自动重定向新的 URL。
- **「304 Not Modified**」不具有跳转的含义，表示资源未修改，重定向已存在的缓冲文件，也称**缓存重定向**，也就是告诉客户端可以继续使用缓存资源，用于缓存控制。

2.4、`4xx` 类状态码表示客户端发送的**报文有误**，服务器无法处理，也就是错误码的含义。

- 「**400 Bad Request**」表示客户端请求的报文有错误，但只是个笼统的错误。
- 「**403 Forbidden**」表示服务器禁止访问资源，并不是客户端的请求出错。
- 「**404 Not Found**」表示**请求的资源在服务器上不存在或未找到**，所以无法提供给客户端。

2.5、`5xx` 类状态码表示客户端请求报文正确，但是服务器处理时内部发生了错误，属于**服务器端的错误码**。

- 「**500 Internal Server Error**」与 400 类型，是个笼统通用的错误码，服务器发生了什么错误，我们并不知道。
- 「**501 Not Implemented**」表示客户端请求的功能还不支持，类似“即将开业，敬请期待”的意思。
- 「**502 Bad Gateway**」通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
- 「**503 Service Unavailable**」表示服务器当前很忙，暂时无法响应客户端，类似“网络服务正忙，请稍后重试”的意思。

### 3、HTTP常见字段

3.1、Host字段：用于在客户端发送请求时，**指定服务器的域名**，实现将请求发往同一台服务器上的不同网站。

Host：www.A.com

3.2、Content-Length字段：表明本次回应的数据长度。 **HTTP 协议通过设置回车符、换行符作为 HTTP header 的边界，通过 Content-Length 字段作为 HTTP body 的边界，这两个方式都是为了解决“粘包”的问题**（因为HTTP是基于TCP传输的，所以会有粘包问题）。 

3.3、Connection字段：Connection字段最常用于客户端要求服务器使用“**HTTP长连接**”机制，以便其他请求复用。

HTTP长连接指的是只要其中一方没有要求中断连接，便保持连接。

3.4、Content-Type字段：Content-Type字段用于服务器回应时，告诉客户端，本次数据是什么格式。

```text
Content-Type: text/html; charset=utf-8
```

上面的类型表明，发送的是网页，而且编码是UTF-8。 

客户端请求的时候，可以使用 `Accept` 字段声明自己可以接受哪些数据格式。 

3.5、Content-Encoding字段：Content-Encoding字段说明**数据的压缩方法**，表示服务器返回的数据使用了什么压缩格式。

```text
Content-Encoding: gzip
```

上面表示服务器返回的数据采用了 gzip 方式压缩，告知客户端需要用此方式解压。

客户端在请求时，用 `Accept-Encoding` 字段说明自己可以接受哪些压缩方法。

### 4、Get和Post

#### 4.1、GET和POST的区别

- **GET的语义是从服务器获取指定的资源**。**GET 方法是安全、幂等、可被缓存的。** GET 请求的参数位置一般是**写在 URL 中**，URL 规定只能支持 ASCII，所以 GET 请求的参数**只允许 ASCII 字符** ，而且浏览器会对 URL 的**长度有限制**（HTTP协议本身对 URL长度并没有做任何规定）。 
- **POST的语义是请求负荷（报文body）对指定的资源做出处理**。**POST 不安全，不幂等，（大部分实现）不可缓存**。  POST 请求携带数据的位置一般是**写在报文 body 中**， body 中的数据可以是**任意格式**的数据，只要客户端与服务端协商好即可，而且浏览器**不会对 body 大小做限制**。 

#### 4.2、安全和幂等

安全：在HTTP协议里，安全指的是请求方法不会破坏服务器的资源。

幂等：多次执行相同的操作，结果都是相同的。

**GET 方法就是安全且幂等的**，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，**可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存为书签**。

**POST** 因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是**不安全**的，且多次提交数据就会创建多个资源，所以**不是幂等**的。所以，**浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签**。

但是实际在使用中，可以用GET方法实现新增和删除，GET方法会变得不安全，不幂等。POST方法也可以用于查询，就是安全且幂等的。

## 二、HTTP缓存技术

对于一些重复的HTTP请求，如果每次得到的数据都是一样的，可以把“请求-响应”的数据缓存在本地。两种实现方式：

### 1、强制缓存

**强制缓存**：**只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在于浏览器这边。** 

强制缓存是利用下面这两个 HTTP 响应头部（Response Header）字段实现的：

利用Cache-Control表示相对时间；Expires表示绝对时间。这两者同时出现时，Cache-Control优先级高于Expires。

具体流程如下：

- 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，在 Response 头部加上 Cache-Control，Cache-Control 中设置了过期时间大小；
- 浏览器再次请求访问服务器中的该资源时，会先**通过请求资源的时间与 Cache-Control 中设置的过期时间大小，来计算出该资源是否过期**，如果没有，则使用该缓存，否则重新请求服务器；
- 服务器再次收到请求后，会再次更新 Response 头部的 Cache-Control。

### 2、**协商缓存**

**协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存**。某些请求的响应码是 `304`（缓存重定向），这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。协商缓存有两种实现方式：

2.1、可以通过请求头部中的 `If-Modified-Since` 字段与响应头部中的 `Last-Modified` 字段实现 。**是基于时间实现的 。**

  - 响应头部中的 `Last-Modified`：标示这个响应资源的最后修改时间；
  - 请求头部中的 `If-Modified-Since`：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 If-Modified-Since 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。

2.2、请求头部中的 `If-None-Match` 字段与响应头部中的 `ETag` 字段。 **是基于一个唯一标识实现的。**

  - 响应头部中 `Etag`：**唯一标识响应资源**；
  - 请求头部中的 `If-None-Match`：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。

2.3、带上了 ETag 和 Last-Modified 字段信息给服务端，**这时 Etag 的优先级更高**。因为ETag 主要能解决 Last-Modified 几个比较难以解决的问题：

1. 在**没有修改文件内容情况下文件的最后修改时间可能也会改变**，这会导致客户端认为这文件被改动了，从而重新请求；
2. 可能有些文件是在**秒级以内修改**的，`If-Modified-Since` 能检查到的粒度是秒级的，使用 Etag就能够保证这种需求下客户端在 1 秒内能刷新多次；
3. 有些服务器不能精确获取文件的最后修改时间。

### 3、强制缓存和协商缓存的工作流程

**只有在未能命中强制缓存的时候，才能发起带有协商缓存字段的请求**。  

当使用 ETag 字段实现的协商缓存的过程：

- 当浏览器第一次请求访问服务器资源时，服务器会在返回这个资源的同时，**在 Response 头部加上 ETag 唯一标识**，这个唯一标识的值是根据当前请求的资源生成的；

- 当浏览器再次请求访问服务器中的该资源时，首先会**先检查强制缓存是否过期**：

  - 如果没有过期，则直接使用本地缓存；
  - 如果缓存过期了，会在 Request 头部加上 If-None-Match 字段，该字段的值就是 **ETag 唯一标识**；

- 服务器再次收到请求后，会根**据请求中的 If-None-Match 值与当前请求的资源生成的唯一标识进行比较：**

  - **如果值相等，则返回 304 Not Modified，不会返回资源**；
  - 如果不相等，则**返回 200 状态码和返回资源**，并在 Response 头部加上**新的 ETag 唯一标识；**
  
- 如果浏览器收到 304 的请求响应状态码，则会从本地缓存中加载资源，否则更新资源。

## 三、HTTP特性

### 1、HTTP/1.1的优点

- **简单**

  HTTP 基本的报文格式就是 `header + body`，头部信息也是 `key-value` 简单文本的形式，**易于理解**，降低了学习和使用的门槛。 

- **灵活、易于扩展**

   HTTP 协议里的各类请求方法、URI/URL、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员**自定义和扩充**。 同时 HTTP 由于是工作在应用层（ `OSI` 第七层），则它**下层可以随意变化**，比如：

  - **HTTPS 就是在 HTTP 与 TCP 层之间增加了 SSL/TLS 安全传输层**；
  - HTTP/1.1 和 HTTP/2.0 传输协议使用的是 TCP 协议，而到了 HTTP/3.0 传输协议改用了 UDP 协议。
  
- **应用广泛，跨平台**


### 2、HTTP/1.1的缺点

- 无状态双刃剑：

  好处是服务器不会记忆HTTP的状态，减少了服务器负担。坏处是完成有关联性的操作都非常的麻烦。例如购物过程中每一环节都需要用户信息，询问次数会特别多，因此使用了**Cookie技术**来弥补。

  `Cookie` 通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。 

- 明文传输双刃剑：

  优点是传输的信息**方便阅读，便于调试**。缺点是带来了**安全问题**。

- 不安全：

  - 通信使用明文（不加密），**内容可能会被窃听**。比如，账号信息容易泄漏。
  - 不验证通信方的身份，因此有可能**遭遇伪装**。比如，访问假的淘宝、拼多多。
  - 无法证明报文的完整性，所以**有可能已遭篡改**。比如，网页上植入垃圾广告。
  
  **HTTP 的安全问题，可以用 HTTPS 的方式解决，也就是通过引入 SSL/TLS 层**，使得在安全上达到了极致。 

### 3、HTTP/1.1的性能

HTTP 协议是基于 **TCP/IP**，并且使用了「**请求 - 应答**」的通信模式，所以性能的关键就在这**两点**里。 

- **长连接**：

   HTTP/1.1提出了长连接的通信方式。 只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。减少了过多的TCP连接次数。

- **管道网络传输**：

  HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。

  即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以**减少整体的响应时间。**但是**服务器必须按照接收请求的顺序发送对这些管道化请求的响应**。

  如果服务端在处理 A 请求时耗时比较长，那么后续的请求的处理都会被阻塞住，这称为「队头堵塞」。所以，**HTTP/1.1 管道解决了请求的队头阻塞，但是没有解决响应的队头阻塞**。

- **响应的队头阻塞**：

   因为当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一同被阻塞了，会招致客户端一直请求不到数据，这也就是「**队头阻塞**」。


## 四、HTTP与HTTPS

### 1、HTTP和HTTPS的区别

- HTTP是**明文传输**。HTTPS在TCP和HTTP网络层之间加入了**SSL/TLS安全协议**，使得报文能够**加密传输**。
- HTTP只需要TCP三次握手，HTTPS在此基础上**还进行SSL/TLS握手过程**。
- HTTP**默认端口80**，HTTPS**默认端口是443**。
- HTTPS协议需要向CA（证书权威机构）**申请数字证书**，保证服务器的身份是可信的。

### 2、HTTP存在的风险

- **窃听风险**：通信链路可以获取通信内容。HTTPS通过**信息加密**解决。使用**混合加密**。
- **篡改风险**：强制植入垃圾信息。HTTPS通过**校验机制**解决。使用**摘要算法**。
- **冒充风险**：冒充假网站。HTTPS通过**身份证书**解决。将服务器公钥放入**数字证书**。HTTP**S** 在 HTTP 与 TCP 层之间加入了 `SSL/TLS` 协议，可以很好的解决了上述的风险。

### 3、HTTPS如何解决三个风险

#### 3.1、混合加密（保证消息的完整性）

##### 3.1.1、对称加密

**加密和解密使用相同的密钥**，在通信时还需将传输密钥给对方用来解密，密钥传输过程中同样可能被截获。

##### 3.1.2、非对称加密

使用**一对非对称的密钥**，一把叫做**公开密钥**，一把叫做**私有密钥**，其中公开密钥可以随意发送，私有密钥必须保密。发送密文的一方要使用对方的公开密钥进行加密，对方收到信息之后，使用自己的私有密钥进行解密，这种方式不需要传输用来解密的私钥了，也就不必担心私钥被截获。

- HTTPS 采用的是**对称加密**和**非对称加密**结合的「混合加密」方式： 
  - 在通信建立前采用**非对称加密**的方式交换「会话秘钥」，后续就不再使用非对称加密。
  - 在通信过程中全部使用**对称加密**的「会话秘钥」的方式加密明文数据。
- 采用「混合加密」的方式的原因：
  - **对称加密**只使用一个密钥，**运算速度快**，密钥必须保密，**无法做到安全的密钥交换**。
  - **非对称加密**使用两个密钥：公钥和私钥，公钥可以任意分发而私钥保密，解决了密钥交换问题但速度慢。

#### 3.2、摘要算法+数字签名（解决消息来源的可靠性）

- 在计算机里会**用摘要算法（哈希函数）来计算出内容的哈希值**，这个**哈希值是唯一的，且无法通过哈希值推导出内容**。

  但存在一个问题：只能保证消息准确，但不能保证消息来源：通过哈希算法可以确保内容不会被篡改，**但是并不能保证「内容 + 哈希值」不会被中间人替换，因为这里缺少对客户端收到的消息是否来源于服务端的证明**。 

- 用**非对称加密算法（私钥加密、公钥解密）**来解决，共有两个密钥：

  - 一个是公钥，这个是可以公开给所有人的；
  - 一个是私钥，这个必须由本人管理，不可泄露。

  这两个密钥可以**双向加解密**的，比如可以用公钥加密内容，然后用私钥解密，也可以用私钥加密内容，公钥解密内容。 流程的不同，意味着目的也不相同：

  - **公钥加密，私钥解密**。这个目的是为了**保证内容传输的安全**，因为被公钥加密的内容，其他人是无法解密的，只有持有私钥的人，才能解密出实际的内容；
  - **私钥加密，公钥解密**。这个目的是为了**保证消息不会被冒充**，因为私钥是不可泄露的，如果公钥能正常解密出私钥加密的内容，就能证明这个消息是来源于持有私钥身份的人发送的。

  **数字签名算法**就是通过私钥加密、公钥解密的方式，确认消息的身份。主要是对内容的哈希值加密。

#### 3.3、数字证书（防止地址伪造）

- 服务器必须把自己的公钥注册到**CA（数字证书认证机构）**。CA用自己的私钥将服务器的公钥数字签名，将**服务器的个人信息+公钥+数字签名打包成一个数字证书**。
- 客户端拿到服务器的数字证书之后，需要**使用CA的公钥进行确认服务器数字证书是否真实**。
- 最后，客户端在获取到服务器公钥后，使用它对报文进行加密后发送。

 <img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/HTTP/22-%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="数子证书工作流程" style="zoom:67%;" /> 

### 4、HTTPS是如何建立连接的

#### 4.1、SSL/TLS协议基本流程

- 客户端向服务端**索要并验证服务器的公钥**。
- 双方使用**非对称加密**协商生产”**会话密钥**“。
- 双方采用**”会话密钥“对称加密**进行加密通信。

前两步就是TLS握手阶段，涉及四次通信。常用的密钥交换算法有：RSA算法和ECDHE算法。

#### 4.2、基于 RSA 算法的TLS协议建立的详细流程

1. Client Hello请求： 由**客户端向服务器发起加密通信请求**。

   - 客户端向服务器发送客户端支持的TLS协议版本；

   - 客户端生产的随机数Client Random；

   - 客户端支持的密码套件列表（如RSA加密算法）。

2. SeverHello：**服务器收到客户端请求后，向客户端发出响应。**确认TLS协议版本，如果浏览器不支持，关闭加密通信。

   - 服务其生产的随机数Server Random；
   
   
      - 确认密码套件列表。
   
   
      - 服务器的数字证书。
   

3. 客户端回应。客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 **CA 公钥，确认服务器的数字证书的真实性。**

   如果证书没有问题，客户端会**从数字证书中取出服务器的公钥**，然后使用它加密报文，向服务器发送如下信息：

   - 一个随机数pre-master key，该随机数会被服务器公钥加密。

   - 加密通信算法改变通知，表示随后的信息都将用”会话密钥“加密通信。

   -  客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。 

   **服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」**。 

4. 服务器最后响应。服务器收到客户端的第三个随机数（`pre-master key`）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。然后，向客户端发送最后的信息：

   - 加密通信算法改变通知。随后的信息都将用”会话密钥“加密通信。

   - 服务器握手结束通知，表示服务器的握手阶段已经结束。

至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。 

#### 4.3、客户端校验数字证书的流程 - 私钥加密，公钥解密

##### 4.3.1、CA签发证书的过程

- 首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 **Hash 值**；
- 然后 CA 会使用自己的私钥将该 Hash 值加密，生成 Certificate Signature，也就是 **CA 对证书做了签名**；
- 最后将 **Certificate Signature 添加在文件证书上，形成数字证书**；

##### 4.3.2、客户端校验证书流程：

- 首先客户端会使用**同样的 Hash 算法**获取该证书的 Hash 值 H1；
- 通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以**使用 CA 的公钥解密** Certificate Signature 内容，得到一个 Hash 值 H2 ；
- 最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。

### 5、HTTPS保证数据完整性

TLS在实现上分为 **握手协议**和**记录协议**两层： 

- **TLS 握手协议**就是我们前面说的 TLS 四次握手的过程，负责**协商加密算法和生成对称密钥**，后续用此密钥来保护应用程序数据（即 HTTP 数据）；
- **TLS 记录协议**负责保护应用程序数据并验证其完整性和来源，所以对 HTTP 数据加密是使用记录协议；TLS 记录协议主要负责消息（HTTP 数据）的压缩，加密及数据的认证。

压缩过程：

- 首先，消息被分割成多个较短的片段,然后分别对每个片段进行压缩。

- 接下来，经过压缩的片段会加上**消息认证码（MAC 值**，这个是通过哈希算法生成的），这是为了**保证完整性，并进行数据的认证**。通过附加消息认证码的 MAC 值，可以**识别出篡改**。

  与此同时，为了**防止重放攻击**（攻击者发送一个目的主机已经接收过的包，因为是已经接收过的，片段，所以会直接通过认证，会破坏认证的正确性），在计算消息认证码时，还加上了片段的编码。

- 再接下来，经过压缩的片段再加上消息认证码会**一起通过对称密码进行加密**。

- 最后，上述经过加密的数据再加上由数据类型、版本号、压缩后的长度组成的报头就是最终的报文数据。

 记录协议完成后，最终的报文数据将传递到传输控制协议 (TCP) 层进行传输。

## 五、HTTP/1.1、HTTP/2、HTTP/3演变与优化

### 1、HTTP/1.1相比HTTP/1.0改进

- 使用**长连接**的方式改善了 HTTP/1.0 短连接造成的性能开销。
- 支持**管道**网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。解决了**请求的队头堵塞问题**，但是还有应答的队头阻塞问题。

### 2、HTTP/1.1的性能瓶颈

- **请求 / 响应头部（Header）未经压缩**就发送，首部信息越多延迟越大。只能压缩 `Body` 的部分；
- **首部冗余**：每次互相发送相同的首部造成的浪费较多；
- **应答的队头阻塞：**服务器是按请求的顺序响应的，如果服务器响应慢，会招致客户端一直请求不到数据。
- 没有请求优先级控制；
- 请求**只能从客户端开始**，服务器只能被动响应。

### 3、HTTP1.1的优化思路

#### 3.1、尽量避免发送 HTTP 请求

使用**缓存技术**。将具有重复性的HTTP请求，将“请求-响应”的数据缓存在本地，下次访问时直接读取本地的数据。

##### 3.1.1、缓存形成方式

-  客户端会把第一次请求以及响应的数据保存在本地磁盘上，其中将请求的 **URL 作为 key，而响应作为 value**，两者形成映射关系。 
-  这样当后续发起相同的请求时，就可以先在本地磁盘上**通过 key 查到对应的 value**，也就是响应，如果找到了，就直接从本地读取该响应。 

##### 3.1.2、缓存正确性保证

**强制缓存与协商缓存**，查看HTTP缓存技术中的内容。

#### 3.2、减少HTTP请求次数

##### 3.2.1、减少重定向请求

资源迁移后，客户端会收到服务端的重定向响应，这导致了多次发送HTTP请求。可以把重定向规则交给代理服务器，减少重定向的次数。

##### 3.2.2、合并请求

多个小文件的请求合并成一个大请求，传输的数据不变，但是减少了重复发送的HTTP头部。

- **CSS Image Sprites技术**：将网页上的多个小图标，合并成一个大图片来请求，之后再切割使用。
- **webpack打包工具**：将js、css等资源文件打包成大文件。
- **base64编码**：将图的二进制信息使用base64编码后，以URL形式跟随HTML文件一起发送。

这样做有一个缺点：如果一个小文件发生了变化，整个大文件也需要重新下载，网络消耗大。

##### 3.2.3、延迟发送请求

请求网页时，不必要直接获取全部资源，只获取用户看到的这部分。

#### 3.3、减少服务器的 HTTP 响应的数据大小

##### 3.3.1、无损压缩

使用**霍夫曼编码**压缩数据。根据字符出现频率进行统计，再构建对应的霍夫曼树，得到每个字符的霍夫曼编码，这样全部数据的码量就是最少的。

##### 3.3.2、有损压缩

- HTTP请求头部的Accept字段中的q质量因子，告诉服务器期望的图像质量。
- **WebP**格式压缩网页格式。
- 音视频由于每帧有时序关系，只需要在一个静态的关键帧，使用**增量数据**来表达后续的帧，这样便减少了很多数据，提高了网络传输的性能

### 4、HTTP/2的改进

**HTTP/2 协议是基于 HTTPS 的**，所以 HTTP/2 的安全性也是有保障的。 

#### 4.1、**头部压缩**

HTTP/2 会**压缩头**。如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你**消除重复的部分**。HTTP/2 头部的编码通过「静态表、动态表、Huffman 编码」共同完成的。

**`HPACK` 算法**：在客户端和服务器同时维护一张**头信息表**，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就**提高速度**了。

##### 4.1.1、静态表编码

HTTP/2 为高频出现在头部的字符串和字段建立了一张**静态表**，它是写入到 HTTP/2 框架里的，不会变化的。在统计大量的 HTTP 头部后，HTTP/2 根据出现频率将 ASCII 码编码为了 Huffman 编码表，可以在 RFC7541 文档找到这张**静态 Huffman 表**。

##### 4.1.2、动态表编码

在静态表范围内的头部字符串就要自行构建**动态表**，它的 Index 从 `62` 起步，会在编码解码的时候随时更新。

#### 4.2、二进制帧

HTTP/2将 HTTP/1 的文本格式改成二进制格式传输数据，极大提高了 HTTP 传输效率，而且二进制数据使用位运算能高效解析。头信息和数据体都是二进制，并且统称为**帧（frame）**：**头信息帧（Headers Frame）和数据帧（Data Frame）**。 

头信息帧中存放帧长度、流标识等。数据帧中存放使用**HPACK算法**压缩的头部和包体。

#### 4.3、并发传输

HTTP/2 引出了 **Stream** 概念，**多个 Stream 复用在一条 TCP 连接**。

##### 4.3.1、HTTP/2的数据格式

- **1 个 TCP 连接包含一个或者多个 Stream**，Stream 是 HTTP/2 并发的关键技术；
- **Stream 里可以包含 1 个或多个 Message**，Message 对应 HTTP/1 中的请求或响应，由 HTTP 头部和包体构成；
- **Message 里包含一条或者多个 Frame**，Frame 是 HTTP/2 最小单位，以二进制压缩格式存放 HTTP/1 中的内容（头部和包体）；

**不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ）**，因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息，而**同一 Stream 内部的帧必须是严格有序的**。

##### 4.3.2、Stream并发传输的优势

**当 HTTP/2 实现 100 个并发 Stream 时，只需要建立一次 TCP 连接，而 HTTP/1.1 需要建立 100 个 TCP 连接，每个 TCP 连接都要经过 TCP 握手、慢启动以及 TLS 握手过程，这些都是很耗时的。**

HTTP/2 还可以对每个 Stream 设置不同**优先级**，帧头中的「标志位」可以设置优先级，比如客户端访问 HTML/CSS 和图片资源时，希望服务器先传递 HTML/CSS，再传图片，那么就可以通过设置 Stream 的优先级来实现，以此提高用户体验。

#### 4.4、服务器主动推送资源

**服务器推送**：服务端不再是被动地响应，可以**主动**向客户端发送消息。

客户端和服务器**双方都可以建立 Stream**， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。

### 4、HTTP/2的缺陷

**队头阻塞问题**（解决了请求、应答的队头阻塞，但是发生在**TCP层面队头阻塞**）。

HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用。那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。 

所以，一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的**所有的 HTTP 请求都必须等待这个丢了的包被重传回来**。

### 5、HTTP/3的优化

解决了队头阻塞： **HTTP/3 把 HTTP 下层的 TCP 协议改成了 UDP**。  UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP/2 队头阻塞的问题。UDP 是不可靠传输的，但基于 UDP 的 **QUIC 协议 可以实现类似 TCP 的可靠性传输。 **

QUIC 有以下 3 个特点：

- **无队头阻塞**。 QUIC 协议也有类似 HTTP/2 Stream 与多路复用的概念，也是可以在同一条连接上并发传输多个 Stream，Stream 可以认为就是一条 HTTP 请求。 

  **当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题**。所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。 

- **更快的连接建立**。HTTP/3 在传输数据前虽然需要 **QUIC 协议握手**，这个握手过程只需要 **1 RTT**，握手的目的是为确认双方的「连接 ID」，连接迁移就是基于连接 ID 实现的。 

- **连接迁移**。基于 TCP 传输协议的 HTTP 协议，由于是通过四元组（源 IP、源端口、目的 IP、目的端口）确定一条 TCP 连接。

  那么**当移动设备的网络从 4G 切换到 WIFI 时，意味着 IP 地址变化了，那么就必须要断开连接，然后重新建立连接**。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。

  而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过**连接 ID**来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了**连接迁移**的功能。 

所以， QUIC 是一个在 UDP 之上的**伪** TCP + TLS + HTTP/2 的多路复用的协议。 QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP 包的，因此，HTTP/3现在仍未完全普及。

## 六、其他问题

### 1、HTTPS协议一定安全吗？

问题情景：客户端通过浏览器向服务端发起 HTTPS 请求时，被「假基站」转发到了一个「中间人服务器」，于是**客户端是和「中间人服务器」完成了 TLS 握手，然后这个「中间人服务器」再与真正的服务端完成 TLS 握手**。具体过程中：

- 客户端向服务端发起 HTTPS 建立连接请求时，然后被「假基站」转发到了一个「中间人服务器」，接着中间人向服务端发起 HTTPS 建立连接请求，此时**客户端与中间人进行 TLS 握手，中间人与服务端进行 TLS 握手**；
- 在客户端与中间人进行 TLS 握手过程中，**中间人会发送自己的公钥证书给客户端**，**客户端验证证书的真伪**，然后从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给中间人，中间人使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（A），后续客户端与中间人通信就用这个对称加密密钥来加密数据了。
- 在中间人与服务端进行 TLS 握手过程中，**服务端会发送从 CA 机构签发的公钥证书给中间人**，从证书拿到公钥，并生成一个随机数，用公钥加密随机数发送给服务端，服务端使用私钥解密，得到随机数，此时双方都有随机数，然后通过算法生成对称加密密钥（B），后续中间人与服务端通信就用这个对称加密密钥来加密数据了。
- 后续的通信过程中，中间人用对称加密密钥（A）解密客户端的 HTTPS 请求的数据，然后用对称加密密钥（B）加密 HTTPS 请求后，转发给服务端，接着服务端发送 HTTPS 响应数据给中间人，中间人用对称加密密钥（B）解密 HTTPS 响应数据，然后再用对称加密密钥（A）加密后，转发给客户端。

从客户端的角度看，其实**并不知道网络中存在中间人服务器这个角色**。那么中间人就可以解开浏览器发起的 HTTPS 请求里的数据，也可以解开服务端响应给浏览器的 HTTPS 响应数据。相当于，中间人能够 “偷看” 浏览器与服务端之间的 HTTPS 请求和响应的数据。

**但是要发生这种场景是有前提的，前提是用户点击接受了中间人服务器的证书。**中间人服务器与客户端在 TLS 握手过程中，实际上发送了自己**伪造的证书**给浏览器，而这个伪造的证书是能被浏览器（客户端）识别出是非法的，于是就会提醒用户该证书存在问题。

**这两个情况会有风险：**

1. 如果用户执意点击「继续浏览此网站」，相当于**用户接受了中间人伪造的证书**，那么后续整个 HTTPS 通信都能被中间人监听了。
2. 电脑中毒了，被**恶意导入了中间人的根证书**，那么在验证中间人的证书的时候，由于操作系统信任了中间人的根证书，那么等同于中间人的证书是合法的，这种情况下，浏览器是不会弹出证书存在问题的风险提醒的。

所以，**HTTPS 协议本身到目前为止还是没有任何漏洞的**，即使你成功进行中间人攻击，本质上是利用了客户端的漏洞（用户点击继续访问或者被恶意导入伪造的根证书），并不是 HTTPS 不够安全。

### 2、为什么抓包工具可以截取HTTPS数据

很多抓包工具 之所以可以明文看到 HTTPS 数据，工作原理与**中间人**一致的。对于 HTTPS 连接来说，中间人要满足以下两点，才能实现真正的明文代理：

1. 中间人，作为客户端与真实服务端建立连接这一步不会有问题，因为服务端不会校验客户端的身份；
2. 中间人，作为服务端与真实客户端建立连接，这里会有**客户端信任服务端的问题，也就是服务端必须有对应域名的私钥；**

中间人要拿到私钥只能通过如下方式：

1. 去网站服务端拿到私钥；
2. 去CA处拿域名签发私钥；
3. **自己签发证书，且要被浏览器信任；**抓包工具只能使用第三种方式取得中间人的身份。

使用抓包工具进行 HTTPS 抓包的时候，需要在客户端安装 Fiddler 的根证书，这里实际上起认证中心（CA）的作用。

抓包工具能够抓包的关键是**客户端会往系统受信任的根证书列表中导入抓包工具生成的证书**，而这个证书会被浏览器信任，也就是抓包工具给自己创建了一个认证中心 CA，客户端拿着中间人签发的证书去中间人自己的 CA 去认证，当然认为这个证书是有效的。

### 3、如何避免被中间人抓取数据

当然，我们还可以通过 **HTTPS 双向认证**来避免这种问题。一般我们的 HTTPS 是单向认证，客户端只会验证了服务端的身份，但是服务端并不会验证客户端的身份。如果用了双向认证方式，不仅**客户端会验证服务端的身份，而且服务端也会验证客户端的身份**。服务端一旦验证到请求自己的客户端为不可信任的，服务端就拒绝继续通信，客户端如果发现服务端为不可信任的，那么也中止通信。

### 4、TLS 和 SSL 实际上是一个东西，是一个东西不同阶段的不同名称。

### 5、https 和 http 相比，就是传输的内容多了对称加密，可以这么理解吗？

1. 建立连接时候：**https 比 http多了 TLS 的握手过程**；
2. 传输内容的时候：https 会把数据进行加密，通常是**对称加密**数据；

## 七、HTTPS握手

### 1、TLS握手

**通常经过「四个消息」就可以完成 TLS 握手，也就是需要 2个 RTT 的时延**，然后就可以在安全的通信环境里发送 HTTP 报文，实现 HTTPS 协议。HTTPS是应用层协议，需要先完成TCP连接，再进行TLS握手。不同的密钥交换算法，TLS 的握手过程可能会有一些区别。

### 2、RSA握手

RSA加密是一种非对称加密，可以**在不直接传递密钥的情况下，完成解密**。这能够确保信息的安全性，避免了直接传递密钥所造成的被破解的风险。命名来自于三个发明者名字缩写。

在 RSA 密钥协商算法中，客户端会生成随机密钥，并使用服务端的公钥加密后再传给服务端。根据非对称加密算法，公钥加密的消息仅能通过私钥解密，这样服务端解密后，双方就得到了相同的密钥，再用它加密应用消息。

#### 2.1、TLS第一次握手

客户端首先会发一个「**Client Hello**」消息，消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的**随机数（Client Random）**，这个随机数会被服务端保留，它是生成对称加密密钥的材料之一。

#### 2.2、TLS第二次握手

1. 当服务端收到客户端的「Client Hello」消息后，会确认 TLS 版本号是否支持，和从密码套件列表中选择一个密码套件，以及生成**随机数（Server Random）**。
2. 服务端返回「**Server Hello**」消息，消息里面有服务器确认的 TLS 版本号，也给出了随机数（Server Random），然后从客户端的密码套件列表选择了一个合适的密码套件。
3. 然后，服务端为了证明自己的身份，会发送「**Server Certificate**」给客户端，这个消息里含有数字证书。
4. 服务端发了「**Server Hello Done**」消息，发送完毕。

前面这两个客户端和服务端相互「打招呼」的过程，客户端和服务端就已确认了 **TLS 版本和使用的密码套件**，而且客户端和服务端都会各自生成一个随机数，并且还会把随机数传递给对方，这两个随机数是后续生成**会话密钥**的条件。

#### 2.3、客户端验证证书

CA 签发证书的过程：

1. 首先 CA 会把持有者的公钥、用途、颁发者、有效时间等信息打成一个包，然后对这些信息进行 Hash 计算，得到一个 Hash 值；
2. 然后 CA 会使用自己的私钥将该 Hash 值加密，生成数字签名；
3. 最后将 Certificate Signature 添加在文件证书上，形成数字证书；

客户端校验服务端的数字证书的过程：

1. 首先客户端会使用同样的 Hash 算法获取该证书的 Hash 值 H1；
2. 通常浏览器和操作系统中集成了 CA 的公钥信息，浏览器收到证书后可以使用 CA 的公钥解密 Certificate Signature 内容，得到一个 Hash 值 H2 ；
3. 最后比较 H1 和 H2，如果值相同，则为可信赖的证书，否则则认为证书不可信。

**证书信任链：**向 CA 申请的证书一般不是根证书签发的，而是中间证书签发的，如果追溯到最后的根证书在系统的信任列表中，就可以信任这个链条上的证书。

> 为什么不全部由Root CA签发？
>
> 是为了确保根证书的绝对安全性，将根证书隔离地越严格越好，不然根证书如果失守了，那么整个信任链都会有问题。

#### 2.4、TLS第三次握手

客户端验证完证书后，认为可信则继续往下走。

1. 客户端就会生成一个新的**随机数 (pre-master)**，用服务器的 RSA 公钥加密该随机数，通过「**Client Key Exchange**」消息传给服务端。
2. 服务端收到后，用 RSA 私钥解密，得到客户端发来的随机数 (pre-master)。
3. 至此，**客户端和服务端双方都共享了三个随机数，分别是 Client Random、Server Random、pre-master**。于是，双方根据已经得到的三个随机数，生成**会话密钥（Master Secret）**，它是对称密钥，用于对后续的 HTTP 请求/响应的数据加解密。
4. 生成完「会话密钥」后，然后客户端发一个「**Change Cipher Spec**」，告诉服务端开始使用加密方式发送消息。「**Change Cipher Spec**」之前的都是明文传输，之后都是密钥加密的密文。
5. 然后，客户端再发一个「**Encrypted Handshake Message（Finishd）**」消息，把之前所有发送的数据做个**摘要**，再用会话密钥（master secret）加密一下，让服务器做个验证，验证加密通信「是否可用」和「之前握手信息是否有被中途篡改过」。

#### 2.5、TLS第四次握手

服务器也是同样的操作，发「**Change Cipher Spec**」和「**Encrypted Handshake Message**」消息，如果双方都验证加密和解密没问题，那么握手正式完成，就可以用会话密钥加解密HTTP请求和响应。

#### 2.6、RSA算法的缺陷

**使用 RSA 密钥协商算法的最大问题是不支持前向保密**。

因为客户端传递随机数（用于生成对称加密密钥的条件之一）给服务端时使用的是公钥加密的，服务端收到后，会用私钥解密得到随机数。所以一旦服务端的私钥泄漏了，过去被第三方截获的所有 TLS 通讯密文都会被破解。

为了解决这个问题，后面就出现了 ECDHE 密钥协商算法，我们现在大多数网站使用的正是 ECDHE 密钥协商算法。

### 3、ECDHE 握手

#### 3.1、DH算法

<img src="https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%A6%BB%E6%95%A3%E5%AF%B9%E6%95%B0.png" alt="img" style="zoom: 67%;" />

底数 a 和模数 p 是离散对数的公共参数，也就说是公开的，b 是真数，i 是对数。知道了对数，就可以用上面的公式计算出真数。但反过来，知道真数却很难推算出对数。

**特别是当模数 p 是一个很大的质数，即使知道底数 a 和真数 b ，在现有的计算机的计算水平是几乎无法算出离散对数的，这就是 DH 算法的数学基础。**

##### 3.1.1、DH算法交换密钥

模数P和底数G是公开参数。然后小红和小明各自生成一个随机整数作为**私钥**，双方的私钥要各自严格保管，不能泄漏，小红的私钥用 a 代称，小明的私钥用 b 代称。

1. **私钥：**

   小红的私钥用 a 代称，小明的私钥用 b 代称。私钥是随机生成的，各自严格保密。

   私钥在计算中充当**指数**。

2. **公钥**：

   小红的公钥记作 A，A = G ^ a ( mod P )；

   小明的公钥记作 B，B = G ^ b ( mod P )；

3. 根据离散对数的原理，从公钥A反向算出私钥的指数是非常困难的。

   双方交换各自 DH 公钥后，小红手上共有 5 个数：P、G、a、A、B，小明手上也同样共有 5 个数：P、G、b、B、A。

   然后小红执行运算： B ^ a ( mod P )，其结果为 K，因为离散对数的幂运算有交换律，所以小明执行运算： A ^ b ( mod P )，得到的结果也是 K。这个 K 就是小红和小明之间用的**对称加密密钥**，可以作为会话密钥使用。

#### 3.2、DHE算法

##### 3.2.1、static DH 算法

static DH 算法里有一方的私钥是静态的，也就说每次密钥协商的时候有一方的私钥都是一样的，一般是服务器方固定，即 a 不变，客户端的私钥则是随机生成的。**static DH 算法不具备前向安全性**，时间长了就会被暴力破解私钥。

##### 3.2.2、DHE算法

让双方的私钥在每次密钥交换通信时，都是随机生成的、临时的，这个方式也就是 DHE 算法，E 全称是 ephemeral（临时性的）。**每个通信过程的私钥都是没有任何关系的，都是独立的，这样就保证了「前向安全」**。

#### 3.3、ECDHE 算法

DHE 算法由于计算性能不佳，因为需要做大量的乘法，为了提升 DHE 算法的性能，所以就出现了现在广泛用于密钥交换算法 —— **ECDHE 算法**。在 DHE 算法的基础上利用了 ECC 椭圆曲线特性，可以用更少的计算量计算出公钥，以及最终的会话密钥。

 ECDHE 密钥交换算法的过程：

- 双方事先确定好使用哪种椭圆曲线，和曲线上的基点 G，这两个参数都是公开的；
- 双方各自随机生成一个随机数作为**私钥d**，并与基点 G相乘得到**公钥Q**（Q = dG），此时小红的公私钥为 Q1 和 d1，小明的公私钥为 Q2 和 d2；
- 双方交换各自的公钥，最后小红计算点（x1，y1） = d1Q2，小明计算点（x2，y2） = d2Q1，由于椭圆曲线上是可以满足乘法交换和结合律，所以 d1Q2 = d1d2G = d2d1G = d2Q1 ，因此**双方的 x 坐标是一样的，所以它是共享密钥，也就是会话密钥**。

这个过程中，双方的私钥都是随机、临时生成的，都是不公开的，即使根据公开的信息（椭圆曲线、公钥、基点 G）也是很难计算出椭圆曲线上的离散对数（私钥）。

#### 3.4、ECDHE握手过程

**使用了 ECDHE，在 TLS 第四次握手前，客户端就已经发送了加密的 HTTP 数据**，而对于 RSA 握手过程，必须要完成 TLS 四次握手，才能传输应用数据。

所以，**ECDHE 相比 RSA 握手过程省去了一个消息往返的时间**，这个有点「抢跑」的意思，它被称为是「*TLS False Start*」，跟「*TCP Fast Open*」有点像，都是在还没连接完全建立前，就发送了应用数据，这样便提高了传输的效率。

##### 3.4.1、TLS 第一次握手

和RSA算法一样，客户端首先会发一个「**Client Hello**」消息，消息里面有客户端使用的 TLS 版本号、支持的密码套件列表，以及生成的**随机数（Client Random）**。

##### 3.4.2、TLS 第二次握手

1. 服务端收到客户端的「打招呼」会返回「**Server Hello**」消息，消息面有服务器确认的 TLS 版本号，也给出了一个**随机数（Server Random）**，然后从客户端的密码套件列表选择了一个合适的密码套件。
2. 服务端为了证明自己的身份，发送「**Certificate**」消息，会把证书也发给客户端。
3. 这里和RSA区别很大，会在发送完证书后，发送「**Server Key Exchange**」消息。
   - 选择了**名为 x25519 的椭圆曲线**，选好了椭圆曲线相当于椭圆曲线基点 G 也定好了，这些都会公开给客户端；
   - 生成随机数作为服务端椭圆曲线的私钥，保留到本地；
   - 根据基点 G 和私钥计算出**服务端的椭圆曲线公钥**，这个会公开给客户端。
4. 随后，就是「**Server Hello Done**」消息，服务端跟客户端表明此次握手完毕。

至此，TLS 两次握手就已经完成了，目前客户端和服务端通过明文共享了这几个信息：**Client Random、Server Random 、使用的椭圆曲线、椭圆曲线基点 G、服务端椭圆曲线的公钥**，这几个信息很重要，是后续生成会话密钥的材料。

##### 3.4.3、TLS 第三次握手

客户端验证服务端证书合法后：

1. 客户端会生成一个随机数作为客户端椭圆曲线的私钥，然后再根据服务端前面给的信息，生成**客户端的椭圆曲线公钥**，然后用「**Client Key Exchange**」消息发给服务端。
2. 至此，双方都有对方的椭圆曲线公钥、自己的椭圆曲线私钥、椭圆曲线基点 G。于是，双方都就计算出点（x，y），其中 x 坐标值双方都是一样的，前面说 ECDHE 算法时候，说 x 是会话密钥，**但实际应用中，x 还不是最终的会话密钥**。
3. **最终的会话密钥，就是用「客户端随机数 + 服务端随机数 + x（ECDHE 算法算出的共享密钥） 」三个材料生成的**。
4. 客户端会发一个「**Change Cipher Spec**」消息，告诉服务端后续改用对称算法加密通信。
5. 客户端会发「**Encrypted Handshake Message**」消息，把之前发送的数据做一个摘要，再用对称密钥加密一下，让服务端做个验证，验证下本次生成的对称密钥是否可以正常使用。

##### 3.4.4、TLS 第四次握手

最后，服务端也会有一个同样的操作，发「**Change Cipher Spec**」和「**Encrypted Handshake Message**」消息，如果双方都验证加密和解密没问题，那么握手正式完成。于是，就可以正常收发加密的 HTTP 请求和响应了。

### 4、RSA 和 ECDHE 握手过程的区别

- RSA 密钥协商算法「不支持」前向保密，ECDHE 密钥协商算法**「支持」前向保密**；
- 使用了 RSA 密钥协商算法，TLS 完成四次握手后，才能进行应用数据传输，而对于 ECDHE 算法，客户端可以不用等服务端的最后一次 TLS 握手，就可以提前发出加密的 HTTP 数据，**节省了一个消息的往返时间**；
- 使用 ECDHE， 在 **TLS 第 2 次握手中，会出现服务器端发出的「Server Key Exchange」消息**，而 RSA 握手过程没有该消息。

## 八、远程过程调用RPC

### 1、RPC的功能

可以直接调用远程服务器的方法。

### 2、有了RPC，为什么还要HTTP

多年以前，**HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合。**

### 3、HTTP 和 RPC 有什么区别

#### 3.1、传输内容序列化

传输内容中，要将内容转化为01串。字符串和数字都可以直接转换，但是结构体需要特别转换。将结构体转为二进制数组的过程就叫**序列化**，反过来将二进制数组复原成结构体的过程叫**反序列化**。

- HTTP中使用json序列化结构体。缺点是非常冗余。
- RPC的定制化程度更高，可以采用体积更小的Protobuf或其他序列化协议。也不需要像 HTTP 那样考虑各种浏览器行为，比如 302 重定向跳转啥的。**因此性能也会更好一些，这也是在公司内部微服务中抛弃 HTTP，选择使用 RPC 的最主要原因。**

HTTP，其实**特指的是现在主流使用的 HTTP/1.1**，`HTTP/2` 在前者的基础上做了很多改进，所以**性能可能比很多 RPC 协议还要好**，甚至连 `gRPC` 底层都直接用的 `HTTP/2`。

由于历史原因，现在还保留着RPC协议的使用。

### 4、总结

- 纯裸 TCP 是能收发数据，但它是个**无边界**的数据流，上层需要定义**消息格式**用于定义**消息边界**。于是就有了各种协议，HTTP 和各类 RPC 协议就是在 TCP 之上定义的应用层协议。
- **RPC 本质上不算是协议，而是一种调用方式**，而像 gRPC 和 Thrift 这样的具体实现，才是协议，它们是实现了 RPC 调用的协议。目的是希望程序员能像调用本地方法那样去调用远端的服务方法。同时 RPC 有很多种实现方式，**不一定非得基于 TCP 协议**。
- 从发展历史来说，**HTTP 主要用于 B/S 架构，而 RPC 更多用于 C/S 架构。但现在其实已经没分那么清了，B/S 和 C/S 在慢慢融合**。很多软件同时支持多端，所以对外一般用 HTTP 协议，而内部集群的微服务之间则采用 RPC 协议进行通讯。
- RPC 其实比 HTTP 出现的要早，且比目前主流的 HTTP/1.1 **性能**要更好，所以大部分公司内部都还在使用 RPC。
- **HTTP/2.0** 在 **HTTP/1.1** 的基础上做了优化，性能可能比很多 RPC 协议都要好，但由于是这几年才出来的，所以也不太可能取代掉 RPC。

## 九、WebSocket

### 1、建立WebSocket协议

在 **TCP 三次握手**建立连接之后，都**统一使用 HTTP 协议**先进行一次通信。

1. 如果此时是**普通的 HTTP 请求**，那后续双方就还是老样子继续用普通 HTTP 协议进行交互，这点没啥疑问。
2. 如果这时候是**想建立 WebSocket 连接**，就会在 HTTP 请求里带上一些**特殊的header 头**，浏览器想**升级协议（Connection: Upgrade）**，并且**想升级成 WebSocket 协议（Upgrade: WebSocket）**。同时带上一段**随机生成的 base64 码（Sec-WebSocket-Key）**，发给服务器。
3. 如果服务器正好支持升级成 WebSocket 协议。就会走 WebSocket 握手流程，同时根据客户端生成的 base64 码，用某个**公开的**算法变成另一段字符串，放在 HTTP 响应的 `Sec-WebSocket-Accept` 头里，同时带上`101状态码`，发回给浏览器。
4. 之后，浏览器也用同样的**公开算法**将`base64码`转成另一段字符串，如果这段字符串跟服务器传回来的**字符串一致**，那验证通过。

### 2、WebSocket的使用场景

WebSocket完美继承了 TCP 协议的**全双工**能力，并且还提供了解决粘包的方案。它适用于**需要服务器和客户端（浏览器）频繁交互**的大部分场景，比如网页/小程序游戏，网页聊天室，以及一些类似飞书这样的网页协同办公软件。

### 3、服务器推送

如何**在用户不做任何操作的情况下，网页能收到消息并发生变更。**

#### 3.1、HTTP定时轮询

**网页的前端代码里不断定时发 HTTP 请求到服务器，服务器收到请求后给客户端响应消息。**常用于扫码登录等场景，会有一些卡顿。

#### 3.2、长轮询

如果我们的 HTTP 请求**将超时设置的很大**，比如 30 秒，**在这 30 秒内只要服务器收到了扫码请求，就立马返回给客户端网页。如果超时，那就立马发起下一次请求。**

这样就减少了 HTTP 请求的个数，并且由于大部分情况下，用户都会在某个 30 秒的区间内做扫码操作，所以响应也是及时的。

### 4、总结

- TCP 协议本身是**全双工**的，但我们最常用的 HTTP/1.1，虽然是基于 TCP 的协议，但它是**半双工**的，对于大部分需要服务器主动推送数据到客户端的场景，都不太友好，因此我们需要使用支持全双工的 WebSocket 协议。
- 在 HTTP/1.1 里，只要客户端不问，服务端就不答。基于这样的特点，对于登录页面这样的简单场景，可以使用**定时轮询或者长轮询**的方式实现**服务器推送**(comet)的效果。
- 对于客户端和服务端之间需要频繁交互的复杂场景，比如网页游戏，都可以考虑使用 WebSocket 协议。
- WebSocket 和 socket 几乎没有任何关系，只是叫法相似。
- 正因为各个浏览器都支持 HTTP协 议，所以 WebSocket 会先利用HTTP协议加上一些特殊的 header 头进行握手升级操作，升级成功后就跟 HTTP 没有任何关系了，之后就用 WebSocket 的数据格式进行收发数据。
