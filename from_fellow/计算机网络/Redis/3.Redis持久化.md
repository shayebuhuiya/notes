## 一、Redis持久化

### 1、AOF日志（Append Only File）

每执行完一条写操作，就把该命令追加写到一个文件里，重启后，读取该文件，一条条执行命令，完成数据恢复。

#### 1.1、写日志方式：先执行命令，再把数据写入日志

- **避免额外的检查开销**。可以保证记录下来的语句都是**语法正确**的，而不必在恢复时再逐条检查。
- **不会阻塞当前写操作命令的执行。**当前写操作执行完之后，才去记录命令到AOF日志。

#### 1.2、后写入日志的风险

- **数据可能丢失。**Redis还没来得及将命令写入硬盘，服务器宕机，这个数据可能就会丢失。
- **可能阻塞其他操作**。写AOF日志会在主线程中执行，虽然后写日志不阻塞写操作，但是影响了后续的其他操作，如果写日志时磁盘I/O压力很大，就会导致写硬盘的速度很慢。

#### 1.3、AOF写回策略

Redis执行完写操作后，会将命令追加到缓冲区，之后再通过write系统调用写入AOF文件。共有三种不同的写入时机：

- Always，每次写操作都会把AOF日志写回磁盘。
- Everysec，每间隔一秒将缓冲区内日式刷盘。
- No，不由Redis控制刷盘，而是让操作系统决定刷盘时机。

这三种写回策略都不能完美解决主进程阻塞、减少数据丢失的问题，Always高可靠，No高性能，根据实际需要选择。

#### 1.4、AOF重写机制 - 解决AOF文件过大问题

写操作越来越多，AOF日志就会越来越大，Redis提供了**AOF重写机制**，大小超过阈值之后，Redis会压缩AOF文件。

AOF重写机制：重写时读取当前数据库的所有键值对，将每一个键值对用一条命令记录到新的AOF文件，用体积更小的新AOF文件覆盖原有文件。本质上就是将对某个键值反复修改的记录整合成只保留最后一次修改的结果。

> 举例：set name xiaolin、set name xiaolincoding这两条被先后执行的语句，就会被记录成一条：set name xiaolincoding，达到压缩的效果。
>

##### 1.4.1、AOF后台重写

Redis重写由后台子进程bgrewriteaof来完成。避免阻塞主进程的正常工作。这里**使用的是子进程，而不是子线程**，因为子进程有主进程的数据副本，避免了共享内存导致的**数据安全**问题，避免加锁。

主进程在通过fork系统调用生成子进程时，操作系统会把主进程的**页表**复制一份给子进程，页表中记录虚拟地址和物理地址的对应关系。两者的虚拟空间不同，对应的物理空间是一样的，这样**子进程就共享了父进程的物理内存数据**，可以**节约物理内存资源**。

##### 1.4.2、写时复制COW（copy on write） - 复制部分物理内存

**在发生写操作的时候，操作系统才会去复制物理内存**，就是**写时复制**机制，这样是为了防止 fork 创建子进程时，由于物理内存数据的复制时间过长而导致父进程长时间阻塞的问题，复制页表比复制物理内存快得多。

只有主进程修改了已经存在的key-value，才会发生写时复制，将这部分物理内存赋值给子进程。没修改的部分还是通过页表与子进程共享。

##### 1.4.3、AOF缓冲区 - 解决重写期间新发生的写操作

重写时的新操作会导致子进程、主进程的数据不一致，重写完成后的新AOF日志会丢失重写期间的写操作。

**解决方法**：新开辟一个AOF重写缓冲区，**重写期间的写操作同时写入AOF缓冲区、AOF重写缓冲区**，这样重写期间的写操作也能被正确记录。

### 2、RDB快照

#### 2.1、RDB快照实现方式

Redis有两种命令实现RDB快照。

- save命令，在主线程生成RDB文件，会阻塞主线程。
- bgsave命令，创建一个子进程生成RDB文件，避免主线程阻塞。

Redis的快照是全量快照，记录的量很大，对性能有影响。

#### 2.2、执行快照时，数据能修改吗

可以通过**写时复制技术COW**（copy on write）在快照时修改数据。

执行bgsave命令时，通过fork()创建子进程，子进程拷贝了父进程的页表，指向了同一块内存。**父进程修改了的数据，将这部分物理内存拷贝给子进程**，其他部分都通过页表共享，极端情况下，所有的共享内存都会被修改，内存占用是原先2倍。

### 3、为什么会有混合持久化

- AOF优点是丢失的数据少，但是恢复效率低。

- RDB优点是数据恢复快，但是快照频率不好把握，频率过低，丢失数据多，频率过高，因为做全量日志，影响性能。


混合持久化工作在**AOF日志重写**过程：重写时**子进程的数据副本这部分使用RDB快照记录**，这之后**新增的写操作，使用AOF日志记录**下来。

**优点：**前半部分是RDB快照，可以快速恢复，**后面数据是新增的数据，更容易发生丢失**，采用AOF日志尽可能完善保存。

**缺点：**AOF文件中混入了RDB格式的内容，可读性变差，并且只有Redis 6.0可以使用。

### 4、Redis大Key对持久化的影响

#### 4.1、对AOF日志的影响

AOF有Always、Everysec、No三种写策略。

- Always策略总会写回磁盘，大Key写回时，执行fsync()函数，可能会因为磁盘性能而阻塞。
- Everysec函数是异步执行fsync函数，大Key持久化不会影响主线程。

#### 4.2、对AOF重写和RDB的影响

AOF重写、RDB快照的bgsave命令，都会**通过fork()创建子进程**来完成。有两个阶段会阻塞父进程：

- 创建子进程时，如果页表太大，就会导致复制过程很耗时。
- 创建子进程后的修改，父进程修改的key-value就会进行**写时复制**，真的拷贝物理内存给子进程，此时大Key复制代价就比较大，导致父进程阻塞。

