## 一、Redis功能

### 1、过期删除策略

#### 1.1、Redis过期删除策略

Redis可以**对key设置过期时间**，需要有相应的机制将已过期的键值对删除，每当对一个key设置了过期时间时，Redis会把该key带上过期时间存储到一个**过期字典**中。

> 过期字典的数据结构：
>
> ```c
> typedef struct redisDb {
>     dict *dict;    /* 数据库键空间，存放着所有的键值对 */
>     dict *expires; /* 键的过期时间 */
>     ....
> } redisDb;
> ```
>
> 过期字典的key是一个指针，指向某个键对象；过期字典的value是一个long long类型的整数，保存了key的过期时间。
>
> 过期字典的底层结构是哈希表实现的，便于查找。

查询一个key时，Redis**检查这个key是否存在在过期字典**中，如果不在就正常读取键值，如果存在，就获取该key的过期时间，判断是否过期。

常用的过期删除策略有：**定时删除、惰性删除、定期删除**三种，Redis使用的是**惰性删除+定期删除**两种策略。

#### 1.2、定时删除

设置key的过期时间时，同时创建一个定时事件，时间到达时，自动执行key的删除操作。

**优点：**保证过期key尽快被释放，对内存友好。

**缺点：**key较多的情况下，删除key占用太多CPU时间，对CPU不友好。

#### 1.3、惰性删除

**不主动删除过期键**，每次从数据库访问key时，都检测key是否过期，如果过期就删除key。

**优点：**每次访问时，才检查key是否过期，少了检查的代价，对**CPU时间友好**。

**缺点：**没被访问到却过期的key保留在数据库中，造成了**内存浪费**。

#### 1.3、定期删除

每隔一段时间，**随机**从数据库中取出一些key检查，删除过期key，重复取出直到这次取出结果中过期比例不超过1/4。Redis默认每10秒抽取20个key检查。

**优点：**能**有计划**的按规定频率删除，**减少CPU的时间代价**。

**缺点：难以确定操作的执行频率**，执行太频繁对CPU不友好，执行太少又变成了惰性删除。

综上，Redis采用惰性删除+定期删除相结合的方式，在合理使用CPU和内存之间取得平衡。

#### 1.4、持久化过程中对过期键的处理

##### 1.4.1、RDB快照

- RDB**文件生成阶段**：**会进行过期检查**，过期key不会保存在RDB文件。
- RDB**加载**：**主服务器**会在载入RDB时**进行过期检查**。从服务器不进行类型检查，但是在主从服务器同步数据时，从服务器数据会被清空，实际上不构成影响。

##### 1.4.2、AOF文件

- **AOF写入：AOF文件保留过期键**，过期键被删除后，Redis会向AOF文件**追加一条DEL命令**表明过期键被删除了。
- **AOF重写**：进行**过期检查**，过期的键不会重写到新文件中。

#### 1.5、主从模式中，对过期键如何处理？

Redis运行在主从模式下时，**从库不会进行过期扫描，从库对过期的处理是被动的**。即使从库的key过期了，也能得到key对应的值。

从库过期key的处理依赖于主服务器。主库在key到期时，会**在AOF文件里增加一条DEL指令，同步到所有的从库**。从库通过AOF里记录的这条DEL指令删除过期的key。

### 2、Redis内存淘汰

Redis运行内存达到设置的最大运行内存，就会触发**内存淘汰机制**。

#### 2.1、Redis内存淘汰策略

##### 2.1.1、不进行内存淘汰

noeviction-运行内存超过最大设置内存时，不淘汰任何数据，而是**直接返回错误，触发OOM，此时只能查询和删除**。

##### 2.1.2、进行内存淘汰

设置了过期时间的数据中进行淘汰：

- volatile-random：随机淘汰设置了过期时间的任意键值。
- volatile-ttl：优先淘汰更早过期的键值。
- volatile-lru：最近最久未使用淘汰。
- volatile-lfu：最近最少使用淘汰。

在所有数据范围淘汰：

- allkeys-random：随机淘汰任意键值。
- allkeys-lru：淘汰整个键值中最久未使用的键值。
- allkeys-lfu：淘汰整个键值中最少使用的键值。

#### 2.2、LRU和LFU

LRU是最近最少使用，会淘汰最近最少使用的数据。传统的LRU基于链表结构实现。但是**Redis没有使用链表**，因为：链表管理所有的缓存数据，会带来额外的空间开销，有数据访问时，还会带来大量数据移动。

##### 2.2.1、Redis的近似LRU算法

在Redis的对象结构中添加一个字段，记录最后一次访问时间。Redis内存淘汰时，采用**随机采样**的方式淘汰，随机取5个，淘汰最久没有使用的一个。

**优点：**节省了维持链表的空间，也不用每次都移动链表。

**缺点：无法解决缓存污染问题**，某个应用一次读取大量数据，原本的热数据会被删掉。

##### 2.2.2、LFU算法

LFU是**最近最不常使用**的，按照**使用频率（注意不是次数）**淘汰数据，认为如果数据过去被访问多次，将来被访问的频率也更高。

Redis通过在对象结构中记录数据的访问频次的信息。

```c
typedef struct redisObject {
    ...
    // 24 bits，用于记录对象的访问信息
    unsigned lru:24;  
    ...
} robj;
```

**LRU**方式在lru字段记录最后一次使用的**时间戳**，**LFU**记录**访问频次**。LFU策略将lru字段拆分成两部分：访问时间戳 + 访问key的频次logc。logc越低，越容易被淘汰。

每次key被访问时，对logc进行衰减，距离上次访问越久，衰减越。之后再对logc进行增长，访问概率越大，增长越多。这样就实现了按照**访问频次**淘汰数据，而不是简单的访问次数。
