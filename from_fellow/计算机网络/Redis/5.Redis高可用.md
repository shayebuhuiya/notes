## 一、Redis高可用

### 1、如何实现Redis服务高可用？

Redis的持久化保证了服务器宕机重启时，数据尽可能不丢失。但是如果只有单点服务器，宕机后可能因为数据无法恢复、硬盘损坏等导致无法恢复。

保证Redis服务高可用，就要从Redis多服务节点考虑：Redis的主从复制、哨兵模式、切片集群。

### 2、主从复制

主从复制是Redis高可用服务的基本保证。将从前的一台Redis服务器，**同步数据到多台Redis服务器**，采用一主多从的模式，主从服务器采用**读写分离**的方式。

- 主服务器可以进行读写操作，发生写操作时，同步给从服务器。
- 从服务器一般是只读，并接受主服务器同步来的写操作，并执行这条命令。

这样保证所有数据修改只在主服务器上进行，将最新数据同步给从服务器，保证主从一致。但是主从服务器的命令复制是**异步进行**的，这导致主服务器不等待从服务器执行完写命令，就会返回结果给客户端，**无法实现强一致性保证**。

主从复制共有三种模式：**全量复制、基于长连接的命令传播、增量复制。**

#### 2.1、第一次同步

多台服务器通过replicaof命令形成主服务器、从服务器之间的关系。

```c
replicaof <服务器 A 的 IP 地址> <服务器 A 的 Redis 端口号>
在服务器B上执行，就会成为服务器A的从服务器。
```

##### 2.1.1、第一阶段：建立链接，协商同步

从服务器向主服务器发送psync命令，其中包括主服务器的ID、当前复制的进度，第一次同步进度是-1，代表全量复制。

主服务器会返回一个相应，表明接下来将采用**全量复制**的模式。

##### 2.1.2、第二阶段：主服务器同步数据给从服务器

主服务器执行bgsave命令，**异步生成RDB文件**，发送给从服务器。

从服务器收到后，会把之前数据全部清空，载入RDB文件。

##### 2.1.1、第三阶段：主服务器发送新的写操作给从服务器

在主服务器生成RDB、发送RDB、从服务器载入RDB的时期内，新发生的写操作需要用额外的缓存记录下来。

在从服务器完成RDB载入后，这期间在缓存中保存的新的写操作还得再发送给从服务器，保证主从数据一致。

#### 2.2、命令传播

主从服务器建立连接后，使用**基于长连接的命令传播**，也就是维护一个TCP连接，避免频繁建立、断开连接的开销。

> Q：Redis主从节点是长连接还是短链接？ 长连接。

#### 2.3、分摊主服务器的压力

从服务器太多时，如果主服务器一个个进行全量复制，主服务器压力太大。

在执行replicaof建立主从关系时，可以指向一个已经完成同步的从服务器，这样这个从服务器就会承担原本主服务器的工作，减轻主服务器压力。

#### 2.4、增量复制

在出现网络波动时，就会出现主从服务器的数据不一致。如果网络恢复后进行全量复制代价太大了，就进行**增量复制**，把断开期间主服务器收到的全部写操作，同步给从服务器。

- 从服务器在恢复网络后，会发送 **psync 命令**给主服务器，此时的 **psync 命令里的 offset 参数不是 -1**（-1是第一次同步用的，代表全量复制）；
- 主服务器收到该命令后，然后用 CONTINUE 响应命令告诉从服务器接下来采用**增量复制**的方式同步数据；
- 然后主服务将主从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令。

##### 2.4.1、主从服务器如何找出两者的同步差异？

主服务器中有一个**环形缓冲区**，保存最近的一些写操作。

主从服务器各有一个指针，指向不同的偏移量。网络恢复后，从服务器在psync命令中带上自己当前的偏移量，主服务器根据自己的指针和从服务器指针偏移量进行**增量复制**。

但是，如果从服务器的偏移量，已经超出了当前缓冲器保存的范围，也就是已经被覆盖了，就必须进行**全量复制**了。因此如果频繁发送全量复制，就要考虑是不是缓冲区太小了。

> 缓冲区大小的估算方式：可以按照**主从服务器断线的平均时间 * 主服务器平均每秒产生的写命令数量**来估算。

#### 2.5、如何判断Redis某个节点是否工作？

使用互相的ping - pong心跳检测机制，如果有一半以上的节点ping一个节点，没有pong回应，集群就认为这个节点挂掉了，断开与它的连接。主从节点心跳间隔和目的不一样：

- 主节点每隔10秒发送一次ping命令。主要是检查从节点是否还存活。
- 从节点每隔1秒发送一次自身复制偏移量给主节点。主要是上报自身偏移量，尽快检查主从不一致的部分。

#### 2.6、主从复制架构中，过期key的处理？

主节点处理了一个过期key，或者是淘汰了一个key，主节点就记录一条del命令，删除key并同步给从节点。从节点被动接收del命令，删除key。

#### 2.7、Redis是同步还是异步复制？

Redis 主节点每次收到写命令之后，先写到内部的缓冲区，然后**异步**发送给从节点。

#### 2.8、如何应对主从不一致？

主从节点的命令复制是异步的，无法实现强一致性保证。主节点只管把新的写命令发给从节点，但是并不管从节点什么时候完成这条命令。

- **尽可能保证网络状况良好。**
- **用一个外部程序监控主从复制进度**。Redis 的 INFO replication命令可以查看主节点接收写命令的进度、从节点复制写命令的进度，也就是二者的偏移量，可以用外部程序先检查两个偏移量的差距，超过某个阈值，就禁止从这个从节点获取数据。

#### 2.9、如何减少数据丢失？

主从切换时，产生数据丢失有两种情况：**异步复制同步丢失、集群脑裂数据丢失**。只能尽可能减少数据丢失，无法避免。

##### 2.9.1、异步复制数据丢失

Redis中有一个参数min-slaves-max-lag，一旦所有的从节点数据复制和同步延迟超过这个阈值，主节点就不再接收任何请求。

例如设为10s，一旦数据同步需要时间超过10s，就认为未来宕机后损失大量数据，拒绝写入新请求。

##### 2.9.2、集群脑裂数据丢失

在当前主节点网络出问题时，**哨兵**会通知应用方，选举出新的主节点。网络恢复后，原先的主节点只能成为从节点，但是从节点和新主节点同步时采用**全量同步**，这导致**旧主节点清空了自己的本地数据**，此前客户端写入的、还未来得及同步到新主节点的数据，就会丢失。

当主节点发现**从节点下线数量太多**、或者是**网络延迟太大**时，就禁止写操作，并直接返回错误给客户端。 在Redis配置文件可以设置主节点必须有的从节点连接数量、主从复制的最高延迟。

这样旧主节点假故障时，无法响应哨兵心跳，不能和从节点同步，会被**限制接收客户端请求**，避免这个期间写入新数据。一直到新的主节点上线后，才让新的主节点接收处理客户端请求，旧主节点数据被清空也就没关系了。

#### 2.10、主从如何做到故障切换？

从节点不能自动升级为主节点，需要Redis哨兵机制完成故障发现和转移，通知给应用方。

### 3、哨兵模式

Redis的主从服务器出现故障宕机时，需要手动进行恢复。Redis增加了**哨兵模式**，监控主从服务器，提供**主从节点故障转移**的功能。

#### 3.1、哨兵工作机制

哨兵节点主要负责三件事情：**监控、选主、通知**。

##### 3.1.1、如何判断主节点故障了？

哨兵每间隔1秒给所有主从节点发送ping命令，如果主节点没有在规定时间响应哨兵的ping，哨兵就会标记主节点为**主观下线**。

当一个哨兵判断主节点为主观下线后，就会向哨兵集群中的其他哨兵发起命令，其他哨兵根据自身和主节点的连接状况，做出赞成或拒绝的投票。当这个哨兵收到的**赞同票超过配置文件设定数值**后，主节点就会被这个哨兵标记为**客观下线**。

##### 3.1.2、为什么要有哨兵集群、主观下线？

因为某个主节点可能没有故障，只是一时的系统压力或者是网络卡顿。**为了减少误判，多个哨兵节点部署成哨兵集群（至少有3个哨兵节点）。**避免单个哨兵因为自身网络不好导致误判主节点下线。

##### 3.1.3、哪个哨兵进行主从故障转移？

主动发起主节点下线投票的哨兵会成为**候选者**，所有哨兵需要对候选者进行投票，每个哨兵一票，并且只有候选者可以投给自己。满足条件的候选者成为**领导者**。领导者负责执行主从故障转移。 

候选者必须拿到**半数以上**赞成票，并且票数**超过配置文件的阈值**quorum。一次选举选不出，就重新选举。

多个候选者同时产生时，哨兵会投票给自己最先接收到投票请求的那个候选者。也正因此哨兵节点至少要有3个，否则2个哨兵同时成为候选者都会投给自己，永远无法选择出领导者。

> 实际使用中，如果一些哨兵节点挂掉了，**剩下的哨兵数量少于3或者是少于投票阈值quorum**，就会导致无法选出领导者。
>
> 此外，哨兵节点的数量最好是奇数，尽可能避免选不出的情况。

#### 3.2、主从故障转移方式

##### 3.2.1、选出新节点

在旧主节点的所有从节点，跳出一个从节点作为新的主节点。

- 首先过滤掉网络连接状态不好的节点，已经下线的从节点、断连次数过多的从节点就被认为连接状态不好。
- 考察节点**优先级**。Redis每个节点都能设定优先级，可以把物理内存大的、资源更多的节点设定更大优先级。
- 优先级相同时，考察**复制进度**。最接近旧主节点写进度的从节点胜出。
- 复制进度相同时，考察ID。节点ID更小的节点胜出。

##### 3.2.2、从节点指向新主节点

将旧主节点的所有从节点指向新的主节点，通过发送slaveof命令实现。

##### 3.2.3、通知客户主节点发生了更换

通过Redis的**发布者/订阅者机制**通知客户端。客户端建立连接后，客户端会订阅烧饼的频道。主从切换完成后，哨兵会发布新主节点的IP地址和端口。

##### 3.2.4、旧主节点变为从节点

继续监视旧主节点，等到它上线后，哨兵集群向他发送slaveof命令，让新的主节点成为它的主节点。

#### 3.3、哨兵集群如何组成

哨兵集群通过Redis的**发布者/订阅者**机制互相发现。

主从集群中，主节点上有一个频道供所有哨兵使用，哨兵把自己的IP和端口发布到这个频道上，其他哨兵就能获取这个信息与之通信。

##### 3.3.1、哨兵如何与从节点通信？

哨兵每隔10s向主节点发送一次info命令，获取当前从节点信息。哨兵根据主节点处获得的信息，与从节点建立连接，监控从节点。 

### 4.集群模式

#### 4.1、切片集群模式

Redis缓存**数据量大到一台服务器无法缓存**时，需要使用**Redis切片集群**方案，将**数据分布在不同服务器**上，降低系统对单主节点的依赖，提高Redis服务的读写性能。

Redis Cluster方案采用**哈希槽**，处理**数据和节点的映射**关系。一个切片集群有16384个哈希槽。根据键值对应的key按照CRC16算法计算一个16bit的值，再用16bit的值对16384取模，得到对应编号的哈希槽。

哈希槽映射到具体的Redis节点上时，可以采用平均分配、手动分配的方式。

#### 4.2、集群脑裂

**问题描述**：网络出现问题时，主节点就无法正常通信，哨兵会认为主节点出问题了，在从节点中选择一个新节点作为主节点，产生了多个主节点，就是**集群脑裂**问题。但是随后网络恢复，原先的主节点就会被哨兵降级成从节点。这导致旧主节点在这段时间与客户端通信写入的数据，可能没能全部正确同步到从节点上，导致了数据丢失。

**解决方案：主节点连接的从节点太少**，或者**主从复制和同步的延迟**超过阈值时，禁止主节点写数据，直接把错误返回客户端。

这要求主库至少要连接N个从库，和主库进行数据复制的ACK消息延迟不能超过T秒，否则主库就不会再接收客户端请求。新主库上线时，就**只有新主库能接收和处理**客户端请求，新写的数据会直接写在新主库中，原主库被哨兵降级为从库。
