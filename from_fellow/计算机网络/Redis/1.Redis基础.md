## 一、Redis基础

### 1、Redis是什么？

Redis是一种**基于内存**的数据结构存储，对数据的读写操作都是在内存中完成，读写速度非常快，用于**缓存、消息队列、分布式锁**的场景。对数据类型的操作都是**原子性**的，执行命令都是单线程负责的，不存在并发竞争问题。

Redis 还支持**事务 、持久化、Lua 脚本、多种集群方案（主从复制模式、哨兵模式、切片机群模式）、发布/订阅模式，内存淘汰机制、过期删除机制**等等。

### 2、为什么用Redis作为MySQL的缓存？

因为Redis具备**高性能**、**高并发**两种特性。

#### 2.1、Redis的高性能

用户在第一次访问MySQL数据之后，就会缓存在Redis中，下一次操作就直接从缓存读取，操作的是内存，速度比操作磁盘快。这需要解决Redis和MySQL双写一致性的问题。

#### 2.2、Redis的高并发

单台设备的Redis的QPS（Query Per Second 每秒钟处理完请求的次数）是MySQL的10倍。Redis可以轻松做到单机10W以上。

### 3、Redis数据结构

### 4、Redis线程模型

#### 4.1、Redis单线程

单线程指的是Redis的**单线程模式**：将接受客户端请求、解析请求、数据读写、发送数据给客户端的操作交给一个主线程完成。

Redis**程序并不是单线程**的，Redis启动时，会启动后台线程，分别处理关闭文件、AOF刷盘、异步释放Redis内存的lazyfree线程。

因为关闭文件、AOF刷盘、释放内存这些操作非常耗时，会阻塞主线程，这三个操作都有各自的任务队列。

#### 4.2、单线程为什么还能高并发

- Redis大部分操作都在**内存**完成，并且数据结构更高效。Redis的瓶颈是内存和网络带宽，而不是CPU。
- Redis的**单线程模型**避免了多线程的竞争，也避免了线程切换的开销。
- Redis采用了**I/O多路复用**机制，处理大量的客户端Socket请求。一个线程处理多个I/O流，内核中存在多个监听和已连接Socket，内核一直监听这些Socket。

#### 4.3、Redis 6之后为什么引入多线程？

Redis单线程可以避免线程切换开销和带来的风险。但是随着网络硬件性能提升，Redis的瓶颈可能发生在网络I/O上，Redis 6就对网络I/O采用多线程处理，但是命令的执行，仍然是单线程，只是引入多线程提高网络I/O效率。

### 5、Redis持久化

Redis读写在内存中，重启后数据就会丢失，Redis实现了三种持久化数据到磁盘的机制。



### 6、Redis集群







## 二、Redis实战

### 1、Redis实现延迟队列

把当前要做的一些事情，往后推迟一段时间再做，例如网购付款时，超过一段时间未付款，订单就会取消。Redis可以使用**有序集合ZSet**实现延迟消息队列，ZSet中有一个属性存储延迟执行的时间。

### 2、Redis如何处理大key？

大key指的是key对应的value很大。一般而言，下面这两种情况被称为大 key：

- String 类型的值大于 10 KB；
- Hash、List、Set、ZSet 类型的元素的个数超过 5000个；

#### 2.1、大key的问题

大key会带来一些问题：

- **客户端超时阻塞**。Redis单线程处理大key过于耗时，造成了客户端阻塞。
- **引发网络阻塞**。每次获取大key需要很多网络流量，导致服务器返回了很多数据量，造成网络压力。
- **阻塞工作线程**。使用del删除大key，导致工作线程被阻塞。
- **内存分布不匀**。集群模型再slot分片均匀时，会出现数据和查询倾斜，这在部分有大key的Redis节点上会导致占用内存特别多，QPS特别大。

#### 2.2、大key删除

删除操作会带来内存释放，内存释放后，会把空闲内存放入系统的空闲块链表中，这个过程需要一些时间。如果大量释放内存，**空闲内存块链表操作时间会增加**，导致**其他Redis操作超时**。

##### 2.2.1、分批次删除

删除大hash时，使用hscan命令，每次获取100个字段，再用hdel命令，每次删除1个字段。

##### 2.2.2、异步删除

用unlink代替del删除，unlink会把key放在一个异步线程中删除，不会阻塞主线程。

### 3、Redis管道

管道可以用于客户端一次**批处理多个命令**，提高交互性能。Redis管道技术可以解决多个命令执行时的网络等待，客户端可以将多个命令整合到一起发送给服务端，服务端处理好后，再一并返回给客户端，避免了每条命令都需要等待。

管道技术本质上是客户端提供的功能，不是Redis服务端的功能，也需要注意避免发送命令过大，管道数据过多导致网络阻塞。

### 4、Redis事务回滚

MySQL通过 undo log实现事务回滚，但是Redis不支持事务回滚。Redis不能保证事务原子性，Redis的discard命令也只能主动放弃事务执行，起不到回滚效果。

因为Redis设计者认为回滚这种复杂机制与Redis的简单高效不符合，并且回滚发生在程序出错的时候，很少在生产中出现。

### 5、Redis分布式锁

分布式锁用于分布式环境下，并发控制某一个资源在某个时刻只能被一个应用使用。

优点：

- **性能高效**，这是分布式锁的关键要素。
- **实现方便。**Redis提供了setnx方法，可以直接实现分布式锁。
- **避免单点故障**。Redis是跨集群部署的，避免了单点故障。

缺点：

- **超时时间不好设置**。超时时间太长会影响性能。超时时间设置太短又起不到共享资源的保护作用，导致一些线程任务执行完之前就放弃了锁，锁被其他线程获取。
- Redis主从复制模式的数据是异步复制的，导致**分布式锁的不可靠**。如果Redis主节点获取到锁后，没有同步到其他节点，主节点宕机了，此时新的主节点也能获取到锁，导致多个应用服务同时获取到锁。

#### 5.1、如何保证Redis集群情况下，Redis分布式锁的可靠性？

Redis设计了一个分布式锁算法——红锁，是**基于多个Redis节点的分布式锁**。即使有节点发生了故障，锁变量还存在，客户端还是能完成锁操作。

让**客户端和多个独立的Redis节点依次请求申请加锁**，如果客户端能够和**半数以上的节点完成加锁**，就认为客户端成功获得分布式锁，否则加锁失败。这导致即使有Redis节点发生故障，锁的数据在其他节点也有保存，客户端仍然可以正常进行锁操作。
