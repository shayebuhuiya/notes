https://zhuanlan.zhihu.com/p/613630658

### 是什么

* **多进程并发**

  使用多进程并发是将一个应用程序划分为多个独立的进程（每个进程只有一个线程），这些独立的进程间可以互相通信，共同完成任务。由于操作系统提供了大量的保护机制，以避免一个进程修改了另一个进程的数据，使用多进程比使用多线程更容易写出相对安全的代码。但是这也就造就了多进程并发的两个缺点

  1. 在进程间的通信，无论是使用信号、套接字，还是文件、管道等方式，其使用要么比较复杂，要么就是速度较慢或者两者兼有之。
  2. 运行多个线程的开销很大，操作系统要分配很多的资源来对这些进程进行管理。

  当多个进程并发完成同一个任务时，不可避免地是：**操作同一个数据和进程间的相互通信**，上述的两个缺点也就决定了多进程的并发并不是一个好的选择，所以就引入了多线程的并发。

* **多线程并发**

  多线程并发指的是在同一个进程中执行多个线程。

  优点：线程是轻量级的进程，每个线程可以独立的运行不同的指令序列，但是线程不独立的拥有资源，依赖于创建它的进程而存在。也就是说，同一个进程中的多个线程共享相同的地址空间，可以访问进程中的大部分数据，指针和引用可以在线程间进行传递。这样，同一个进程的多个线程可以很方便的进行数据共享以及通信，这就比进程更适用于并发操作。

  缺点：由于缺少操作系统提供的保护机制，在多线程共享数据及通信时，就需要程序员做更多的工作以保证对共享数据段的操作是以预想的操作顺序进行的，并且要极力的避免死锁。

![image-20230420105928578](C:\Users\24859\AppData\Roaming\Typora\typora-user-images\image-20230420105928578.png)

六线程vs单线程

### 怎么用

1. **头文件**

   1. thread
   2. mutex
   3. atomic
   4. condition_variable
   5. future

   ![img](https://pic2.zhimg.com/v2-76e5e48c9c1d60f9868452cfc9ce7d85_r.jpg)

2. **创建线程**

   创建线程只需要把函数添加到线程中就可以了。

   ~~~c++
   //1
   //创建名为myThread的子线程，主线程等子线程结束后再退出
   void thread_fun(arg...);
   std::thread myThread(thread_fun, arg...);
   myThread.join();
   
   //2
   //创建没有名字的线程，主线程运行完后直接销毁所有子线程
   std::thread(thread_fun, arg...).detach();
   ~~~

   **join与detach方式**

   当线程启动后，一定要在和线程向关联的thread销毁前，确定以何种方式等待线程执行结束。

   **join()**：等待启动的线程完成，才会继续往下执行。

   **detach()**：启动的线程自主在后台运行，当前的代码继续往下执行，不必等待新线程结束。

   **this_thread**

   this_thread为一个命名空间，里面有四种方法

   * get_id(): 获取线程唯一id
   * yield(): 让当前线程让出cpu，让其他线程有机会运行
   * sleep_for(): 可以使当前线程休眠指定的时间，单位为毫秒，也可以调用std::chrono::seconds(x)转换为秒
   * sleep_until(): 指定时间开始运行

3. **互斥量mutex**

   * **std::mutex**：最基本的mutex类
   * **std::recursive_mutex**：递归mutex类
   * **std::time_mutex**：定时mutex类
   * **std::recursive_timed_mutex**：定时递归mutex类



